data SimpleRow (Ty : KEnv → Kind → Set) Δ : Kind → Set
       

--------------------------------------------------------------------------------
-- Simple rows
--
-- Simple rows are indexed by an abstract Ty : KEnv → Kind → Set
-- so that they can be reused later by NormalType.

labels : ∀ {Ty : KEnv → Kind → Set} → SimpleRow Ty Δ R[ κ ] → List Label 

infixr 0 _▹_⸴_
data SimpleRow Ty Δ where 
       _▹_ : 
              (ℓ : Label) → (τ : Ty Δ κ)  → 
              ------------------------
              SimpleRow Ty Δ R[ κ ]

       _▹_⸴_ : ∀ (ℓ : Label) → 
                  (τ : Ty Δ κ) →
                  (ρ : SimpleRow Ty Δ R[ κ ]) → -- {noDup : True (ℓ ∉? labels ρ)} → 
                  ----------------------------------------------- 
                  SimpleRow Ty Δ R[ κ ]

labels (ℓ ▹ τ) = ℓ ∷ []
labels (ℓ ▹ τ ⸴ ρ) = ℓ ∷ labels ρ 

--------------------------------------------------------------------------------
-- Simple rows are bijective to simpler rows

--------------------------------------------------------------------------------
-- NoDuplicate predicate on simple rows

NoDup : List Label → Set
NoDup xs = ∀ (x : Label) → Irrelevant (x ∈ xs)

-- The NoDup predicate is decidable
noDup? : (xs : List Label) → Dec (NoDup xs)
noDup? [] = yes (λ { x ()  })
noDup? (x ∷ xs) with _∈?_ x xs 
... | yes p = no (λ noDup → absurd∈ (noDup x (there p) (here refl)))
... | no p with noDup? xs 
...         | yes noDup = yes (λ { y (here refl) (here refl) → refl
                             ; y (here refl) (there p₂) → ⊥-elim (p p₂)
                             ; y (there p₁) (here refl) → ⊥-elim (p p₁)
                             ; y (there p₁) (there p₂) → cong there (noDup y p₁ p₂) } ) 
...         | no  yesDup = no (λ noDup → yesDup (λ { y (here refl) (here refl) → refl
                                                   ; y (here refl) (there p₂) → there-injective (noDup y (there (here refl)) (there (there p₂)))
                                                   ; y (there p₁) (here refl) → there-injective (noDup y (there (there p₁)) (there (here refl)))
                                                   ; y (there p₁) (there p₂)  → there-injective (noDup y (there (there p₁)) (there (there p₂))) })) 

--------------------------------------------------------------------------------
-- Simple rows are well formed if they contain no duplicates

WFRow : ∀ {Ty} → SimpleRow Ty Δ R[ κ ] → Set
WFRow ρ = True (noDup? (labels ρ))

-- Any proof that ρ has no duplicates is identical
IrrelevantWFRow : ∀ {Ty} (ρ : SimpleRow Ty Δ R[ κ ])  → Irrelevant (WFRow ρ)
IrrelevantWFRow (ℓ ▹ τ) p₁ p₂ = refl
IrrelevantWFRow (ℓ ▹ τ ⸴ ρ) p₁ p₂ with ℓ ∈? labels ρ
... | yes p = refl
... | no p  with labels ρ | noDup? (labels ρ)
...              | c | yes q = refl
...              | c | no  q = refl

SimpleRow2 : (ls : List Label) → True (noDup? ls) → Set₁
SimpleRow2 ls nd = ∀ {Ty : KEnv → Kind → Set} {Δ : KEnv} {κ : Kind} → (ℓ : Label) → (ℓ ∈ ls) → Ty Δ R[ κ ]


--------------------------------------------------------------------------------
-- Mapping over simple rows
-- 
-- It is easy to show that mapping preserves labels... but it won't be possible 
-- to *use* mapSimpleRow without violating termination checking.

mapSimpleRow : ∀ {Ty : KEnv → Kind → Set} → 
                 (f : Ty Δ₁ κ₁ → Ty Δ₂ κ₂)  → 
                 SimpleRow Ty Δ₁ R[ κ₁ ] → SimpleRow Ty Δ₂ R[ κ₂ ]
labelsFixedByMap : ∀ {Ty : KEnv → Kind → Set} → 
                     (f : Ty Δ₁ κ₁ → Ty Δ₂ κ₂) → 
                     (sr : SimpleRow Ty Δ₁ R[ κ₁ ]) → 
                     labels (mapSimpleRow f sr) ≡ labels sr

mapSimpleRow f (ℓ ▹ τ) = ℓ ▹ (f τ)
mapSimpleRow f ((ℓ ▹ τ ⸴ ρ)) = 
       (ℓ ▹ (f τ) ⸴ mapSimpleRow f ρ) 
labelsFixedByMap f (ℓ ▹ τ) = refl
labelsFixedByMap f (ℓ ▹ τ ⸴ ρ) rewrite labelsFixedByMap f ρ = refl

cong-SimpleRow : (sr : SimpleRow Type Δ R[ κ ]) {wf₁ : WFRow sr} {wf₂ : WFRow sr} → 
                ⦅ sr ⦆ wf₁ ≡ ⦅ sr ⦆ wf₂
cong-SimpleRow sr {wf₁} {wf₂} rewrite IrrelevantWFRow sr wf₁ wf₂ = refl
