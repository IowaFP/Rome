\documentclass[sigplan,10pt,anonymous,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
\overfullrule=1mm
% \usepackage[margin=1.5in]{geometry}

\include{header.tex} 
\usepackage{agda}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% ACM garbage
\setcopyright{none}
\citestyle{acmauthoryear}
\settopmatter{printacmref=false, printfolios=true}
\renewcommand{\footnotetextcopyrightpermission}{} 
% Redefine the \acmDOI command to do nothing 
\pagestyle{empty}
\fancyfoot{}

%\usepackage[utf8]{inputenc}
% \numberwithin{equation}{section}
% \numberwithin{theorem}{section}

\title{Normalization By Evaluation of Types in \Rome}
\author{Alex Hubers}
\orcid{0000-0002-6237-3326}
\affiliation{
  \department{Department of Computer Science}
  \institution{The University of Iowa}
  \streetaddress{14 MacLean Hall}
  \city{Iowa City}
  \state{Iowa}
  \country{USA}}
\email{alexander-hubers@uiowa.edu}

\usepackage{newunicodechar}
\newunicodechar{âˆ‹}{$\ni$}
\newunicodechar{Îµ}{$\epsilon$}
\newunicodechar{Â·}{$\cdot$}
\newunicodechar{âŠ¢}{$\vdash$}
\newunicodechar{â‹†}{${}^\star$}
\newunicodechar{Î }{$\Pi$}
\newunicodechar{â‡’}{$\Rightarrow$}
\newunicodechar{Æ›}{$\lambdabar$}
\newunicodechar{âˆ…}{$\emptyset$}
\newunicodechar{âˆ€}{$\forall$}
\newunicodechar{Ï•}{$\Phi$}
\newunicodechar{Ï†}{$\phi$}
\newunicodechar{Ïˆ}{$\Psi$}
\newunicodechar{Ï}{$\rho$}
\newunicodechar{Î±}{$\alpha$}
\newunicodechar{Î²}{$\beta$}
\newunicodechar{Î¼}{$\mu$}
\newunicodechar{Ïƒ}{$\sigma$}
\newunicodechar{â‰¡}{$\equiv$}
\newunicodechar{Î“}{$\Gamma$}
\newunicodechar{âˆ¥}{$\parallel$}
\newunicodechar{Î›}{$\Lambda$}
\newunicodechar{â‚‚}{$_2$}
\newunicodechar{Î¸}{$\theta$}
\newunicodechar{Î˜}{$\Theta$}
\newunicodechar{âˆ˜}{$\circ$}
\newunicodechar{Î”}{$\Delta$}
\newunicodechar{â˜…}{$\star$}
\newunicodechar{Î»}{$\lambda$}
\newunicodechar{âŠ§}{$\models$}
\newunicodechar{âŠŽ}{$\uplus$}
\newunicodechar{Î·}{$\eta$}
\newunicodechar{âŠ¥}{$\bot$}
\newunicodechar{Î£}{$\Sigma$}
\newunicodechar{Î¾}{$\xi$}
\newunicodechar{â‚}{$_1$}
\newunicodechar{â‚–}{$_k$}
\newunicodechar{â‚ƒ}{$_3$}
\newunicodechar{â„•}{$\mathbb{N}$}
\newunicodechar{á¶œ}{${}^c$}
\newunicodechar{Î¦}{$\Phi$}
\newunicodechar{Î¨}{$\Psi$}
\newunicodechar{âŠ¤}{$\top$}
\newunicodechar{Îº}{$\kappa$}
\newunicodechar{Ï„}{$\tau$}
\newunicodechar{Ï€}{$\pi$}
\newunicodechar{âŒŠ}{$\lfloor$}
\newunicodechar{âŒ‹}{$\rfloor$}
\newunicodechar{â‰²}{$\lesssim$}
\newunicodechar{â–¹}{$\triangleright$}
\newunicodechar{â„“}{$\ell$}
\newunicodechar{Ï…}{$\upsilon$}

\newunicodechar{â†’}{$\rightarrow$}
\newunicodechar{Ã—}{$\times$}
\newunicodechar{Ï‰}{$\omega$}
\newunicodechar{âˆƒ}{$\exists$}
\newunicodechar{âˆˆ}{$\in$}
\newunicodechar{â‡‘}{$\Uparrow$}
\newunicodechar{â‡“}{$\Downarrow$}
\newunicodechar{â‰‹}{$\approx$}
\newunicodechar{â‚—}{$_l$}
\newunicodechar{áµ£}{$_r$}
\newunicodechar{âŸ¦}{$\llbracket$}
\newunicodechar{âŸ§}{$\rrbracket$}
\newunicodechar{â»}{$^{-}$}
\newunicodechar{Â¹}{$^{1}$}
\newunicodechar{â‚„}{$_{4}$}
\newunicodechar{â¦…}{$\llparenthesis$}
\newunicodechar{â¦†}{$\rrparenthesis$}
\newunicodechar{â”€}{$\setminus$}
\newunicodechar{âˆ·}{$\co\co$}
\newunicodechar{â‚–}{$_{k}$}
\newunicodechar{â‚™}{$_{n}$}
\newunicodechar{â‰Ÿ}{$\overset{?}{=}$}
\newunicodechar{ð’¯}{$\mathcal T$}
\newunicodechar{â¨¾}{$\co$}
\newunicodechar{Îž}{$\Xi$}
\newunicodechar{Î¾}{$\xi$}

\begin{document}
\InlineOn{}

\maketitle

\section*{Abstract}
\citet{HubersIMM24} introduce \Rome, a higher-order row calculus with first-class labels, iso-recursive types, and label-generic operators, but do not describe any metatheory of its type equivalence relation nor of type reduction. This paper shows not only that \Rome types enjoy normal forms, but formalizes the normaliz\-ation\--by\--evaluation (NbE) of types in the interactive proof assistant Agda. We prove that our normalization algorithm is stable, sound and complete with respect to the type equivalence relation. Consequently, type conversion in \Rome is decidable.

\section{Introduction}
\citet{HubersM23} introduce an expressive higher-order row calculus called \RO for \emph{generic programming} with rows. \RO is a row calculus with first-class labels, higher-order type computation, and label-generic combinators. System \RO is rooted in System \FO, but incurs additional type-level computation from maps over rows. In practice, expressing types in \RO relies on implicit type reductions according to a type equivalence relation. Despite this reliance, the authors only provide a proof of \emph{semantic soundness} that well-typed terms inhabit the denotations of well-kinded types. The authors show that their denotation is \emph{sound} with respect to type equivalence---that is, that equivalent types incur the same denotation. However, the authors do not characterize the shape of types in normal form, nor prove that the denoted types are complete with respect to type equivalence. \citet{HubersIMM24} extends the \RO language to \Rome, which is \RO with recursive types, term-level recursion, and a novel \emph{row complement} operator. The authors similarly extend the proof of semantic soundness, but fail to describe any metatheory of the equivalence relation. We argue that an explicit treatment of type normalization is necessary for practical use of the \RO and \Rome languages.

\subsection{The need for type normalization}
\label{sec:need-for-type-normalization}
\RO and \Rome each have a type conversion rule. The rule below states that the term $M$ can have its type converted from $\tau$ to $\upsilon$ provided a proof that $\tau$ and $\upsilon$ are equivalent. (For now, let us split environments into kinding environments $\Delta$, evidence environments $\Phi$, and typing environments $\Gamma$.)

\[ 
\ib{\irule[\trule{conv}]
          {\TypeJ \Delta \Phi \Gamma M \tau}
          {\TEqvJ \Delta \tau \upsilon \TypeK};
          {\TypeJ \Delta \Phi \Gamma M \upsilon}}
\] 

Conversion rules can complicate metatheory in an intrinsic setting. \Citet{HubersM23,HubersIMM24} each provide an intrinsic semantics, but do not provide a procedure to decide type checking or type equivalence. Under an intrinsic semantics, proofs of type conversion are de facto embedded into the term language (that is, the language of typing derivations). This has a number of consequences:
\begin{enumerate}[nolistsep]
  \item Users of the surface language are forced to write conversion rules by hand.  
  \item Decidability of type checking now rests upon the decidability of type conversion.
  \item Term-level conversions can block $\beta$-reduction if a conversion is in the head position of an application. 
  \item Term-level conversions can block proofs of progress. Let !M! have type !tau!, let !pf! be a proof that !tau = upsilon!, and consider the term !conv! !M! !pf!; ideally, one would expect this to reduce to !M! (we've changed nothing semantically about the term). But this breaks type preservation, as !conv! !M! !pf! (at type !upsilon!) has stepped to a term at type !tau!. 
  \item Inversion of the typing judgment $\TypeJ \Delta \Phi \Gamma  M \tau$---that is, induction over derivations---must consider the possibility that this derivation was constructed via conversion. But conversion from what type? Proofs by induction over derivations often thus get stuck. 
\end{enumerate}

All of these complications may be avoided provided a sound and complete normalization algorithm. In such a case, all types are reduced to normal forms, where syntactic comparison is enough to decide equivalence. In effect, the proofs of all conversions have collapsed to just the reflexive case, and so term-level conversions can safely be reduced without violating type preservation.

\subsection{Contributions}
This paper offers the following as contributions: 

\begin{enumerate}
  \item A normalization procedure for the directed \Rome type equivalence relation, which in turn yields a decision procedure for type equivalence;
  \item a semantics of the type-level \emph{row complement} operator;
  \item proofs of soundness and completeness of normalization with respect to type equivalence; and
  \item a complete mechanization in Agda of \Rome and the claimed metatheory.
\end{enumerate}

In summary, we offer the first mechanized, sound and complete normalization algorithm for higher-order row types, which we hope future adopters may use as a framework for additional row-based type  computation.

\section{Background}
We briefly review the literature on row typing. Row types, as introduced by \citet{wand87}, describe a type-level association of labels to types. Rows can be used dually to type \emph{records} (i.e, classes and objects) and \emph{variants} (i.e., algebraic data types). Row types were first introduced by \citet{wand87,Wand91,Remy89} to give a \emph{structural} account of object inheritance, in which records and variants are seen as equal when their structures agree. For example, the two-dimensional point record !p! !=! !{x := 1,! !y := 2}! might be assigned the record type !Pi! !{x := Int,! !y := int}! in a row-type system. Extensibility in row type systems arises from \emph{row polymorphism}. A function that expects a record with \emph{at least} the the fields !{x := Int , y := int}! will be happy to accept !p!; one could type such a function as accepting the row !{x := Int,! !y := Int! !|! !rho}!, where !rho! is a row variable denoting "zero or more additional fields".

Over the years, many novel applications of rows to other domains have been proposed, including first-class mixins \citep{MakholmW05}, session types \citep{LindleyM17}, and most notably effect typing \citep{Leijen05,Leijen14,LindleyC12,HillerstromL16}. The algebraic effects literature, which handles label overlaps via \emph{shadowing}, has indeed popularized the use of rows in type systems for purposes beyond just extensibility. Correspondingly, The \Rose language \citep{MorrisM19}, from which \RO and \Rome extend, first sought to reconcile varying accounts of label overlap resolutions into \emph{row theories}. 

We view \Rome as a highly-expressive candidate core calculus for many row theories and applications.


\section{The \Rome{} calculus}
\label{sec:Rome-calculus}

\Cref{fig:syntax-types} describes the syntax of kinds, predicates, and types in \Rome. We omit any description of the term calculus, but refer the reader to \citet{HubersIMM24}. For our purposes, it is sufficient to be able to parse and understand the intent of \Rome types as a specification. 

\begin{figure}
\begin{gather*}
\begin{array}{r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l}
\text{Type variables} & \alpha \in \mathcal A & \text{Labels} & \ell \in \mathcal L
\end{array}
\\[5px]
\begin{doublesyntaxarray}
  \mcl{\text{Kinds}} & \kappa & ::= & \TypeK \mid \LabK \mid \RowK \kappa \mid \kappa \to \kappa \\
  \mcl{\text{Predicates}} & \pi, \psi & ::= & \LeqP \rho \rho \mid \PlusP \rho \rho \rho \\
  \text{Types} & \mcr{\Types \ni \phi, \tau, \rho, \xi} & ::= & \alpha \mid T \mid  \tau \to \tau \mid \pi \then \tau \\
               &                              &     & \mid    & \forall \alpha\co\kappa. \tau \mid \lambda \alpha\co\kappa. \tau \mid \tau \, \tau\\
               &                              &     & \mid    & \RowIx i 0 m {\LabTy {\xi_i} {\tau_i}} \mid \ell \mid \Sing{\tau} \\ 
               &                              &     & \mid    & \Mapp{\phi}{\rho} \mid \rho \Compl \rho \\
  \mcl{\text{Type constants}} & T & ::= & \KFam \Pi \kappa \mid \KFam \Sigma \kappa \mid \mu \\
\end{doublesyntaxarray}
\end{gather*}
\caption{Syntax}
\label{fig:syntax-types}
\end{figure}

Labels (i.e., record field and variant constructor names) live at the type level, and are classified by kind $\LabK$. Rows of kind $\kappa$ are classified by $\RowK \kappa$. When possible, we use $\phi$ for type functions, $\rho$ for row types, and $\xi$ for label types. Singleton types $\Sing \tau$ are used to cast label-kinded types to types at kind $\TypeK$.  $\Mapp\phi \rho$ maps the type operator $\phi$ across a row $\rho$. In practice, we often leave the map operator implicit, using kind information to infer the presence of maps. We define a families of  $\Pi$ and $\Sigma$ constructors, describing record and variants at various kinds; in practice, we can determine the kind annotation from context. The constant $\mu$ builds isorecursive types. Row literals (or, synonymously, \emph{simple rows}) are sequences of labeled types $\LabTy {\xi_i} {\tau_i}$. We write $0 \dots m$ to denote the set of naturals up to (but not including) $m$. We will frequently use $\varepsilon$ to denote the empty row. In some cases, we will treat rows as lists of associations, e.g writing $\Row{\LabTy \ell \tau , \rho}$, purely as metatheoretic notation; rows in \Rome are not built by extension but rather by concatenation.

The type $\pi \then \tau$ denotes a qualified type. In essence, the predicate $\pi$ restricts the instantiation of the type variables in $\tau$. Our predicates capture relationships among rows: $\LeqP {\rho_1} {\rho_2}$ means that $\rho_1$ is \emph{contained} in $\rho_2$, and $\PlusP {\rho_1} {\rho_2} {\rho_3}$ means that $\rho_1$ and $\rho_2$ can be \emph{combined} to give $\rho_3$.

Finally, $\Rome$ introduces a novel \emph{row complement} operator $\rho_2 \Compl \rho_1$, analogous to set complements. The complement $\rho_2 \Compl \rho_1$ intuitively means the row obtained by removing any label-type associations in $\rho_1$ from $\rho_2$. In practice, the type $\rho_2 \Compl \rho_1$ is meaningful only when we know that $\LeqP {\rho_1} {\rho_2}$, however constraining the formation of row complements to just this case introduces an unpleasant dependency between predicate evidence and type well-formedness. In practice, it is easy enough to totally define the complement operator on all rows, even without the containment of one by the other. 

\subsection{Type computation in \Rome}
\RO and \Rome are quite expressive languages, with succinct and readable types. To some extent, this magic relies on implicit type application, implicit maps, and unresolved type reduction. Let us demonstrate with a few examples.

\subsubsection{Reifying variants, reflecting records} The following \RO terms witness the duality of records and variants. 

\begin{rosi}
reify : forall z : R[ * ], t : *. 
        (Sigma z -> t) -> Pi (z -> t)
reflect : forall z : R[ * ], t : *. 
          Pi (z -> t) -> Sigma z -> t
\end{rosi}

The term !reify! transforms a variant eliminator into a record of individual eliminators; the term !reflect! transforms a record of individual eliminators into a variant eliminator. The syntax above is precise, but arguably so because it hides some latent computation. In particular, what does !z -> t! mean? The variable !z! is at kind !R[ * ]! and !t! at kind !*!, so this is an implicit map. Rewriting explicitly yields: 

\begin{rosi}
  reify : forall z : R[ * ], t : *. 
          (Sigma z -> t) -> Pi ((\s. s -> t) .map. z)
reflect : forall z : R[ * ], t : *. 
          Pi ((\s. s -> t) .map. z) -> Sigma z -> t
\end{rosi}

\Ni The writing of the former rather than the latter is permitted because the corresponding types are convertible.


\subsubsection{Deriving functorality} We can simulate the deriving of functor typeclass instances: given a record of !fmap! instances at type !Pi (Functor z)!, we can give a !Functor! instance for !Sigma z!. 

\begin{rosi}
type Functor : (* -> *) -> *
type Functor = \f. forall a b. (a -> b) -> f a -> f b
fmapS : forall z : R[* -> *]. 
        Pi (Functor z) -> Functor (Sigma z)
\end{rosi}

\Ni When we consider the kind of !Functor z! it becomes apparent that this is another implicit map. Let us write it explicitly and also expand the !Functor! type synonym:

\begin{rosi}
fmapS : forall z : R[* -> *]. 
      Pi ((\f. forall a b. 
        (a -> b) -> f a -> f b) .map. z) -> 
      (\f. forall a b. (a -> b) -> f a -> f b) (Sigma z)
\end{rosi}

\Ni which reduces further to:

\begin{rosi}
fmapS : forall z : R[* -> *]. 
        Pi ((\f. forall a b. 
            (a -> b) -> f a -> f b) .map. z) -> 
        forall a b. (a -> b) -> (Sigma z) a -> (Sigma z) b
\end{rosi}

\Ni Intuitively, we suspect that !(Sigma z) a! means "the variant of type constructors z applied to the type variable !a!". Let us make this intent obvious. First, define a "left-mapping" helper !_??_!  with kind !R[ * -> * ] -> * -> R[ * ]!  as so:

\begin{rosi}
  r ?? t = (\ f. f t) .map. r
\end{rosi}

\Ni Now the type of !fmapS! is:

\begin{rosi}
fmapS : forall z : R[* -> *]. 
        Pi ((\f. forall a b. 
            (a -> b) -> f a -> f b) .map. z) -> 
        forall a b. (a -> b) -> Sigma (z ?? a) -> Sigma (z ?? b)
\end{rosi}

\Ni And we have what appears to be a normal form. Of course, the type is more interesting when applied to a real value for !z!. Suppose !z! is a functor for naturals, !{'Z := const Unit,! !'S := \x. x}!. Then a first pass yields:

\begin{rosi}
fmapS {'Z := const Unit, 'S := \x. x} : 
        Pi ((\f. forall a b. (a -> b) -> f a -> f b) 
          .map. {'Z := const Unit, 'S := \x. x}) -> 
        forall a b. (a -> b) -> 
        Sigma ({'Z := const Unit, 'S := \x. x} ?? a) -> 
        Sigma ({'Z := const Unit, 'S := \x. x} ?? b)
\end{rosi}

How do we reduce from here? Regarding the first input, we suspect we would like a record of fmap instances for both the !'Z! and !'S! functors. We further intuit that the subterm !({'Z := const Unit,! !'S := \x. x}! !??! !a)! really ought to mean "the row with !'Z! mapped to !Unit! and !'S! mapped to !a!". Performing the remaining reductions yields:

\begin{rosi}
fmapS {'Z := const Unit, 'S := \x. x} : 
        Pi {'Z := forall a b. (a -> b) -> Unit -> Unit, 
            'S := forall a b. (a -> b) -> a -> b} -> 
        forall a b. (a -> b) -> 
        Sigma {'Z := Unit , 'S := a} ->
        Sigma {'Z := Unit , 'S := b}
\end{rosi}

The point we arrive at is that the precision of some \RO and \Rome types are supplanted quite effectively by type equivalence. Further, as values are passed to type-operators, the shapes of the types incur forms of reduction beyond simple $\beta$-reduction. In this case, we must map type operators over rows; we next consider the reduction of row complements.


\subsubsection{Desugaring Booleans} Consider a desugaring of Booleans to Church encodings:

\begin{rosi}
type BoolF = { 'T := const Unit , 
               'F := const Unit , 
               'If := \x. Triple x x x}
type LamF  = { 'Lam := Id , 
               'App := \x. Pair x x , 
               'Var := const Nat }
desugar : forall y. BoolF < y, LamF < y - BoolF =>
          Pi (Functor (y - BoolF)) -> 
          Mu (Sigma y) -> 
          Mu (Sigma (y - BoolF))
\end{rosi}

We will ignore the already stated complications that arise from subexpressions such as !Functor! !(y - BoolF)! and skip to the step in which we tell !desugar! what particular row !y! it operates over. Here we know it must have at least the !BoolF! and !LamF! constructors. Let us try something like the following AST, using !++! as pseudonotation for row concatenation to save space.

\begin{rosi}
type AST = BoolF ++ LamF ++ 
          {'Lit := const Int , 'Add := \x. Pair x x }
desugar AST : BoolF < AST, LamF < (AST - BoolF) =>
              Pi (Functor (AST - BoolF)) -> 
              Mu (Sigma y) -> Mu (Sigma (AST - BoolF))
\end{rosi}

\Ni When !desugar! is passed !AST! for !z!, the inherent computation in the complement operator is made more obvious. What should !AST - BoolF! reduce to? Intuitively, we suspect the following to hold: 

\begin{rosi} 
AST - BoolF = {'Lit := const Int , 
               'Add := \x. Pair x x, 
               'Lam := Id , 
               'App := \x. Pair x x , 
               'Var := const Nat }
\end{rosi}

\Ni But this computation must be realized, just as (analogously) $\lambda$-redexes are realized by $\beta$-reduction.

\section{Type Equivalence \& Reduction}

We define reduction on types $\tau \RedT \tau'$ by directing the type equivalence judgment $\TEqvJ \Delta \tau {\tau'} \kappa$ from left to right, defined in \cref{fig:equivalence}. We omit conversion and closure rules. The semantics of each rule will be discussed further  in \cref{sec:helping-evaluation} when we describe each rule's computational role during normalization.

\newcommand\Subtract{\mathsf{subtract}}
\InlineOff{}
\begin{figure*}
\begin{small}
\begin{gather*}
\fbox{$\TEqvJ \Delta \tau \tau \kappa$}
\\
\ib{\irule[\erule{$\beta$}]
          {\KindJ \Delta {(\lambda \alpha\co\kappa. \tau) \, \upsilon} {\kappa'}};
          {\TEqvJ \Delta {(\lambda \alpha\co\kappa. \tau)\,\upsilon} {\tau[\upsilon/\alpha]} {\kappa'}}}
\isp
\begin{gathered}
\ib{\irule[\errule{lift$_\Xi$}]
          {\KindJ \Delta \rho {\RowK {\kappa_1 \to \kappa_2}}}
          {\KindJ \Delta \tau \kappa};
          {\TEqvJ \Delta {(\KFam \Xi {\kappa_1 \to \kappa_2} \rho) \, \tau} {\KFam \Xi {\kappa_2} (\rho \, \Flap \, \tau)} {\kappa_2}}!
          {\Xi \in \Set {\Pi, \Sigma}}}
\\
\text {where $\rho \, \Flap \, \tau = \Mapp {(\lambda f. f \, \tau)} \rho$}
\end{gathered}
\\
\ib{\irule[\erule{$\setminus$}]
          {\KindJ \Delta {\RowIx i 0 n {\LabTy {\xi_i} {\tau_i}}} {\RowK \kappa}}
          {\KindJ \Delta {\RowIx j 0 m {\LabTy {\xi_j} {\tau_j}}} {\RowK \kappa}};
          % {\Delta \vdash \mathsf{subtract} \, \rho_1 \, \rho_2 \, \rho_3};
          {\TEqvJ \Delta {{\Row {\LabTy {\xi_i} {\tau_i}}} \Compl {\Row {\LabTy {\xi_j} {\tau_j}}}} {\Subtract \, {\Row {\LabTy {\xi_i} {\tau_i}}} \, {\Row{\LabTy {\xi_j} {\tau_j}}}} {\RowK \kappa}}}
\rsp
\ib{\irule[\errule{map}]
          {\KindJ \Delta \phi {\kappa_1 \to \kappa_2}}
          {\KindJ \Delta {\RowIx i 0 n {\LabTy {\xi_i} {\tau_i}}} {\RowK{\kappa_1}}};
          {\TEqvJ \Delta {\Mapp {\phi} {\RowIx i 0 n {\LabTy {\xi_i} {\tau_i}}}} {\RowIx i 0 n {\LabTy {\xi_i} {\phi\,\tau_i}}} {\RowK{\kappa_2}}}}
\\
\ib{\irule[\errule{map$_\mathsf{id}$}]
          {\KindJ \Delta \rho {\RowK\kappa}};
          {\TEqvJ \Delta \rho {\Mapp {(\lambda \alpha. \alpha)} \rho} {\RowK\kappa}}}
\isp
\begin{gathered}
\ib{\irule[\errule{map$_\circ$}]
          {\KindJ \Delta {\phi_1} {\kappa_2 \to \kappa_3}}
          {\KindJ \Delta {\phi_2} {\kappa_1 \to \kappa_2}}
          {\KindJ \Delta \rho {\RowK {\kappa_1}}};
          {\TEqvJ \Delta {\Mapp {\phi_1} {(\Mapp {\phi_2} \rho)}} {\Mapp {(\phi_1 \circ \phi_2)} \rho} {\kappa_3}}}
\\
\text{where $\phi_1 \circ \phi_2 = \lambda \alpha. \phi_1 \, (\phi_2 \, \alpha)$}
\end{gathered}
\\
\ib{\irule[\errule{map$_{\setminus}$}]
          {\KindJ \Delta {\phi} {\kappa_1 \to \kappa_2}}
          {\KindJ \Delta {\rho_i} {\RowK {\kappa_1}}};
          {\TEqvJ \Delta {\Mapp {\phi} {(\rho_2 \setminus \rho_1)}} {\Mapp \phi {\rho_2} \setminus {\Mapp \phi {\rho_1}}} {\kappa_2} }}
\isp
\ib{\irule[\errule{$\Xi$}]
          {\KindJ \Delta \rho {\RowK {\RowK {\kappa}}}};
          {\TEqvJ \Delta {\KFam \Xi {\RowK \kappa} \, \rho} {\Mapp {{\KFam \Xi \kappa}} \rho} {\RowK {\kappa}}}!
          {\Xi \in \{ \Pi , \Sigma \}}}
\isp
\ib{\irule[\errule{$\eta$}]
          {\KindJ \Delta \phi {\kappa_1 \to \kappa_2}};
          {\TEqvJ \Delta {\phi} {\lambda \alpha \co \kappa_1. \phi \, \alpha} {\kappa_1 \to \kappa_2}}
}
\\[5pt]
\fbox{$\Subtract \, \rho \, \rho$}
\\
\begin{small}
\begin{aligned}
  \Subtract \, \EmptyRow \, \rho &= \EmptyRow \\
  \Subtract \, \Row {\LabTy \ell \tau, \rho} \, \rho' &= 
    &\begin{cases}
      \Subtract \, \rho \, \rho' &\text{if $\ell \in \rho'$} \\
      \Row {\LabTy \ell \tau, \Subtract \, \rho \, \rho'} &\text{otherwise}
    \end{cases}
\end{aligned}
\end{small}
\end{gather*}
\end{small}
\caption{Type equivalence}
\label{fig:equivalence}
\end{figure*}



\subsection{Normal forms}

The syntax of normal types is given in \cref{fig:type-normalization}. % We carefully define the normal type syntax so that no type $\Normal \tau \in \NormalTypes$ could reasonably reduce further to some other $\tau' \in \NormalTypes$. Hence we write $\tau \NRedT$ synonymously with $\tau \in \NormalTypes$ to indicate that $\tau$ is well-kinded and has no further reductions.

\begin{figure}[H]
\begin{gather*}
\begin{array}{r@{\hspace{7px}}l@{\qquad\qquad}r@{\hspace{7px}}l}
  \text{Type variables} & \alpha \in \mathcal A &
  \text{Labels} & \ell \in \mathcal L
\end{array} \\
\begin{doublesyntaxarray}
  \mcl{\text{Ground Kinds}}  & \gamma   & ::= & \TypeK \mid \LabK \\
  \mcl{\text{Kinds}}         & \kappa    & ::= & \gamma \mid \kappa \to \kappa \mid  \RowK \kappa \\
  \mcl{\text{Row Literals}}   & \NormalRows \ni \Normal \rho    & ::= & \RowIx i 0 m {\LabTy {\ell_i} {\Normal {\tau_i}}} \\
  \mcl{\text{Neutral Types}} & n    & ::= & \alpha \mid n \, {\Normal \tau}  \\
  \mcl{\text{Normal Types}}  & \NormalTypes \ni \Normal \tau, \Normal \phi & ::= & n \mid \Mapp {\hat{\phi}} {n} \mid \Normal{\rho} \mid \Normal{\pi} \then \Normal{\tau} \\
                             &       &     & \mid &  \forall \alpha\co\kappa. \Normal{\tau} \mid \lambda \alpha\co\kappa. \Normal{\tau}  \\ 
                             &       &     & \mid & \LabTy n {\Normal \tau} \mid \ell \mid \Sing {\Normal \tau} \mid {\Normal \tau} \Compl {\Normal \tau} \\
                             &       &     & \mid & {\KFam \Pi \TypeK} {\Normal \tau} \mid {\KFam \Sigma \TypeK} {\Normal \tau}                         
\end{doublesyntaxarray}
\end{gather*}
\begin{small}
\begin{gather*}
\fbox{$\KindJNF \Delta {\Normal \tau} {\kappa}$} \, \fbox{$\KindJNE \Delta {n} {\kappa}$} \\
\ib{
  \irule[\kruleNF{ne}]
    {\KindJNE \Delta n \gamma};
    {\KindJNF \Delta n \gamma}}
\isp
\ib{
  \irule[\kruleNF{$\Compl$}]
    {\KindJNF \Delta {\Normal {\tau_i}} {\RowK \kappa}}
    {\Normal{\tau_1} \notin \NormalRows \, \text{or}\, \Normal{\tau_2} \notin \NormalRows};
    {\KindJNF \Delta {\Normal{\tau_2} \Compl \Normal{\tau_1}} {\RowK \kappa}}}
\\
\ib{
  \irule[\kruleNF{$\triangleright$}]
    {\KindJNE \Delta {n} {\LabK}}{\KindJNF \Delta {\Normal \tau} \kappa};
    {\KindJNF \Delta {\LabTy n {\Normal \tau}}{\RowK \kappa}}}
\end{gather*}
\end{small}
\caption{Normal type forms}
\label{fig:type-normalization}
\end{figure}

Normalization reduces applications and maps except when a variable blocks computation, which we represent as a \emph{neutral type}. A neutral type is either a variable or a spine of applications with a variable in head position. We distinguish ground kinds $\gamma$ from functional and row kinds, as neutral types may only be promoted to normal type at ground kind (rule \kruleNF{ne}): neutral types $n$ at functional kind must $\eta$-expand to have an outer-most $\lambda$-binding (e.g., to $\lambda x. \, n\, x$), and neutral types at row kind are expanded to an inert map by the identity function (e.g., to $\Mapp {(\lambda x. x)} {n}$). Likewise, repeated maps are necessarily composed according to rule \errule{map$_\circ$}: For example, $\Mapp {\phi_{1}} {(\Mapp {\phi_{2}} {n})}$ normalizes by letting $\phi_{1}$ and $\phi_{2}$ compose into $(\Mapp {(\phi_{1} \circ \phi_{2})} n$). By consequence of $\eta$-expansion, records and variants need only be formed at kind $\TypeK$. This means a type such as $\Pi (\LabTy {\ell} {\lambda x. x})$ must reduce to $\lambda x. \Pi (\LabTy {\ell} {x})$, $\eta$-expanding its binder over the $\Pi$. Nested applications of $\Pi$ and $\Sigma$ are also "pushed in" by rule \erule{$\Xi$}. For example, the type $\Pi \, \Sigma \, (\LabTy {\ell_1} {(\LabTy  {\ell_2} \tau)})$ has $\Sigma$ mapped over the outer row, reducing to $\Pi (\LabTy {\ell_1} {\Sigma (\LabTy {\ell_2} \tau)})$.

The syntax $\LabTy n \Normal \tau$ separates singleton rows with variable labels from row literals $\Normal \rho$ with literal labels; rule \kruleNF{$\triangleright$} ensures that $n$ is a well-kinded neutral label.  A row is otherwise an inert map $\Mapp \phi n$ or the complement of two rows $\Normal{\tau_2} \Compl \Normal{\tau_1}$. Observe that the complement of two row literals should compute according to rule \erule{$\Compl$}; we thus require in the kinding of normal row complements \kruleNF{$\Compl$} that one (or both) rows are not literal so that the computation is indeed inert. The remaining normal type syntax does not differ meaningfully from the type syntax; the remaining kinding rules for the judgments $\KindJNF \Delta {\Normal \tau} \kappa$ and $\KindJNE \Delta n \kappa$ are as expected.
% \subsection{Metatheory}
% \label{sec:metatheory-summary}

% \subsubsection{Canonicity of normal types}

% The normal type syntax is pleasantly partitioned by kind. Due to $\eta$-expansion of functional variables, arrow kinded types are canonically $\lambda$-bound. A normal type at kind $\RowK \kappa$ is either an inert map $\hat{\phi}^{\TypeK} \, n$, a variable-labeled row $(\LabTy n \Normal \tau)$, the complement of two rows $\Normal {\tau_{2}} \Compl \Normal {\tau_{1}}$, or a row literal $\Normal \rho$. The first three cases necessarily have neutral types (recall that at least one of the two rows in a complement is not a row literal). Hence rows in empty contexts are canonically literal. Likewise, the only types with label kind in empty contexts are label literals; recall that we disallowed the formation of $\Pi$ and $\Sigma$ at kind $\RowK \LabK \to \LabK$, thereby disallowing non-literal labels such as $\Delta \not\vdash \Pi \epsilon \co \LabK$ or $\Delta \not\vdash \Pi (\LabTy {\ell_{1}} {\ell_{2}}) \co \LabK$.

% \begin{theorem}[Canonicity]
%   Let $\Normal\tau \in \NormalTypes$.
%   \begin{itemize}
%     \item If $\KindJNF \Delta {\Normal\tau} {(\kappa_{1} \to \kappa_{2})}$ then $\Normal\tau = {\lambda \alpha \co \kappa_{1}. \Normal\upsilon}$;
%     \item if $\KindJNF \epsilon {\Normal\tau} {\RowK \kappa}$ then $\Normal\tau =  \RowIx i 0 m {\LabTy {\ell_i} {\Normal{\tau_i}}}$.
%     \item If $\KindJNF \epsilon {\Normal\tau} \LabK$, then $\Normal\tau = \ell$.
%   \end{itemize}
% \end{theorem}
% \subsubsection{Normalization}
% \begin{theorem}[Normalization] ~
%   There exists a normalization function $\Norm\, : \Types \to \NormalTypes$ that maps well-kinded types to well-kinded normal forms.
% \end{theorem}

% $\Norm$ is realized in Agda intrinsically as a function from derivations of $\KindJ \Delta \tau \kappa$ to derivations of $\KindJNF \Delta {\Normal{\tau}} \kappa$.  Conversely, we witness the inclusion $\NormalTypes \subseteq \Types$ as an embedding $\Embed \,:\, \NormalTypes \to \Types$, which casts derivations of $\KindJNF \Delta {\Normal \tau} \kappa$  back to a derivation of $\KindJ \Delta \tau \kappa$; we omit this function and its use in the following claims, as it is effectively the identity function (modulo tags).

% The following properties confirm that $\Norm$ behaves as a normalization function ought to. The first property, \emph{stability}, asserts that normal forms cannot be further normalized. Stability implies \emph{idempotency} and \emph{surjectivity}.

% \begin{theorem}[Properties of normalization] ~
%   \begin{itemize}
%   \item (Stability) for all $\Normal\tau \in \NormalTypes$, $\Norm \, \Normal\tau = \Normal\tau$.
%   \item (Idempotency) For all $\tau \in \Types$, $ \Norm (\Norm \, \tau) =\, \Norm \, \tau$.
%   \item (Surjectivity) For all $\Normal\tau \in \NormalTypes$, there exists $\upsilon \in \Types$ such that $\Normal\tau =\, \Norm \upsilon$.
%   \end{itemize}
% \end{theorem}

% We now show that $\Norm$ indeed reduces faithfully according to the equivalence relation $\TEqvJ \Delta \tau \tau \kappa$. Completeness of normalization states that equivalent types normalize to the same form.

% \begin{theorem}[Completeness]
% For well-kinded $\tau , \upsilon \in \Types$ at kind $\kappa$, If $\TEqvJ \Delta \tau \upsilon \kappa$ then $\Norm\, \tau = \, \Norm \, \upsilon$.
% \end{theorem}

% \Ni Soundness of normalization states that every type is equivalent to its normalization.

% \begin{theorem}[Soundness]
% For well-kinded $\tau \in \Types$ at kind $\kappa$, there exists a derivation that $\TEqvJ \Delta \tau {\,\Norm \tau} {\kappa}$. Equivalently, if $\Norm\, \tau =\, \Norm\, \upsilon$, then $\TEqvJ \Delta \tau \upsilon {\kappa}$.
% \end{theorem}
% \Ni Soundness and completeness together imply, as desired, that $\tau \RedT \tau'$ iff $\Norm\, \tau =\, \Norm \tau'$.

% \subsubsection{Decidability of type conversion}

% Equivalence of normal types is syntactically decidable which, in conjunction with soundness and completeness, is sufficient to show that \Rome's equivalence relation is decidable.

% \begin{theorem}[Decidability]
%   Given well-kinded $\tau, \upsilon \in \Types$ at kind $\kappa$, the judgment $\TEqvJ \Delta \tau \upsilon \kappa$ either (i) has a derivation or (ii) has no derivation.
% \end{theorem}

\section{Normalization by Evaluation (NbE)}
This section describes our methodology, which is largely inspired by the \emph{normalization by evaluation} algorithm and metatheory of \citet{ChapmanKNW19}, although we have made significant extensions to their approach in order to capture the computation of rows. Our work also differs in some design choices (see \cref{sec:related-work}). Our particular style of intrinsic mechanization was popularized largely by \citet{plfa22} and can be further traced back to \citet{AltenkirchB99}. Our full development is available as part of the anonymous supplementary materials. The code we present here is summarized and tidied for display in print and easier digestion, but otherwise remains faithful to the development in behavior and intent. 

\InlineOn{}
Normalization by evaluation comes in a handful of different flavors (\cf{} \citet{Lindley05, Abel13}). In our intrinsic case, we seek to build a normalization function $\Norm : \TJudges{\Delta}{\kappa} \to \TJudgesNF{\Delta}{\kappa}$ by interpreting derivations in $\TJudges{\Delta}{\kappa}$ (the set of derivations of the judgment $\KindJ \Delta \tau \kappa$) into a semantic domain capable of performing reductions semantically. We then \emph{reify} objects in the semantic domain back to judgments in $\TJudgesNF{\Delta}{\kappa}$ (the set of derivations of the judgment $\KindJNF \Delta \tau \kappa$). The mapping of syntax to a semantic domain is typically written as $\Sem{\cdot}$ and called the \emph{residualizing semantics}. As a simple example, a judgment of the form $\KindJ \Delta \phi {\TypeK \to \TypeK}$ could be interpreted into a set-theoretic function, allowing applications to be interpreted into set-theoretic applications by that function. In our case, our residualizing semantics is not set-theoretic but in Agda. The syntax of the judgments $\KindJ \Delta \tau \kappa$, $\KindJNF \Delta \tau \kappa$, and $\KindJNE \Delta \tau \kappa$ are represented as Agda data types (where !Env! is a list of De Bruijn indexed type variables and !Kind! is the type of kinds). 

\begin{agda}
data Type : Env -> Kind -> Set
data NormalType : Env -> Kind -> Set
data NeutralType : Env -> Kind -> Set 
\end{agda}

\Ni We will interpret the !Type! and !NeutralType! types into Agda terms and functions in order to leverage Agda's meta-level computation, then reify these semantic objects back to normal type syntax.

\subsection{Residualizing semantic domain}

We define our semantic domain in Agda recursively over the syntax of !Kind!s in \cref{fig:SemType}.

\begin{figure}
\begin{agda}
SemType : Env -> Kind -> Set
SemType Delta * = NormalType Delta *
SemType Delta L = NormalType Delta L 
SemType Delta_1 (kappa_1 '-> kappa_2) = KripkeFunction Delta_1  kappa_1  kappa_2 
SemType Delta R[ kappa ] = 
  RowType Delta (\ Delta' -> SemType Delta' kappa) R[ kappa ]
\end{agda}
\caption{Semantic types}
\label{fig:SemType}
\end{figure}

Types at ground kind !*! and !L! are simply interpreted as !NormalType!s. We interpret arrow-kinded types as \emph{Kripke function spaces}, which permit the application of interpreted function $\phi$ at any environment !Delta_2! provided a renaming from !Delta_1! into !Delta_2!. % Note that we are defining !SemType! recursively (not inductively), and so the negative occurrence of !SemType! !Delta_2! !kappa_1! is not a problem.  

\begin{agda}
Renaming Delta_1  Delta_2 = TVar Delta_1 kappa -> TVar Delta_2 kappa
KripkeFunction : Env -> Kind -> Kind -> Set
KripkeFunction Delta_1  kappa_1  kappa_2 =  forall {Delta_2} -> 
  Renaming Delta_1  Delta_2 -> SemType Delta_2  kappa_1 -> SemType Delta_2  kappa_2
\end{agda}

The first three equations of \cref{fig:SemType} can be attributed to \citet{ChapmanKNW19}, with the mild deviation that we do not permit type-functions to appear as neutral types. (This is unnecessary in a system, such as ours, with $\eta$-expansion.) Novel to our development is the interpretation of row-kinded types (lines 5-6). First, we define the interpretation of row literals as finitely indexed maps to label-type pairs. (Here the type !Label! is a synonym for !String!, but could be any type with decidable equality and a strict total-order.) We define smart constructors for the empty row !emptyRow! and cons cases. 

\begin{agda} 
Row : Set -> Set
Row A = exists[ n ](Fin n -> Label times A)

emptyRow : Row A
emptyRow = 0 , \ ()
_;;_ : A -> Row A -> Row A 
a ;; (n , P) = suc n , \ { fzero -> a
                         ; fsuc i -> P i }
\end{agda}

\Ni Next, we define a !RowType! inductively as one of four cases in \cref{fig:semantic-rows}. A semantic row is either: a row literal constructed by !row!, a neutral-labeled row singleton constructed by !_:=_!, an inert map constructed by !_.map._!, or an inert row complement constructed by !_COMPL_!.
\begin{figure}
\begin{agda}
data RowType (Delta : Env) 
             (T : Env -> Set) : Kind -> Set where 
  row      : (rho : Row (T Delta)) -> 
              OrderedRow rho -> 
              RowType Delta T R[ kappa ]
  _:=_     : NeutralType Delta L -> 
             T Delta -> 
             RowType Delta T R[ kappa ]
  _.map._  : (forall {Delta'} -> 
                Renaming Delta Delta' -> 
                NeutralType Delta' kappa_1 -> 
                T Delta') -> 
             NeutralType Delta R[ kappa_1 ] -> 
             RowType Delta T R[ kappa_2 ]
  _COMPL_  : (rho_2  rho_1 : RowType Delta T R[ kappa ]) -> 
             {nor : NotRow rho_2  or  notRow rho_1} -> 
             RowType Delta T R[ kappa ]
\end{agda}
\caption{Semantic row type}
\label{fig:semantic-rows}
\end{figure}

Care must be taken to explain some nuances of each constructor. First, the !row! and !_COMPL_! constructors are each constrained by predicates. The !OrderedRow rho! predicate asserts that !rho! has its string labels totally and ascendingly ordered---guaranteeing that labels in the row are unique and that rows are definitionally equal modulo ordering. The !NotRow rho! predicate asserts simply that !rho! was \emph{not} constructed by !row!. In other words, it is not a row literal. This is important, as the complement of two row literals should reduce to a !Row!, so we must disallow the formation of complements in which at least one of the operands is a literal. 

The next set of nuances come from dancing around Agda's positivity and termination checking. It would have been preferable for us to have written the !row! and !_.map._! constructors as follows: 
\begin{agda}
  row      : (rho : Row (SemType Delta kappa)) -> 
             OrderedRow rho -> 
             RowType Delta T R[ kappa ]
  _.map._  : (forall {Delta'} -> 
                Renaming Delta Delta' -> 
                SemType Delta' kappa_1 -> 
                SemType Delta' kappa_2) -> 
             NeutralType Delta R[ kappa_1 ] -> 
             RowType Delta T R[ kappa_2 ]
\end{agda}

\Ni Such a definition would have necessarily made the types !RowType! and !SemType! mutually inductive-recursive. But this would run afoul of Agda's termination and positivity checkers for the following reasons:
\begin{enumerate}
  \item in the constructor !row!, the input !Row! !(SemType! !Delta! !kappa)! makes a recursive call to !SemType Delta kappa!, where it's not clear (to Agda) that this is a strictly smaller recursive call. To get around this, we parameterize the !RowType! type by !T : Env -> Set! so that we may enforce this recursive call to be structurally smaller---hence the definition of !SemType! at kind !R[ kappa ]! passes the argument !(\ Delta' ->! !SemType Delta' kappa)!, which varies in environment but is at a strictly smaller kind.
  \item  The !_.map._! constructor takes a !KripkeFunction! as input, in which !SemType! !Delta' kappa_1! occurs negatively, which Agda must outright reject. Here we borrow some clever machinery from \citet{AllaisBM13} and instead make the !KripkeFunction! accept the input !NeutralType Delta' kappa_1!, which is already defined. The trick is that, as we will show in the next section, every !NeutralType! may be promoted to a !SemType!. In practice this is sufficient for our needs.
\end{enumerate}

\subsection{Reflection \& reification}

We have now declared three domains: the syntax of types, the syntax of normal and neutral types, and the embedded domain of semantic types. Normalization by evaluation involves producing a \emph{reflection} from neutral types to semantic types, a \emph{reification} from semantic types to normal types, and an \emph{evaluation} from types to semantic types. It follows thereafter that normalization is the reification of evaluation. Because we reason about types modulo $\eta$-expansion, reflection and reification are necessarily mutually recursive. (This is not the case however with e.g. \citet{ChapmanKNW19}.)

Reflection is defined in \cref{fig:reflection}. Types at kind !*! and !L! can be promoted straightforwardly with the !ne! constructor (lines 4-5). Neutral types at arrow kind must be expanded into Kripke functions (lines 6-7). Note that the input \verb!v! has type \verb!SemType Î” Îºâ‚! and must be reified; additionally, !tau! is kinded in environment !Delta_1! and so must be renamed to !Delta_2!, the environment of !v!. The syntax $\cdot$ is used to construct an application of a !neutralType! to a !normalType!. Finally, a neutral row (e.g., a row variable) must be expanded into an inert mapping by !(\ r n -> reflect n)!, which is effectively the identity function (line 8). 
\begin{figure}
\begin{agda}
reflect : NeutralType Delta kappa -> SemType Delta kappa 
reify : SemType Delta kappa -> NormalType Delta kappa

reflect {kappa = *} tau = ne tau
reflect {kappa = L} tau = ne tau
reflect {kappa = kappa_1 '-> kappa_2} = 
  \ r v -> reflect ((rename r tau) cdot reify v)
reflect {kappa = R[ kappa ]} rho = (\ r n -> reflect n) .map. rho
\end{agda}
\caption{Reflection}
\label{fig:reflection}
\end{figure}

The definition of reification is a little more involved (\cref{fig:reification}). The first two equations are expected (!tau! is already in normal form). Functions are reified effectively by $\eta$\--expan\-sion; note that we are using intrinsically-scoped De Bruijn variables, so !Z! constructs the zero'th variable and !S! induces a renaming in which each variable is incremented by one. (Recall that !phi! is a Kripke function space and so expects a renaming as argument.) The constructor !`! promotes a type variable to a !neutralType!, which is reflected so that it may be passed to !phi S!. The remaining equations (lines 5-10) describe the reification of the four row cases. When the input is a neutral-labeled row singleton, we need only create a !NeutralType!-labeled singleton with the body !tau! reified. The case of an inert complement !rho_2 - rho_1! remains an inert complement at type !NormalType!. Finally, we reify the inert map !phi .map. tau! by reifying !phi! analogously to the !kappa_1 `-> kappa_2! case and mapping it over the reification of !tau!.

The equation of interest is in reifying row literals. We pun the !row! constructor to construct row literals at type !NormalType!, which likewise expects a proof that the row is well-ordered. Such a proof is given by the auxiliary lemma !reify!\-!Preserves!\-!Ordering!. We use a helper function !reify!\-!Row! to recursively build a list of !Label!\--!Normal!\-!Type! pairs (that is, the form of !NormalType! row literals) from a semantic row. The empty case is trivial; the successor case must inspect the head of the list by destructing !P! !fzero!, i.e., the label\--type association of the zero'th finite index. From there we yield a semantic type !tau! which we reify and append to the result of recursing.
\begin{figure}
\begin{agda}
reify {kappa = *} tau = tau
reify {kappa = L} tau = tau
reify {kappa = kappa_1 '-> kappa_2} phi = 
  `\ (reify (phi S (reflect (` Z))))
reify {kappa = R[ kappa ]} (l := tau) = l := (reify tau)
reify {kappa = R[ kappa ]} (rho_2 - rho_1) = reify rho_2 - reify rho_1
reify {kappa = R[ kappa ]} (phi .map. tau) = 
  `\ (reify (phi S (` Z))) .map. (reify tau)
reify {kappa = R[ kappa ]} (row rho q) = 
  row (reifyRow rho) (reifyPreservesOrdering q)
  where
    reifyRow : Row (SemType Delta kappa) -> 
               List (Label times NormalType Delta kappa)
    reifyRow (0 , P) = [] 
    reifyRow (suc n , P) with P fzero 
    ... | (l , tau) = 
      (l , reify tau) :: reifyRow (n , P . fsuc)
\end{agda}
\caption{Reification}
\label{fig:reification}
\end{figure}

Finally, we have asserted that types are reduced modulo $\beta$-reduction and $\eta$-expansion. It follows that a given !NeutralType! should, after reflection and reification, end up in an expanded form. This is precisely how we define the promotion of !NeutralType!s to !NormalType!s: 

\begin{agda}
eta-norm : NeutralType Delta kappa -> NormalType Delta kappa
eta-norm = reify . reflect
\end{agda}

This function is necessary: the !NormalType! constructor !ne! stipulates that we may only promote neutral derivations to normal derivations at \emph{ground kind} (rule \kruleNF{ne}). Hence !eta!!-norm! is the only means by which we may promote neutral types at row or arrow kind.

\subsection{Helping evaluation}
\label{sec:helping-evaluation}
Our next task is to \emph{evaluate} terms of type !Type Delta kappa! into the semantic domain at type !SemType Delta kappa!. We will build our evaluation function incrementally; we find it clearer to introduce helpers for sub-computation (e.g., mapping or the complement) on our way up to full evaluation. We describe these helpers next.

\subsubsection{Semantic application.}

We define semantic application straightforwardly as Agda application under the identity renaming.

\begin{agda}
_cdot'_ : SemType Delta (kappa_1 '-> kappa_2) -> 
          SemType Delta kappa_1 -> 
          SemType Delta kappa_2
phi cdot' v = phi id v
\end{agda}
% \caption{semantic application}
% \label{fig:semantic-application}
% \end{figure}

\subsubsection{Semantic mapping}
Mapping over rows is a form of computation novel to \Rome's equivalence relation. We define the mapping !phi .map. rho! over the four cases a semantic row may take (\cref{fig:semantic-mapping}). When !rho! is neutral-labeled, we simply apply !phi! to its contents (line 4). The case where !rho! is a row literal is interesting in that our choice of representation for row literals as Agda functions comes to pay off: we may express the mapping of !phi! across the row !(n , P)! by pre-composing !P! with !phi! (line 5; note that we must appropriately fmap !phi! over the pair's second component). The mapping of !phi! over a complement is distributive, following rule \errule{map$_{\setminus}$} (line 6). Likewise, we follow rule \errule{map$_\circ$} in grouping the nested map !phi! !.map.! !(phi_2 .map. n)! into a composed map (line 7).

\begin{figure}
\begin{agda}
_.map.'_ : SemType Delta (kappa_1 '-> kappa_2) -> 
           SemType Delta R[ kappa_1 ] -> 
           SemType Delta R[ kappa_2 ]
phi .map.' (l := tau) = l := (phi cdot' tau)
phi .map.' (row (n , P) q) = row (n , fmap (phi id) . P)
phi .map.' (rho_2 - rho_1) = (phi .map. rho_2) - (phi .map. rho_1)
phi_1 .map.' (phi_2 .map. n) = (\ r -> phi_1 r . phi_2 r) .map. n
\end{agda}
\caption{Semantic mapping}
\label{fig:semantic-mapping}
\end{figure}

\subsubsection{Semantic complement} The complement of two row-kinded semantic types is always inert when one (or both) are not row literals, and thus constructed simply by the !_COMPL_! constructor. The interesting case is when we must reduce two row literals to another row literal (\cref{fig:semantic-complement}). We proceed by induction on the length of the left-hand row: when the left-hand row is empty, the resulting row is the empty row !0 , \ ()! (line 5). (That is to say, an empty row minus any other row is empty.) Otherwise, we check if the label of the head entry in !P!, !P fzero .fst!, is in the right-hand row (line 6). If so, we omit it and proceed with recursion (line 7). If not, we retain it (line 8).

\begin{figure}
\begin{agda}
_In?_ : Label -> Row (SemType Delta kappa) -> Bool

_COMPL'_ : Row (SemType Delta kappa) -> Row (SemType Delta kappa) -> 
           Row (SemType Delta kappa)
(zero , P) COMPL' (m , Q) = emptyRow
(suc n , P) COMPL' (m , Q) with P fzero .fst In? Q 
... | true = (P . fsuc) COMPL' Q
... | false = P fzero ;; ((P . fsuc) COMPL' Q) 
\end{agda}
\caption{Semantic complement}
\label{fig:semantic-complement}
\end{figure}

\subsubsection{Semantic flap}
The rule \errule{lift$_\Xi$} describes how $\Pi$ and $\Sigma$ reassociate from e.g. !(Pi rho) a! to !Pi (rho ?? a)!. We define a semantic version of the flap (flipped map) operator as follows:

\begin{agda}
_??'_ : SemType Delta R[ kappa_1 '-> kappa_2 ] -> 
       SemType Delta kappa_1 -> SemType Delta R[ kappa_2 ]
phi ??' a = (\ r f -> f cdot' (rename r a)) .map.' phi
\end{agda}

\subsubsection{Semantic $\Pi$ and $\Sigma$} The defining equations for the reduction of $\Pi$ is given in \cref{fig:semantic-pi}. (The logic for $\Sigma$ is identical and omitted.)

\begin{figure}
\begin{agda}
Pi' : SemType Delta R[ kappa ] -> SemType Delta kappa
Pi' {kappa = *} rho = Pi (reify rho)
Pi' {kappa = kappa_1 -> kappa_1} phi = \ r v -> Pi' (rename r phi ??' v)
Pi' {kappa = R[ kappa ]} rho = (\ r v -> Pi' v) .map.' rho
\end{agda}
\caption{Semantic $\Pi$}
\label{fig:semantic-pi}
\end{figure}
 
The input row to !Pi'! has kind !R[ kappa ]!; we proceed by destructing !kappa!. Recall that we may only construct record types in normal form at kind !*!, and so for the case that !kappa = *! we simply reify the input and construct the record via the !NormalType! constructor !Pi! (line 2). We exclude the case that !kappa = L! because it is impossible: in the !Type! syntax, we restrict the formation of the !Pi! constructor by the following predicate:

\begin{agda}
NotLabel : Kind -> Set
NotLabel * = Top
NotLabel L = Bot
NotLabel (kappa_1 '-> kappa_2) = NotLabel kappa_2
NotLabel R[ kappa ] = NotLabel kappa
\end{agda}

This is to say, one may not apply !Pi! to an input that is a row of labels, a label-valued function, or a nested row of labels. Next, when applying !Pi'! to a function, we must expand the semantic $\lambda$-binding outwards (line 3). Thereafter, we apply rule \errule{lift$_\Xi$} to explain how !Pi'! operates on a single operand. Finally, we implement rule \errule{$\Xi$} directly in the last equation (line 4): the application of !Pi'! to a row-kinded input !x! is simply the mapping of !Pi'!  over !x!.

\subsection{Evaluation (residualizing semantics)}
Evaluation warrants an environment that maps type variables to semantic types. The identity environment, which fixes the meaning of variables, is given as the composition of reflection and !`!, the constructor of !NeutralType!s from !TVar!s. 


\begin{agda}
SemEnv : Env -> Env -> Set
SemEnv Delta_1  Delta_2 = TVar Delta_1 kappa -> SemType Delta_2 kappa 
idEnv : SemEnv Delta Delta
idEnv = reflect . `
\end{agda}

We describe only the interesting cases of evaluation (\cref{fig:evaluation}); the rest are purely compositional. 

\begin{figure}
\begin{agda}
eval : Type Delta_1 -> SemEnv Delta_1  Delta_2 -> SemType Delta_2  kappa
eval (` x) eta = eta x
eval (tau_1  cdot  tau_2) eta = (eval tau_1  eta) cdot' (eval tau_2  eta)
eval (rho_2 - rho_1) eta = eval rho_2 eta COMPL' eval rho_1  eta 
eval (`\ tau) eta = \ r v -> 
  eval tau (extend (rename r . eta) v)
eval Pi eta = \ r v -> Pi' v
eval Sigma eta = \ r v -> Sigma' v
eval (phi .map. tau) eta = eval phi eta .map.' eval n tau
eval (l := tau) eta with eval l eta 
... | ne n = (n := eval tau eta)
... | lab ell = row (1 , \ { 
        fzero -> (ell , eval tau eta )}) tt
eval (row rho q) eta = row 
  (evalRow rho eta) 
  (evalPreservesOrdering q)
where
  evalRow : List (Label times (Type Delta_1 kappa)) -> 
            SemEnv Delta_1  Delta_2 -> 
            Row (SemType Delta_2 kappa)
  evalRow [] eta = emptyRow
  evalRow ((ell , tau) :: rho) eta = 
    (ell , eval tau eta) ;; evalRow rho eta
\end{agda}
\caption{Evaluation}
\label{fig:evaluation}
\end{figure}

The first equation states that variables evaluate to their meaning in environment !eta! (line 2). The equations for application !_cdot_!, row complement !_COMPL_!, record and variant operators !Pi! and !Sigma!, and mapping !_.map._! (lines 3, 4, 6, 7, and 9, resp.) defer to the semantic helpers defined in \cref{sec:helping-evaluation}. The evaluation of a function \lstinline{`\ tau} is simply the evaluation of the body in the environment !eta! expanded with semantic object !v!, being careful to rename appropriately as this is a Kripke function. Evaluation of labeled singletons must check if the label is a neutral variable !n! or label literal !ell!; in the former case (line 11), we evaluate to an inert singleton using the !RowType! constructor !_:=_!; in the latter (line 12), we evaluate to a row literal in which !fzero! points to !(ell , eval tau eta)!. The term !tt : Unit! is the evidence that this row literal is trivially ordered. Finally, we evaluate row literals by recursion: the empty case evaluates to the empty !Row!, !0 , \ ()! (line 21); the cons case (lines 22-23) evaluates to a row in which !fzero! maps to the evaluation of !tau!, while !fsuc! otherwise proceeds recursively. Again, we have an obligation to prove that evaluation preserves the ordering evidence !q!, which is performed by the auxiliary lemma !evalPreservesOrdering!.



\subsection{Normalization}

\ifthms
\begin{theorem}[Normalization] ~
  There exists a normalization function $\Norm\, : \TJudges{\Delta}{\kappa} \to \TJudgesNF{\Delta}{\kappa}$, that maps well-kinded types to well-kinded normal forms.
\end{theorem}\fi

Normalization in the NbE approach is simply the composition of reification after evaluation. 

\begin{agda} 
Down : Type Delta kappa -> NormalType Delta kappa
Down tau = reify (eval tau idEnv)
\end{agda}

It will be necessary in the coming metatheory to define an inverse embedding by induction over the !NormalType! structure. The definitions are entirely expected and omitted. 

\begin{agda}
Up : NormalType Delta kappa -> Type Delta kappa
UpNE : NeutralType Delta kappa -> Type Delta kappa
\end{agda}

\section{Mechanized metatheory}

This section describes the Agda formalization of our metatheory, including proofs and proof outlines where space permits.

\subsection{Canonicity of normal types}
\ifthms
\begin{theorem}[Canonicity]
  Let $\Normal\tau \in \TJudgesNF{\Delta}{\kappa}$.
  \begin{itemize}
    \item If $\KindJNF \Delta {\Normal\tau} {(\kappa_{1} \to \kappa_{2})}$ then $\Normal\tau = {\lambda \alpha \co \kappa_{1}. \Normal\upsilon}$;
    \item if $\KindJNF \epsilon {\Normal\tau} {\RowK \kappa}$ then $\Normal\tau =  \RowIx i 0 m {\LabTy {\ell_i} {\Normal{\tau_i}}}$.
    \item If $\KindJNF \epsilon {\Normal\tau} \LabK$, then $\Normal\tau = \ell$.
  \end{itemize}
\end{theorem}
\fi

Normal forms are partitioned by kind, which can easily be shown by case splitting on !Normal!\-!Type! inputs. We first demonstrate that neutrals cannot exist in an empty environment:

\begin{agda} 
noNeutrals : NeutralType [] kappa -> Bot
noNeutrals (n cdot tau) = noNeutrals n
\end{agda} 

Now, in any context an arrow-kinded type is canonically $\lambda$-bound:
\begin{agda}
arrow-canonicity : (phi : NormalType Delta (kappa_1 '-> kappa_2)) -> 
                    exists[ tau ](phi .=. `\ tau)
arrow-canonicity (`\ tau) = tau , refl 
\end{agda}

\Ni A row in an empty context is necessarily a row literal (all omitted cases are eliminated by !Bot-elim!):

\begin{agda}
row-canonicity : (rho : NormalType [] R[ kappa ]) -> 
                 exists[ (xs , oxs) ]
                 ( rho .=. row xs oxs)
row-canonicity (row rho q) = rho , q , refl
\end{agda}

\Ni And a label-kinded type is necessarily a label literal:

\begin{agda}
label-canonicity : (l : NormalType [] L) -> 
                   exists[ ell ] (l .=. lab ell)
label-canonicity (ne x) = Bot-elim (noNeutrals x)
label-canonicity (lab s) = s , refl
\end{agda}

\subsection{Stability}

The following properties confirm that $\Norm$ behaves as a normalization function ought to. The first property, \emph{stability}, asserts that normal forms cannot be further normalized. Stability implies \emph{idempotency} and \emph{surjectivity}.

\ifthms
\begin{theorem}[Properties of normalization] ~
  \begin{itemize}
  \item (Stability) for all $\Normal\tau \in \TJudgesNF{\Delta}{\kappa}$, $\Norm \, \Normal\tau = \Normal\tau$.
  \item (Idempotency) For all $\tau \in \TJudges{\Delta}{\kappa}$, $ \Norm (\Norm \, \tau) =\, \Norm \, \tau$.
  \item (Surjectivity) For all $\Normal\tau \in \TJudgesNF{\Delta}{\kappa}$, there exists $\upsilon \in \Types$ such that $\Normal\tau =\, \Norm \upsilon$.
  \end{itemize}
\end{theorem}\fi

Stability follows by simple induction on the input derivation $\KindJNF \Delta \tau \kappa$. We are in essence just stating that normallization (!Down!) is left-inverse to embedding (!Up!).

\begin{agda}
stability : forall (tau : NormalType Delta kappa) -> Down (Up tau) .=. tau
\end{agda}
Stability implies idempotency:
\begin{agda}
idempotency : forall (tau : Type Delta kappa) -> 
              (Up . Down . Up . Down) tau .=. (Up . Down) tau
idempotency tau rewrite (stability (Down tau)) = refl
\end{agda}
\Ni and surjectivity: 

\begin{agda}
surjectivity : forall (tau : NormalType Delta kappa) -> 
               exists[ upsilon ] (Down upsilon .=. tau)
surjectivity tau = ( Up tau , stability tau )
\end{agda}

Dual to surjectivity, stability also implies that embedding is injective.

\begin{agda}
Up-inj : forall (tau_1  tau_2 : NormalType Delta kappa) -> 
         Up tau_1 .=. Up tau_2 -> tau_1 .=. tau_2
Up-inj  tau_1  tau_2  eq = 
  trans 
    (sym (stability tau_1))          
    (trans 
      (cong Down eq)
      (stability tau_2))
\end{agda}

\subsection{A logical relation for completeness}

We now show that $\Norm$ indeed reduces faithfully according to the equivalence relation $\TEqvJ \Delta \tau \upsilon \kappa$. Completeness of normalization states that equivalent types normalize to the same form.

\ifthms
\begin{theorem}[Completeness]
For well-kinded $\tau , \upsilon \in \TJudges{\Delta}{\kappa}$, If $\TEqvJ \Delta \tau \upsilon \kappa$ then $\Norm\, \tau = \, \Norm \, \upsilon$.
\end{theorem}
\fi

We define the equivalence relation of \cref{fig:equivalence} as an inductive, intrinsically-typed relation in Agda. We force that !_.=.t_! be an equivalence relation with the rules !eq-refl!, !eq-sym!, and !eq-trans!, which will appear again in later proofs. 

\begin{agda}
data _.=.t_ : Type Delta kappa -> Type Delta kappa -> set
\end{agda}

\Ni Completeness may be stated as follows:

\begin{agda}
completeness : forall tau_1 tau_2. tau_1 .=.t tau_2 -> Down tau_1 .=. Down tau_2
\end{agda}

We prove completeness via a logical relation !_~~_! on semantic types that specifies when two semantic objects are equivalent modulo uniformity (\citep{AllaisBM13,ChapmanKNW19}) and pointwise functional extensionality. We define !_~~_! recursively over the kinds of the inputs !tau_1! and !tau_2! (\cref{fig:completeness-relation}).

\begin{figure}
\begin{agda}
_~~_ {kappa = *} tau_1 tau_2 = tau_1 .=. tau_2
_~~_ {kappa = L} tau_1 tau_2 = tau_1 .=. tau_2
_~~_ {kappa = kappa_1 `-> kappa_2} phi_1  phi_2 = 
  Uniform phi_1 times Uniform phi_2 times PointEqual phi_1 phi_2
_~~_ {kappa = R[ kappa ]} (ell_1 := tau_1) (ell_2 := tau_2) = ell_1 .=. ell_2 times tau_1 ~~ tau_2  
_~~_ {kappa = R[ kappa_2 ]} (_.map._ {kappa_1} phi_1  n_1) (_.map._ {kappa_1'} phi_2  n_2) = 
  exists[ pf : kappa_1 .=. kappa_1' ]
    UniformNE phi_1 times
    UniformNE phi_2 times
    PointEqualNE (convKripkeNE pf phi_1) phi_2 times
    convNE pf n_1 .=. n_2
_~~_ {kappa = R[ kappa ]} (rho_2 - rho_1) (rho_4 - rho_3) = rho_2 ~~ rho_4 times rho_1 ~~ rho_3
_~~_ {kappa = R[ kappa ]} (row rho_1 q) (row rho_2 g) = rho_1 ~~R rho_2
  where
    (ell_1 , tau_1) ~~2 (ell_2 , tau_2) = ell_1 .=. ell_2 times tau_1 ~~ tau_2
    (n , P) ~~R (m , Q) = exists[ pf : n .=. m]
                          (forall (i : fin m) -> 
                          (subst-Row pf P) i ~~2 Q i)
\end{agda}
\caption{Completeness relation}
\label{fig:completeness-relation}
\end{figure}

\begin{figure}
\begin{agda}
Uniform : KripkeFunction Delta kappa_1  kappa_2 -> Set 
Uniform phi = forall (r_1 : Renaming Delta_1  Delta_2) 
              (r_2 : Renaming Delta_2  Delta_3) 
              (v_1 v_2 : SemType Delta_2  kappa_1) -> 
              v_1 ~~ v_2 -> 
              rename r_2 (phi r_1 v_1) ~~ 
              phi (r_2 . r_1) (rename r_2 v_2)
PointEqual : ( phi_1  phi_2 : KripkeFunction Delta kappa_1  kappa_2) -> Set
PointEqual phi_1  phi_2 = forall (r : Renaming Delta_1  Delta_2)
                         {v_1 v_2 : SemType Delta_2 kappa_1} -> 
                         v_1 ~~ v_2 -> 
                         phi_1 r v_1 ~~ phi_2 r v_2
\end{agda}
\caption{Uniformity and point equality}
\label{fig:uniformity-and-PE}
\end{figure}

The completeness logical relation is defined compositionally in the cases where !kappa = *!, !kappa = L!, or !kappa = R[ kappa ]! and the equated rows are neutral-labeled or inert complements (lines 1, 2, 5, and 12, resp.). In the case that !kappa = kappa_1 `-> kappa_2! (lines 3-4), we assert that the Kripke functions !phi_1! and !phi_2! are \emph{uniform} and \emph{extensionally equivalent} to one another (see \cref{fig:uniformity-and-PE}). Uniformity states that passing a renaming !r_2! to a Kripke function is equivalent to renaming it algorithmically---that is, the function !rename! commutes with Kripke renaming (lines 2-7, \cref{fig:uniformity-and-PE}). The uniformity property is attributable to \citet{AllaisBM13} but simplified drastically by \citet{ChapmanKNW19}. The !PointEqual! predicate (lines 8-12, \cref{fig:uniformity-and-PE}) circumvents any need to postulate functional extensionality; rather, we assert that !phi_1! and !phi_2! map equivalent inputs to equivalent outputs.

The predicates !UniformNE! and !PointEqualNE! are entirely analogous to !Uniform! and !PointEqual! except that they describe Kripke functions in which the domain is a !NeutralType! rather than !SemType!. In the case that we are equating two inert maps (lines 6-11, \cref{fig:completeness-relation}), we must additionally assert that the domains of !phi_1! and !phi_2! (that is, !kappa_1! and !kappa_1'!, resp.) are equivalent. The helpers !convKripkeNE! and !convNE! convert !phi_1! and !n_1! appropriately so as to be indexed by kind !kappa_1'!.

Finally, we equate row literals under the !~~R! relation (lines 16-18), which states that (i) the two rows' lengths are equal, and (ii) the two rows have pointwise related contents.  Note that we must use an auxiliary helper !subst-Row! to convert the length !n! indexing !P! to be !m!.

\subsubsection{Properties}

Propositionally equal neutral types reflect to equivalent semantic objects: 

\begin{agda}
reflect-~~ : forall {tau_1 tau_2 : NeutralType Delta kappa} -> 
             tau_1 .=. tau_2 -> reflect tau_1 ~~ reflect tau_2
\end{agda}

\Ni Dually, equivalent semantic objects reify to propositionally equal types. 

\begin{agda}
  reify-~~ : \forall {v_1 v_2 : SemType Delta kappa} -> 
              v_1 ~~ v_2 -> 
              reify v_1 .=. reify v_2
\end{agda}

\subsubsection{Logical environments} We lift the relation !_~~_! to a relation on semantic environments !eta_1! and !eta_2!  by asserting that the two are pointwise related.

\begin{agda}
_~~e_ : (eta_1  eta_2 : SemEnv Delta_1  Delta_2) -> Set
eta_1 ~~e eta_2 = forall (alpha : TVar Delta_1 kappa) -> (eta_1 alpha) ~~ (eta_2 alpha)
\end{agda}

\Ni  The identity semantic environment relates to itself under the reflection of propositional equality, as witnessed by !idEnv-~~!. 

\begin{agda}
idEnv-~~ : idEnv ~~e idEnv 
idEnv-~~ alpha = reflect-~~ refl 
\end{agda}

\subsubsection{The fundamental theorem and completeness}

The fundamental theorem for the completeness relation states that equivalent types evaluate to related semantic objects. The proof of the fundamental theorem is by induction over the type equivalence witness !tau_1 .=.t tau_2!.

\begin{agda}
  fundC : eta_1 ~~e eta_2 -> tau_1 .=.t tau_2 -> 
          eval tau_1 eta_1 ~~ eval tau_2 eta_2
\end{agda}

Completeness follows from the fundamental theorem in the identity semantic environment. 

\begin{agda}
completeness : forall tau_1 tau_2. tau_1 .=.t tau_2 -> Down tau_1 .=. Down tau_2
completeness tau_1 tau_2 eq = reify-~~ (fundC idEnv-~~ eq)
\end{agda}

\subsection{A logical relation for soundness}

Soundness of normalization states that every type is equivalent to its normalization.

\ifthms
\begin{theorem}[Soundness]
For well-kinded $\tau \in \TJudges{\Delta}{\kappa}$, there exists a derivation that $\TEqvJ \Delta \tau {\,\Norm \tau} {\kappa}$. Equivalently, if $\Norm\, \tau =\, \Norm\, \upsilon$, then $\TEqvJ \Delta \tau \upsilon {\kappa}$.
\end{theorem}\fi

In Agda, soundness states specifically that each type is equivalent to its embedded normalization:

\begin{agda}
soundness : forall (tau : Type Delta kappa) -> tau .=.t Up (Down tau)
\end{agda}

\Ni This is enough to imply the converse of completeness. We use an auxiliary transfer lemma, !embed-.=.t!, to state that if the type !tau_1! is equal to a normalization of !tau_2!, then the embedding of !tau_1! is equivalent to !tau_2!.

\begin{agda}
embed-.=.t : forall (tau_1 : NormalType Delta kappa) (tau_2 : Type Delta kappa) -> 
             tau_1 .=. (Down tau_2) -> Up tau_1 .=.t tau_2 
embed-.=.t refl = eq-sym (soundness tau_2)

conv-completeness : (tau_1 tau_2 : Type Delta kappa) -> 
                    Down tau_1 .=. Down tau_2 -> tau_1 .=.t tau_2
conv-completeness tau_1 tau_2 eq = 
  eq-trans (soundness tau_1) (embed-.=.t eq)                 
\end{agda}

\Ni Hence soundness and completeness together imply, as desired, that $\tau \RedT \tau'$ iff $\Norm\, \tau =\, \Norm \tau'$.

In \cref{fig:soundness-relation}, we define a logical relation for soundness by relating un-normalized types to semantic objects. The first two cases (lines 2-3) state that !tau! relates to !v! at ground kind when !tau! is equivalent to the embedding of !v!. On line 4, we relate arrow-kinded types; \Cref{fig:soundKripke} describes when syntactic type operators relate to Kripke functions. The definitions are largely the same for semantic and neutral Kripke functions except that, in the neutral case, we require instead that !tau .=.t Up (eta-norm n)! for neutral !n!. Each definition otherwise asserts that related inputs map to related outputs.

The cases that follow relate syntactic rows with semantic rows. On line 5 we relate row literals \emph{existentially}:\footnote{In practice, we actually know precisely that \lstinline{tau} should be equivalent to the embedding of the reification of \lstinline{row (n , P) q}, but asserting as such complicates presentation; either style works.} we assert that there exists a syntactic row literal !xs! !: List! !(Label! !times! !Type! !Delta! !kappa)! and a well-orderedness predicate !oxs! such that !tau! is equivalent to !row xs oxs! and, further, !xs! is pointwise equivalent to !(n , P)!. The pointwise relation ![[_]]R~~_! of syntactic and semantic row literals is defined in \cref{fig:soundness-relation-row-literals}, and is more or less to be expected: two row literals are related if they are of the same length and have related contents. 

On lines 10-13 we relate row singletons in a straightforward fashion; lines 14-17 relate row complements compositionally. Finally, we relate inert row maps by asserting the existence of a !phi! that is sound with respect to the neutral Kripke function !F! (\cref{fig:soundKripke}).

\begin{figure}
\begin{agdaf}
[[_]]~~_ : Type Delta kappa -> SemType Delta kappa -> Set
[[_]]~~_ {kappa = *} tau  v = tau .=.t Up v
[[_]]~~_ {kappa = L} tau  v = tau .=.t Up v
[[_]]~~_ {kappa = kappa_1 `-> kappa_2} phi F = SoundKripke phi F
[[_]]~~_ {kappa = R[ kappa ]} tau (row (n , P) q) =
  exists[ xs ] 
  exists[ oxs ]
  (tau .=.t row xs oxs) times
  [[ xs ]]R~~ (n , P)
[[_]]~~_ {kappa = R[ kappa ]} tau (n := v) = 
  exists[ upsilon ]
  (tau .=.t (UpNE n := upsilon)) times
  [[ upsilon ]]~~ v
[[_]]~~_ {kappa = R[ kappa ]} tau (rho_2 - rho_1) = 
  (tau .=.t Up (reify (rho_2 - rho_1))) times 
  [[ Up (reify rho_2) ]]~~ rho_2 times 
  [[ Up (reify rho_1) ]]~~ rho_1
[[_]]~~_ {kappa = R[ kappa ]} tau (F .map. n) = 
  exists[ phi ]
  (tau .=.t (phi .map. UpNE n)) times
  (SoundKripkeNE phi F)
\end{agdaf}
\caption{Soundness relation}
\label{fig:soundness-relation}
\end{figure}
\begin{figure}
\begin{agda}
[[ [] ]]R~~_ (zero , P) = Top
[[ [] ]]R~~_ (suc n , P) = Bot
[[ x :: rho ]]R~~_ (zero , P) = Bot
[[ x :: rho ]]R~~_ (suc n , P) = 
  [[ x ]]~~2 (P fzero) times 
  [[ rho ]]R~~ (n , P . fsuc)
  where
    [[ (ell_1 , tau) ]]~~2 (ell_2 , v) = 
      (ell_1 .=. ell_2) times [[ tau ]]~~ v 
\end{agda}
\caption{Soundness relation (row literals)}
\label{fig:soundness-relation-row-literals}
\end{figure}

\begin{figure}
\begin{agda}
SoundKripke : Type Delta_1 (kappa_1 `-> kappa_2) -> 
              KripkeFunction Delta_1  kappa_1  kappa_2 -> Set 
SoundKripke phi F = 
  (r : Renaming Delta_1  Delta_2) 
  {tau : Type Delta_2 kappa} {v : SemType Delta_2 kappa}
  [[ tau ]]~~ v -> 
  [[ rename r phi cdot tau ]]~~ F r v

SoundKripkeNE : Type Delta_1 (kappa_1 `-> kappa_2) -> 
                KripkeFunctionNE Delta_1  kappa_1  kappa_2 -> Set
SoundKripkeNE phi F = 
  (r : Renaming Delta_1  Delta_2) 
  {tau : Type Delta_2 kappa} {n : NeutralType Delta_2 kappa}
  tau .=.t Up (eta-norm n) -> 
  [[ rename r phi cdot n ]]~~ F r n
\end{agda}
\caption{Soundness of Kripke functions}
\label{fig:soundKripke}
\end{figure}
 
\subsubsection{Properties}

Analogous to the completeness relation, equivalence of neutral types can be reflected into the soundness relation.

\begin{agda}
reflect-[[]]~~ : forall {tau : Type Delta kappa} 
                 {n : NeutralType Delta kappa} -> 
                 tau .=.t UpNE n  -> [[ tau ]]~~ (reflect n)
\end{agda}

\Ni And the relation of !Type! !tau! to semantic type !v! can be reified to type equivalence: 

\begin{agda}
reify-[[]]~~ : forall {tau : Type Delta kappa}
               {v : SemType Delta kappa} -> 
               [[ tau ]]~~ v -> 
               tau .=.t Up (reify v)
\end{agda}

% We lastly find it necessary to confirm that each neutral type is indeed equivalent to its $\eta$-expansion: 

% \begin{agda}
% eta-norm-.=.t : forall (n : NeutralType Delta kappa) -> 
%                 Up (eta-norm n) .=.t UpNE n
% \end{agda}

\subsubsection{Logical environments}

A syntactic substitution is related to a semantic environment when the substitution relates at each point in the environment.

\begin{agda}
[[_]]e~~ : Substitution Delta_1  Delta_2 -> SemEnv Delta_1  Delta_2 -> Set 
[[ sigma ]]e~~ eta = (alpha : TVar Delta_1 kappa) -> [[ sigma alpha ]]~~ (eta alpha)
\end{agda}

Here a syntactic substitution is a map from type variables to !Type!s: 

\begin{agda}
Substitution : Env -> Env -> Set
Substitution Delta_1  Delta_2 = TVar Delta_1 kappa -> Type Delta_2 kappa
\end{agda}

We show that the identity syntactic substitution !`! and the identity semantic environment are point-wise related. 

\begin{agda}
idEnv-[[]]~~ : [[ ` ]]e~~ idEnv 
idEnv-[[]]~~ alpha = reflect-[[]]~~ eq-refl
\end{agda}

\subsubsection{The fundamental theorem and Soundness}

Finally, the fundamental theorem of soundness states that the syntactic substitution of a type !tau! by !sigma! is related to its semantic evaluation in !eta!, provided !sigma! and !eta! are related. The definition is by induction over !tau!.

\begin{agda}
fundS : (tau : Type Delta_1 kappa) -> 
        [[ sigma ]]e~~ eta -> 
        [[ sub sigma tau ]]~~ (eval tau eta)
\end{agda}

Soundness follows from a trivial case of the fundamental theorem where the environments related are the identity substitution !`! and the identity semantic environment !idEnv!:

\begin{agda}
vdash[[_]]~~ : (tau : Type Delta kappa)  -> [[ tau ]]~~ eval tau idEnv  
vdash[[ tau ]]~~ = 
  subst-[[]]~~ (sub-id tau) (fundS tau idEnv-[[]]~~)
  where
    subst-[[]]~~ : tau_1 .=.t tau_2 -> [[ tau_1 ]]~~ v -> [[ tau_2 ]]~~ v
    sub-id : forall (tau : Type Delta kappa) -> sub ` tau .=.t tau

soundness : forall (tau : Type Delta kappa) -> tau .=.t Up (Down tau)
soundness tau =  reify-[[]]~~ (vdash[[ tau ]]~~)
\end{agda}

\subsection{Decidability of type conversion}

Equivalence of normal types is syntactically decidable which, in conjunction with soundness and completeness, is sufficient to show that \Rome's equivalence relation is decidable.

\ifthms
\begin{theorem}[Decidability]
  Given well-kinded $\tau, \upsilon \in \TJudges{\Delta}{\kappa}$, the judgment $\TEqvJ \Delta \tau \upsilon \kappa$ either (i) has a derivation or (ii) has no derivation.
\end{theorem}\fi

It is easy enough to implement a syntactic decidability check on the shapes of normal forms; simply proceed by case analysis on both !tau_1! and !tau_2!.

\begin{agda}
_.=.?_ : forall (tau_1 tau_2 : NormalType Delta kappa) -> Dec (tau_1 .=. tau_2)
\end{agda}

Paired with soundness and completeness, we get an effective decision procedure to decide the relation !tau_1 .=.t tau_2! as follows: 

\begin{agda}
_.=.t?_ : forall (tau_1 tau_2 : Type Delta kappa) -> Dec (tau_1 .=.t tau_2)
tau_1 .=.t? tau_2  with (Down tau_1) .=.? (Down tau_2)
... | yes p = yes 
    (eq-trans 
        (soundness tau_1) 
        (embed-.=.t p))
... | no  p = no (\ x -> p (completeness x))
\end{agda}


\section{Most closely related work}
\label{sec:related-work} 

We conclude with a discussion of closely related work. 

\subsection{Intrinsic mechanization of $F\omega\mu$ and other languages.} Our technical development owes a great debt to two papers in particular. We closely follow the formalization and proof techniques of \citet{ChapmanKNW19}; indeed, this paper is in some sense an extension of their work from System \Fome to system \Rome. In turn, \citet{ChapmanKNW19} themselves follow closely \citet{AllaisBM13}, from whom we looked to in finding the correct normal form of inert row maps (borrowing from their formalization of lists). This paper differs from \citet{ChapmanKNW19}, but not \citet{AllaisBM13}, in that \Rome introduces additional definitional equality rules. In contrast to \citet{ChapmanKNW19}, we also reason about types modulo $\eta$-equivalence of functions and expansion of rows to inert maps, which made many proof definitions harder to define.

\subsection{Featherweight Ur.} A comparison must be made between \Rome and Featherweight Ur \citep{Chlipala10}, each of which have type-level rows and mapping operators. However, Ur focuses on type-level records and does not witness the duality between $\Pi$ and $\Sigma$ types. Further, \citet{Chlipala10} give an elaborative semantics, translating Featherweight Ur to the Calculus of Inductive Constructions, in order to inherit metatheory. It is unclear if a procedure has been mechanized to normalize Featherweight Ur types according to its own definitional equality rules. The authors write that "most of Ur constructor unification could be implemented by normalizing constructors and then comparing normal forms ... We can refactor the definitional equality rules of [Featherweight Ur] so that, when applied only left-to-right, they form a rewrite system that we conjecture is terminating and confluent." So it may be possible that results alike ours could be replicated in Featherweight Ur, but we are unaware of any extant attempts. To their credit, Featherweight Ur is more concerned with practical unification and inference implementation details, of which this development can stake no parallel claim.

\bibliographystyle{plainnat}
\bibliography{NBE}
\end{document}
%%% Local Variables: 
%%% TeX-command-extra-options: "-shell-escape"
%%% End:
%  LocalWords:  denotational Agda Wadler dPoint sqrt subtyping coercions Intr
%  LocalWords:  RowTypes Bool eval GHC reified HillerstromL Leijen LindleyM RO
%  LocalWords:  ChapmanKNW Aydemir AbelAHPMSS AbelC AbelOV plfa HubersIMM STLC
%  LocalWords:  MorrisM denotationally DenotationalSoundness RowTheories Suc de
%  LocalWords:  ReifyingVariants RowTheory BerthomieuM CardelliMMS HarperP NatF
%  LocalWords:  XueOX GasterJ Sipser SaffrichTM Env Expr Agda's Leivant ChanW
%  LocalWords:  ThiemannW ImpredicativeSet ImpredicativeSetSucks AbelP chapman
%  LocalWords:  AltenkirchK KaposiKK Gaster XieOBS BiXOS Chlipala objTypes Bahr
%  LocalWords:  Garrigue KEnv PEnv
