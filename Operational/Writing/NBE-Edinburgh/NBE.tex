\documentclass[sigplan,10pt,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
\overfullrule=1mm
% \usepackage[margin=1.5in]{geometry}

\include{header.tex} 
\usepackage{agda}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% ACM garbage
\setcopyright{none}
\citestyle{acmauthoryear}
\settopmatter{printacmref=false, printfolios=true}
\renewcommand{\footnotetextcopyrightpermission}{} 
% Redefine the \acmDOI command to do nothing 
\pagestyle{empty}
\fancyfoot{}

%\usepackage[utf8]{inputenc}
% \numberwithin{equation}{section}
% \numberwithin{theorem}{section}

\title{Normalization By Evaluation of Types in \Rome}
\author{Alex Hubers}
\orcid{0000-0002-6237-3326}
\affiliation{
  \department{Department of Computer Science}
  \institution{The University of Iowa}
  \streetaddress{14 MacLean Hall}
  \city{Iowa City}
  \state{Iowa}
  \country{USA}}
\email{alexander-hubers@uiowa.edu}

\usepackage{newunicodechar}
\newunicodechar{âˆ‹}{$\ni$}
\newunicodechar{Îµ}{$\epsilon$}
\newunicodechar{Â·}{$\cdot$}
\newunicodechar{âŠ¢}{$\vdash$}
\newunicodechar{â‹†}{${}^\star$}
\newunicodechar{Î }{$\Pi$}
\newunicodechar{â‡’}{$\Rightarrow$}
\newunicodechar{Æ›}{$\lambdabar$}
\newunicodechar{âˆ…}{$\emptyset$}
\newunicodechar{âˆ€}{$\forall$}
\newunicodechar{Ï•}{$\Phi$}
\newunicodechar{Ï†}{$\phi$}
\newunicodechar{Ïˆ}{$\Psi$}
\newunicodechar{Ï}{$\rho$}
\newunicodechar{Î±}{$\alpha$}
\newunicodechar{Î²}{$\beta$}
\newunicodechar{Î¼}{$\mu$}
\newunicodechar{Ïƒ}{$\sigma$}
\newunicodechar{â‰¡}{$\equiv$}
\newunicodechar{Î“}{$\Gamma$}
\newunicodechar{âˆ¥}{$\parallel$}
\newunicodechar{Î›}{$\Lambda$}
\newunicodechar{â‚‚}{$_2$}
\newunicodechar{Î¸}{$\theta$}
\newunicodechar{Î˜}{$\Theta$}
\newunicodechar{âˆ˜}{$\circ$}
\newunicodechar{Î”}{$\Delta$}
\newunicodechar{â˜…}{$\star$}
\newunicodechar{Î»}{$\lambda$}
\newunicodechar{âŠ§}{$\models$}
\newunicodechar{âŠŽ}{$\uplus$}
\newunicodechar{Î·}{$\eta$}
\newunicodechar{âŠ¥}{$\bot$}
\newunicodechar{Î£}{$\Sigma$}
\newunicodechar{Î¾}{$\xi$}
\newunicodechar{â‚}{$_1$}
\newunicodechar{â‚–}{$_k$}
\newunicodechar{â‚ƒ}{$_3$}
\newunicodechar{â„•}{$\mathbb{N}$}
\newunicodechar{á¶œ}{${}^c$}
\newunicodechar{Î¦}{$\Phi$}
\newunicodechar{Î¨}{$\Psi$}
\newunicodechar{âŠ¤}{$\top$}
\newunicodechar{Îº}{$\kappa$}
\newunicodechar{Ï„}{$\tau$}
\newunicodechar{Ï€}{$\pi$}
\newunicodechar{âŒŠ}{$\lfloor$}
\newunicodechar{âŒ‹}{$\rfloor$}
\newunicodechar{â‰²}{$\lesssim$}
\newunicodechar{â–¹}{$\triangleright$}
\newunicodechar{â„“}{$\ell$}
\newunicodechar{Ï…}{$\upsilon$}

\newunicodechar{â†’}{$\rightarrow$}
\newunicodechar{Ã—}{$\times$}
\newunicodechar{Ï‰}{$\omega$}
\newunicodechar{âˆƒ}{$\exists$}
\newunicodechar{âˆˆ}{$\in$}
\newunicodechar{â‡‘}{$\Uparrow$}
\newunicodechar{â‡“}{$\Downarrow$}
\newunicodechar{â‰‹}{$\approx$}
\newunicodechar{â‚—}{$_l$}
\newunicodechar{áµ£}{$_r$}
\newunicodechar{âŸ¦}{$\llbracket$}
\newunicodechar{âŸ§}{$\rrbracket$}
\newunicodechar{â»}{$^{-}$}
\newunicodechar{Â¹}{$^{1}$}
\newunicodechar{â‚„}{$_{4}$}
\newunicodechar{â¦…}{$\llparenthesis$}
\newunicodechar{â¦†}{$\rrparenthesis$}
\newunicodechar{â”€}{$\setminus$}
\newunicodechar{âˆ·}{$\co\co$}
\newunicodechar{â‚–}{$_{k}$}
\newunicodechar{â‚™}{$_{n}$}
\newunicodechar{â‰Ÿ}{$\overset{?}{=}$}
\newunicodechar{ð’¯}{$\mathcal T$}
\newunicodechar{â¨¾}{$\co$}
\newunicodechar{Îž}{$\Xi$}
\newunicodechar{Î¾}{$\xi$}

\begin{document}
\InlineOn{}

\maketitle

\section*{Abstract}
\citet{HubersIMM24} introduce \Rome, a higher-order row calculus, but do not describe any metatheory of its type equivalence relation nor of type reduction. \Rome extends System \Fome with rows, records, variants, row mapping, and a novel \emph{row complement} operator. This paper shows not only that \Rome types enjoy normal forms, but formalizes the normaliz\-ation\--by\--evaluation (NbE) of types in the interactive proof assistant Agda. We prove that our normalization algorithm is stable, sound and complete with respect to the type equivalence relation. Consequently, type conversion in \Rome is decidable.

\section{Introduction}
\citet{HubersM23} introduce an expressive higher-order row calculus called \RO, which relies on implicit type reductions according to a directed type equivalence relation. Despite this reliance, the authors only provide a proof of \emph{semantic soundness} that well-typed terms inhabit the denotations of well-kinded types. The authors do not characterize the shape of types in normal form, nor prove that the denoted types are sound and complete with respect to the equivalence relation. \citet{HubersIMM24} extends the \RO language to \Rome, which is \RO with recursive types, term-level recursion, and a novel \emph{row complement} operator. The authors similarly extend the proof of semantic soundness, and fail to describe any metatheory of the equivalence relation.

\subsection{The need for type normalization}
\label{sec:need-for-type-normalization}
\RO and \Rome each have a type conversion rule. The rule below states that the term $M$ can have its type converted from $\tau$ to $\upsilon$ provided a proof that $\tau$ and $\upsilon$ are equivalent. (For now, let us split environments into kinding environments $\Delta$, evidence environments $\Phi$, and typing environments $\Gamma$.)

\[ 
\ib{\irule[\trule{conv}]
          {\TypeJ \Delta \Phi \Gamma M \tau}
          {\TEqvJ \Delta \tau \upsilon \TypeK};
          {\TypeJ \Delta \Phi \Gamma M \upsilon}}
\] 

Conversion rules can complicate metatheory. In particular, \citet{HubersM23,HubersIMM24} do not provide a procedure to decide type equivalence, and so proofs of type conversion must be embedded into the term language. This has a number of consequences:
\begin{enumerate}[nolistsep]
  \item Users of the surface language may be forced to write conversion rules by hand.  
  \item Decidability of type checking now rests upon the decidability of type conversion.
  \item Term-level conversions can block $\beta$-reduction if a conversion is in the head position of an application. 
  \item Term-level conversions can block proofs of progress. Let !M! have type !tau!, let !pf! be a proof that !tau = upsilon!, and consider the term !conv! !M! !pf!; ideally, one would expect this to reduce to !M! (we've changed nothing semantically about the term). But this breaks type preservation, as !conv! !M! !pf! (at type !upsilon!) has stepped to a term at type !tau!. 
  \item Inversion of the typing judgment $\TypeJ \Delta \Phi \Gamma  M \tau$---that is, induction over derivations---must consider the possibility that this derivation was constructed via conversion. But conversion from what type? Proofs by induction over derivations often thus get stuck. 
\end{enumerate}

All of these complications may be avoided provided a sound and complete normalization algorithm. In such a case, all types are reduced to normal forms, where syntactic comparison is enough to decide equivalence. In effect, the proofs of all conversions have collapsed to just the reflexive case, and so term-level conversions can safely be removed.

\subsection{Contributions}
This paper offers the following as contributions: 

\begin{enumerate}
  \item A normalization procedure for the directed \RO and \Rome type equivalence relation;
  \item the semantics of a novel \emph{row complement} operator;
  \item proofs of soundness and completeness of normalization with respect to type equivalence; and
  \item a complete mechanization in Agda of \Rome and the claimed metatheoretic results.
\end{enumerate}

\section{The \Rome{} calculus}
\label{sec:Rome-calculus}

\Cref{fig:syntax-types} describes the syntax of kinds, predicates, and types in \Rome. 

\begin{figure}
\begin{gather*}
\begin{array}{r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l}
\text{Type variables} & \alpha \in \mathcal A & \text{Labels} & \ell \in \mathcal L
\end{array}
\\[5px]
\begin{doublesyntaxarray}
  \mcl{\text{Kinds}} & \kappa & ::= & \TypeK \mid \LabK \mid \RowK \kappa \mid \kappa \to \kappa \\
  \mcl{\text{Predicates}} & \pi, \psi & ::= & \LeqP \rho \rho \mid \PlusP \rho \rho \rho \\
  \text{Types} & \mcr{\Types \ni \phi, \tau, \rho, \xi} & ::= & \alpha \mid T \mid  \tau \to \tau \mid \pi \then \tau \\
               &                              &     & \mid    & \forall \alpha\co\kappa. \tau \mid \lambda \alpha\co\kappa. \tau \mid \tau \, \tau\\
               &                              &     & \mid    & \RowIx i 0 m {\LabTy {\xi_i} {\tau_i}} \mid \ell \mid \Sing{\tau} \\ 
               &                              &     & \mid    & \Mapp{\phi}{\rho} \mid \rho \Compl \rho \\
  \mcl{\text{Type constants}} & T & ::= & \KFam \Pi \kappa \mid \KFam \Sigma \kappa \mid \mu \\
\end{doublesyntaxarray}
\end{gather*}
\caption{Syntax}
\label{fig:syntax-types}
\end{figure}

Labels (i.e., record field and variant constructor names) live at the type level, and are classified by kind $\LabK$. Rows of kind $\kappa$ are classified by $\RowK \kappa$. When possible, we use $\phi$ for type functions, $\rho$ for row types, and $\xi$ for label types. Singleton types $\Sing \tau$ are used to cast label-kinded types to types at kind $\TypeK$.  $\Mapp\phi \rho$ maps the type operator $\phi$ across a row $\rho$. In practice, we often leave the map operator implicit, using kind information to infer the presence of maps. We define a families of  $\Pi$ and $\Sigma$ constructors, describing record and variants at various kinds; in practice, we can determine the kind annotation from context. $\mu$ builds isorecursive types. Row literals (or, synonymously, \emph{simple rows}) are sequences of labeled types $\LabTy {\xi_i} {\tau_i}$. We write $0 \dots m$ to denote the set of naturals up to (but not including) $m$. We will frequently use $\varepsilon$ to denote the empty row.

The type $\pi \then \tau$ denotes a qualified type. In essence, the predicate $\pi$ restricts the instantiation of the type variables in $\tau$. Our predicates capture relationships among rows: $\LeqP {\rho_1} {\rho_2}$ means that $\rho_1$ is \emph{contained} in $\rho_2$, and $\PlusP {\rho_1} {\rho_2} {\rho_3}$ means that $\rho_1$ and $\rho_2$ can be \emph{combined} to give $\rho_3$.

Finally, $\Rome$ introduces a novel \emph{row complement} operator $\rho_2 \Compl \rho_1$, analogous to a set complement for rows. The complement $\rho_2 \Compl \rho_1$ intuitively means the row obtained by removing any label-type associations in $\rho_1$ from $\rho_2$. In practice, the type $\rho_2 \Compl \rho_1$ is meaningful only when we know that $\LeqP {\rho_1} {\rho_2}$, however constraining the formation of row complements to just this case introduces an unpleasant dependency between predicate evidence and type well-formedness. In practice, it is easy enough to totally define the complement operator on all rows, even without the containment of one by the other. 

\subsection{Type computation in \Rome}
\RO and \Rome are quite expressive languages, with succinct and readable types. To some extent, this magic relies on implicit type application, implicit maps, and unresolved type reduction. Let us demonstrate with a few examples.

\subsubsection{Reifying variants, reflecting records} The following \RO terms witness the duality of records and variants. 

\begin{rosi}
reify : forall z : R[ * ], t : *. 
        (Sigma z -> t) -> Pi (z -> t)
reflect : forall z : R[ * ], t : *. 
          Pi (z -> t) -> Sigma z -> t
\end{rosi}

The term !reify! transforms a variant eliminator into a record of individual eliminators; the term !reflect! transforms a record of individual eliminators into a variant eliminator. The syntax above is precise, but arguably so because it hides some latent computation. In particular, what does !z -> t! mean? The variable !z! is at kind !R[ * ]! and !t! at kind !*!, so this is an implicit map. Rewriting explicitly yields: 

\begin{rosi}
  reify : forall z : R[ * ], t : *. 
          (Sigma z -> t) -> Pi ((\s. s -> t) .map. z)
reflect : forall z : R[ * ], t : *. 
          Pi ((\s. s -> t) .map. z) -> Sigma z -> t
\end{rosi}

\Ni The writing of the former rather than the latter is permitted because the corresponding types are convertible.


\subsubsection{Deriving functorality} We can simulate the deriving of functor typeclass instances: given a record of !fmap! instances at type !Pi (Functor z)!, we can give a !Functor! instance for !Sigma z!. 

\begin{rosi}
type Functor : (* -> *) -> *
type Functor = \f. forall a b. (a -> b) -> f a -> f b
fmapS : forall z : R[* -> *]. 
        Pi (Functor z) -> Functor (Sigma z)
\end{rosi}

\Ni When we consider the kind of !Functor z! it becomes apparent that this is another implicit map. Let us write it explicitly and also expand the !Functor! type synonym:

\begin{rosi}
fmapS : forall z : R[* -> *]. 
      Pi ((\f. forall a b. 
        (a -> b) -> f a -> f b) .map. z) -> 
      (\f. forall a b. (a -> b) -> f a -> f b) (Sigma z)
\end{rosi}

\Ni which reduces further to:

\begin{rosi}
fmapS : forall z : R[* -> *]. 
        Pi ((\f. forall a b. 
            (a -> b) -> f a -> f b) .map. z) -> 
        forall a b. (a -> b) -> (Sigma z) a -> (Sigma z) b
\end{rosi}

\Ni Intuitively, we suspect that !(Sigma z) a! means "the variant of type constructors z applied to the type variable !a!". Let us make this intent obvious. First, define a "left-mapping" helper !_??_!  with kind !R[ * -> * ] -> * -> R[ * ]!  as so:

\begin{rosi}
  r ?? t = (\ f. f t) .map. r
\end{rosi}

\Ni Now the type of !fmapS! is:

\begin{rosi}
fmapS : forall z : R[* -> *]. 
        Pi ((\f. forall a b. 
            (a -> b) -> f a -> f b) .map. z) -> 
        forall a b. (a -> b) -> Sigma (z ?? a) -> Sigma (z ?? b)
\end{rosi}

\Ni And we have what appears to be a normal form. Of course, the type is more interesting when applied to a real value for !z!. Suppose !z! is a functor for naturals, !{'Z := const Unit,! !'S := \x. x}!. Then a first pass yields:

\begin{rosi}
fmapS {'Z := const Unit, 'S := \x. x} : 
        Pi ((\f. forall a b. (a -> b) -> f a -> f b) 
          .map. {'Z := const Unit, 'S := \x. x}) -> 
        forall a b. (a -> b) -> 
        Sigma ({'Z := const Unit, 'S := \x. x} ?? a) -> 
        Sigma ({'Z := const Unit, 'S := \x. x} ?? b)
\end{rosi}

How do we reduce from here? Regarding the first input, we suspect we would like a record of fmap instances for both the !'Z! and !'S! functors. We further intuit that the subterm !({'Z := const Unit,! !'S := \x. x}! !??! !a)! really ought to mean "the row with !'Z! mapped to !Unit! and !'S! mapped to !a!". Performing the remaining reductions yields:

\begin{rosi}
fmapS {'Z := const Unit, 'S := \x. x} : 
        Pi {'Z := forall a b. (a -> b) -> Unit -> Unit, 
            'S := forall a b. (a -> b) -> a -> b} -> 
        forall a b. (a -> b) -> 
        Sigma {'Z := Unit , 'S := a} ->
        Sigma {'Z := Unit , 'S := b}
\end{rosi}

The point we arrive at is that the precision of some \RO and \Rome types are supplanted quite effectively by type equivalence. Further, as values are passed to type-operators, the shapes of the types incur forms of reduction beyond simple $\beta$-reduction. In this case, we must map type operators over rows; we next consider the reduction of row complements.


\subsubsection{Desugaring Booleans} Consider a desugaring of Booleans to Church encodings:

\begin{rosi}
type BoolF = { 'T := const Unit , 
               'F := const Unit , 
               'If := \x. Triple x x x}
type LamF  = { 'Lam := Id , 
               'App := \x. Pair x x , 
               'Var := const Nat }
desugar : forall y. BoolF < y, LamF < y - BoolF =>
          Pi (Functor (y - BoolF)) -> 
          Mu (Sigma y) -> 
          Mu (Sigma (y - BoolF))
\end{rosi}

We will ignore the already stated complications that arise from subexpressions such as !Functor! !(y - BoolF)! and skip to the step in which we tell !desugar! what particular row !y! it operates over. Here we know it must have at least the !BoolF! and !LamF! constructors. Let us try something like the following AST, using !++! as pseudonotation for row concatenation to save space.

\begin{rosi}
type AST = BoolF ++ LamF ++ 
          {'Lit := const Int , 'Add := \x. Pair x x }
desugar AST : BoolF < AST, LamF < (AST - BoolF) =>
              Pi (Functor (AST - BoolF)) -> 
              Mu (Sigma y) -> Mu (Sigma (AST - BoolF))
\end{rosi}

\Ni When !desugar! is passed !AST! for !z!, the inherent computation in the complement operator is made more obvious. What should !AST - BoolF! reduce to? Intuitively, we suspect the following to hold: 

\begin{rosi} 
AST - BoolF = {'Lit := const Int , 
               'Add := \x. Pair x x, 
               'Lam := Id , 
               'App := \x. Pair x x , 
               'Var := const Nat }
\end{rosi}

\Ni But this computation must be realized, just as (analogously) $\lambda$-redexes are realized by $\beta$-reduction.

\section{Type Equivalence \& Reduction}

We define reduction on types $\tau \RedT \tau'$ by directing the type equivalence judgment $\TEqvJ \Delta \tau {\tau'} \kappa$ from left to right, defined in \cref{fig:equivalence}. We omit conversion and closure rules.

\newcommand\Subtract{\mathsf{subtract}}
\InlineOff{}
\begin{figure}
\begin{small}
\begin{gather*}
\fbox{$\TEqvJ \Delta \tau \tau \kappa$}
\\
\ib{\irule[\erule{$\beta$}]
          {\KindJ \Delta {(\lambda \alpha\co\kappa. \tau) \, \upsilon} {\kappa'}};
          {\TEqvJ \Delta {(\lambda \alpha\co\kappa. \tau)\,\upsilon} {\tau[\upsilon/\alpha]} {\kappa'}}}
\\
\begin{gathered}
\ib{\irule[\errule{lift$_\Xi$}]
          {\KindJ \Delta \rho {\RowK {\kappa_1 \to \kappa_2}}}
          {\KindJ \Delta \tau \kappa};
          {\TEqvJ \Delta {(\KFam \Xi {\kappa_1 \to \kappa_2} \rho) \, \tau} {\KFam \Xi {\kappa_2} (\rho \, \Flap \, \tau)} {\kappa_2}}!
          {\Xi \in \Set {\Pi, \Sigma}}}
\\
\text {where $\rho \, \Flap \, \tau = \Mapp {(\lambda f. f \, \tau)} \rho$}
\end{gathered}
\\
\ib{\irule[\erule{$\setminus$}]
          {\KindJ \Delta {\RowIx i 0 n {\LabTy {\xi_i} {\tau_i}}} {\RowK \kappa}}
          {\KindJ \Delta {\RowIx j 0 m {\LabTy {\xi_j} {\tau_j}}} {\RowK \kappa}};
          % {\Delta \vdash \mathsf{subtract} \, \rho_1 \, \rho_2 \, \rho_3};
          {\TEqvJ \Delta {{\Row {\LabTy {\xi_i} {\tau_i}}} \Compl {\Row {\LabTy {\xi_j} {\tau_j}}}} {\Subtract \, {\Row {\LabTy {\xi_i} {\tau_i}}} \, {\Row{\LabTy {\xi_j} {\tau_j}}}} {\RowK \kappa}}}
\\
\ib{\irule[\errule{map}]
          {\KindJ \Delta \phi {\kappa_1 \to \kappa_2}}
          {\KindJ \Delta {\RowIx i 0 n {\LabTy {\xi_i} {\tau_i}}} {\RowK{\kappa_1}}};
          {\TEqvJ \Delta {\Mapp {\phi} {\RowIx i 0 n {\LabTy {\xi_i} {\tau_i}}}} {\RowIx i 0 n {\LabTy {\xi_i} {\phi\,\tau_i}}} {\RowK{\kappa_2}}}}
\\
\ib{\irule[\errule{map$_\mathsf{id}$}]
          {\KindJ \Delta \rho {\RowK\kappa}};
          {\TEqvJ \Delta \rho {\Mapp {(\lambda \alpha. \alpha)} \rho} {\RowK\kappa}}}
\\
\begin{gathered}
\ib{\irule[\errule{map$_\circ$}]
          {\KindJ \Delta {\phi_1} {\kappa_2 \to \kappa_3}}
          {\KindJ \Delta {\phi_2} {\kappa_1 \to \kappa_2}}
          {\KindJ \Delta \rho {\RowK {\kappa_1}}};
          {\TEqvJ \Delta {\Mapp {\phi_1} {(\Mapp {\phi_2} \rho)}} {\Mapp {(\phi_1 \circ \phi_2)} \rho} {\kappa_3}}}
\\
\text{where $\phi_1 \circ \phi_2 = \lambda \alpha. \phi_1 \, (\phi_2 \, \alpha)$}
\end{gathered}
\\
\ib{\irule[\errule{map$_{\setminus}$}]
          {\KindJ \Delta {\phi} {\kappa_1 \to \kappa_2}}
          {\KindJ \Delta {\rho_i} {\RowK {\kappa_1}}};
          {\TEqvJ \Delta {\Mapp {\phi} {(\rho_2 \setminus \rho_1)}} {\Mapp \phi {\rho_2} \setminus {\Mapp \phi {\rho_1}}} {\kappa_2} }}
\\
\ib{\irule[\errule{$\Xi$}]
          {\KindJ \Delta \rho {\RowK {\RowK {\kappa}}}};
          {\TEqvJ \Delta {\KFam \Xi {\RowK \kappa} \, \rho} {\Mapp {{\KFam \Xi \kappa}} \rho} {\RowK {\kappa}}}!
          {\Xi \in \{ \Pi , \Sigma \}}}
\\ 
\ib{\irule[\errule{$\eta$}]
          {\KindJ \Delta \phi {\kappa_1 \to \kappa_2}};
          {\TEqvJ \Delta {\phi} {\lambda \alpha \co \kappa_1. \phi \, \alpha} {\kappa_1 \to \kappa_2}}
}
\\[5pt]
\fbox{$\Subtract \, \rho \, \rho$}
\\
\begin{small}
\begin{aligned}
  \Subtract& \, \EmptyRow \, \rho = \EmptyRow \\
  \Subtract& \, \rho \, \EmptyRow = \rho \\
  \Subtract& \, \Row {\LabTy \ell \tau, \rho} \, \Row{\LabTy {\ell'} {\tau'}, {\rho'}} = \\
    &\begin{cases}
      \Subtract \, \rho \, \rho' &\text{if $\ell = \ell'$ and $\tau = \tau'$} \\
      \Row {\LabTy \ell \tau, \Subtract \, \rho \, \Row {\LabTy {\ell'} {\tau'}, \rho'}} &\text{if $\ell < \ell'$} \\
      \Subtract \, \Row {\LabTy \ell \tau, \rho} \, \rho' &\text{if $\ell > \ell'$}
    \end{cases}
\end{aligned}
\end{small}
\end{gather*}
\end{small}
\caption{Type equivalence}
\label{fig:equivalence}
\end{figure}



\subsection{Normal forms}

The syntax of normal types is given in \cref{fig:type-normalization}. % We carefully define the normal type syntax so that no type $\Normal \tau \in \NormalTypes$ could reasonably reduce further to some other $\tau' \in \NormalTypes$. Hence we write $\tau \NRedT$ synonymously with $\tau \in \NormalTypes$ to indicate that $\tau$ is well-kinded and has no further reductions.

\begin{figure}[H]
\begin{gather*}
\begin{array}{r@{\hspace{7px}}l@{\qquad\qquad}r@{\hspace{7px}}l}
  \text{Type variables} & \alpha \in \mathcal A &
  \text{Labels} & \ell \in \mathcal L
\end{array} \\
\begin{doublesyntaxarray}
  \mcl{\text{Ground Kinds}}  & \gamma   & ::= & \TypeK \mid \LabK \\
  \mcl{\text{Kinds}}         & \kappa    & ::= & \gamma \mid \kappa \to \kappa \mid  \RowK \kappa \\
  \mcl{\text{Row Literals}}   & \NormalRows \ni \Normal \rho    & ::= & \RowIx i 0 m {\LabTy {\ell_i} {\Normal {\tau_i}}} \\
  \mcl{\text{Neutral Types}} & n    & ::= & \alpha \mid n \, {\Normal \tau}  \\
  \mcl{\text{Normal Types}}  & \NormalTypes \ni \Normal \tau, \Normal \phi & ::= & n \mid \Mapp {\hat{\phi}} {n} \mid \Normal{\rho} \mid \Normal{\pi} \then \Normal{\tau} \\
                             &       &     & \mid &  \forall \alpha\co\kappa. \Normal{\tau} \mid \lambda \alpha\co\kappa. \Normal{\tau}  \\ 
                             &       &     & \mid & \LabTy n {\Normal \tau} \mid \ell \mid \Sing {\Normal \tau} \mid {\Normal \tau} \Compl {\Normal \tau} \\
                             &       &     & \mid & {\KFam \Pi \TypeK} {\Normal \tau} \mid {\KFam \Sigma \TypeK} {\Normal \tau}                         
\end{doublesyntaxarray}
\end{gather*}
\begin{small}
\begin{gather*}
\fbox{$\KindJNF \Delta {\Normal \tau} {\kappa}$} \, \fbox{$\KindJNE \Delta {n} {\kappa}$} \\
\ib{
  \irule[\kruleNF{ne}]
    {\KindJNE \Delta n \gamma};
    {\KindJNF \Delta n \gamma}}
\isp
\ib{
  \irule[\kruleNF{$\Compl$}]
    {\KindJNF \Delta {\Normal {\tau_i}} {\RowK \kappa}}
    {\Normal{\tau_1} \notin \NormalRows \, \text{or}\, \Normal{\tau_2} \notin \NormalRows};
    {\KindJNF \Delta {\Normal{\tau_2} \Compl \Normal{\tau_1}} {\RowK \kappa}}}
\\
\ib{
  \irule[\kruleNF{$\triangleright$}]
    {\KindJNE \Delta {n} {\LabK}}{\KindJNF \Delta {\Normal \tau} \kappa};
    {\KindJNF \Delta {\LabTy n {\Normal \tau}}{\RowK \kappa}}}
\end{gather*}
\end{small}
\caption{Normal type forms}
\label{fig:type-normalization}
\end{figure}

Normalization reduces applications and maps except when a variable blocks computation, which we represent as a \emph{neutral type}. A neutral type is either a variable or a spine of applications with a variable in head position. We distinguish ground kinds $\gamma$ from functional and row kinds, as neutral types may only be promoted to normal type at ground kind (rule \kruleNF{ne}): neutral types $n$ at functional kind must $\eta$-expand to have an outer-most $\lambda$-binding (e.g., to $\lambda x. \, n\, x$), and neutral types at row kind are expanded to an inert map by the identity function (e.g., to $\Mapp {(\lambda x. x)} {n}$). Likewise, repeated maps are necessarily composed according to rule \errule{map$_\circ$}: For example, $\Mapp {\phi_{1}} {(\Mapp {\phi_{2}} {n})}$ normalizes by letting $\phi_{1}$ and $\phi_{2}$ compose into $(\Mapp {(\phi_{1} \circ \phi_{2})} n$). By consequence of $\eta$-expansion, records and variants need only be formed at kind $\TypeK$. This means a type such as $\Pi (\LabTy {\ell} {\lambda x. x})$ must reduce to $\lambda x. \Pi (\LabTy {\ell} {x})$, $\eta$-expanding its binder over the $\Pi$. Nested applications of $\Pi$ and $\Sigma$ are also "pushed in" by rule \erule{$\Xi$}. For example, the type $\Pi \, \Sigma \, (\LabTy {\ell_1} {(\LabTy  {\ell_2} \tau)})$ has $\Sigma$ mapped over the outer row, reducing to $\Pi (\LabTy {\ell_1} {\Sigma (\LabTy {\ell_2} \tau)})$.

The syntax $\LabTy n \Normal \tau$ separates singleton rows with variable labels from row literals $\Normal \rho$ with literal labels; rule \kruleNF{$\triangleright$} ensures that $n$ is a well-kinded neutral label.  A row is otherwise an inert map $\Mapp \phi n$ or the complement of two rows $\Normal{\tau_2} \Compl \Normal{\tau_1}$. Observe that the complement of two row literals should compute according to rule \erule{$\Compl$}; we thus require in the kinding of normal row complements \kruleNF{$\Compl$} that one (or both) rows are not literal so that the computation is indeed inert. The remaining normal type syntax does not differ meaningfully from the type syntax; the remaining kinding rules for the judgments $\KindJNF \Delta {\Normal \tau} \kappa$ and $\KindJNE \Delta n \kappa$ are as expected.
\subsection{Metatheory}
\label{sec:metatheory-summary}

\subsubsection{Canonicity of normal types}

The normal type syntax is pleasantly partitioned by kind. Due to $\eta$-expansion of functional variables, arrow kinded types are canonically $\lambda$-bound. A normal type at kind $\RowK \kappa$ is either an inert map $\hat{\phi}^{\TypeK} \, n$, a variable-labeled row $(\LabTy n \Normal \tau)$, the complement of two rows $\Normal {\tau_{2}} \Compl \Normal {\tau_{1}}$, or a row literal $\Normal \rho$. The first three cases necessarily have neutral types (recall that at least one of the two rows in a complement is not a row literal). Hence rows in empty contexts are canonically literal. Likewise, the only types with label kind in empty contexts are label literals; recall that we disallowed the formation of $\Pi$ and $\Sigma$ at kind $\RowK \LabK \to \LabK$, thereby disallowing non-literal labels such as $\Delta \not\vdash \Pi \epsilon \co \LabK$ or $\Delta \not\vdash \Pi (\LabTy {\ell_{1}} {\ell_{2}}) \co \LabK$.

\begin{theorem}[Canonicity]
  Let $\Normal\tau \in \NormalTypes$.
  \begin{itemize}
    \item If $\KindJNF \Delta {\Normal\tau} {(\kappa_{1} \to \kappa_{2})}$ then $\Normal\tau = {\lambda \alpha \co \kappa_{1}. \Normal\upsilon}$;
    \item if $\KindJNF \epsilon {\Normal\tau} {\RowK \kappa}$ then $\Normal\tau =  \RowIx i 0 m {\LabTy {\ell_i} {\Normal{\tau_i}}}$.
    \item If $\KindJNF \epsilon {\Normal\tau} \LabK$, then $\Normal\tau = \ell$.
  \end{itemize}
\end{theorem}
\subsubsection{Normalization}
\begin{theorem}[Normalization] ~
  There exists a normalization function $\Norm\, : \Types \to \NormalTypes$ that maps well-kinded types to well-kinded normal forms.
\end{theorem}

$\Norm$ is realized in Agda intrinsically as a function from derivations of $\KindJ \Delta \tau \kappa$ to derivations of $\KindJNF \Delta {\Normal{\tau}} \kappa$.  Conversely, we witness the inclusion $\NormalTypes \subseteq \Types$ as an embedding $\Embed \,:\, \NormalTypes \to \Types$, which casts derivations of $\KindJNF \Delta {\Normal \tau} \kappa$  back to a derivation of $\KindJ \Delta \tau \kappa$; we omit this function and its use in the following claims, as it is effectively the identity function (modulo tags).

The following properties confirm that $\Norm$ behaves as a normalization function ought to. The first property, \emph{stability}, asserts that normal forms cannot be further normalized. Stability implies \emph{idempotency} and \emph{surjectivity}.

\begin{theorem}[Properties of normalization] ~
  \begin{itemize}
  \item (Stability) for all $\Normal\tau \in \NormalTypes$, $\Norm \, \Normal\tau = \Normal\tau$.
  \item (Idempotency) For all $\tau \in \Types$, $ \Norm (\Norm \, \tau) =\, \Norm \, \tau$.
  \item (Surjectivity) For all $\Normal\tau \in \NormalTypes$, there exists $\upsilon \in \Types$ such that $\Normal\tau =\, \Norm \upsilon$.
  \end{itemize}
\end{theorem}

We now show that $\Norm$ indeed reduces faithfully according to the equivalence relation $\TEqvJ \Delta \tau \tau \kappa$. Completeness of normalization states that equivalent types normalize to the same form.

\begin{theorem}[Completeness]
For well-kinded $\tau , \upsilon \in \Types$ at kind $\kappa$, If $\TEqvJ \Delta \tau \upsilon \kappa$ then $\Norm\, \tau = \, \Norm \, \upsilon$.
\end{theorem}

\Ni Soundness of normalization states that every type is equivalent to its normalization.

\begin{theorem}[Soundness]
For well-kinded $\tau \in \Types$ at kind $\kappa$, there exists a derivation that $\TEqvJ \Delta \tau {\,\Norm \tau} {\kappa}$. Equivalently, if $\Norm\, \tau =\, \Norm\, \upsilon$, then $\TEqvJ \Delta \tau \upsilon {\kappa}$.
\end{theorem}
\Ni Soundness and completeness together imply, as desired, that $\tau \RedT \tau'$ iff $\Norm\, \tau =\, \Norm \tau'$.

\subsubsection{Decidability of type conversion}

Equivalence of normal types is syntactically decidable which, in conjunction with soundness and completeness, is sufficient to show that \Rome's equivalence relation is decidable.

\begin{theorem}[Decidability]
  Given well-kinded $\tau, \upsilon \in \Types$ at kind $\kappa$, the judgment $\TEqvJ \Delta \tau \upsilon \kappa$ either (i) has a derivation or (ii) has no derivation.
\end{theorem}

\section{Normalization by Evaluation (NbE)}
This section and those that follow give a closer examination into how the above metatheory was derived. In particular, we explain the \emph{normalization of types by evaluation} (NbE) involved in deriving a normalization algorithm. We describe the standard components of NbE, but place emphasis on the novelty of normalizing rows and row operators. The full development is available online as part of the anonymous supplementary materials. The code we present here is summarized and tidied for easier digestion, but otherwise remains faithful to the development in behavior and intent. The claims of this section are annotated with the corresponding points in our full artifact. 

\InlineOn{}
Normalization by evaluation comes in a handful of different flavors. In our case, we seek to build a normalization function $\Norm : \Types \to \NormalTypes$ by interpreting derivations in $\TJudges{\Delta}{\kappa}$ (the set of derivations of the judgment $\KindJ \Delta \tau \kappa$) into a semantic domain capable of performing reductions semantically. We then \emph{reify} objects in the semantic domain back to judgments in $\TJudgesNF{\Delta}{\kappa}$ (the set of derivations of the judgment $\KindJNF \Delta \tau \kappa$). The mapping of syntax to a semantic domain is typically written as $\Sem{\cdot}$ and called the \emph{residualizing semantics}. For example, a judgment of the form $\KindJ \Delta \phi {\TypeK \to \TypeK}$ could be interpreted into a set-theoretic function, allowing applications to be interpreted into set-theoretic applications by that function. In our case, the syntax of the judgments $\KindJ \Delta \tau \kappa$, $\KindJNF \Delta \tau \kappa$, and $\KindJNE \Delta \tau \kappa$ are represented as Agda data types (where !Env! is a list of De Bruijn indexed type variables and !Kind! is the type of kinds): 

\begin{agda}
data Type : Env -> Kind -> Set
data NormalType : Env -> Kind -> Set
data NeutralType : Env -> Kind -> Set 
\end{agda}

\subsection{Residualizing semantics}

We define our semantic domain in Agda recursively over the syntax of !Kind!s in \cref{fig:SemType}.

\begin{figure}
\begin{agda}
SemType : Env -> Kind -> Set
SemType Delta * = NormalType Delta *
SemType Delta L = NormalType Delta L 
SemType Delta_1 (kappa_1 -> kappa_2) = KripkeFunction Delta_1  kappa_1  kappa_2 
SemType Delta R[ kappa ] = 
  RowType Delta (\ Delta' -> SemType Delta' kappa) R[ kappa ]
\end{agda}
\caption{Semantic types}
\label{fig:SemType}
\end{figure}

Types at ground kind !*! and !L! are simply interpreted as !NormalType!s. We interpret arrow-kinded types as \emph{Kripke function spaces}, which permit the application of interpreted function $\phi$ at any environment !Delta_2! provided a renaming from !Delta_1! into !Delta_2!. % Note that we are defining !SemType! recursively (not inductively), and so the negative occurrence of !SemType! !Delta_2! !kappa_1! is not a problem.  

\begin{agda}
Renaming Delta_1  Delta_2 = TVar Delta_1 kappa -> TVar Delta_2 kappa
KripkeFunction : Env -> Kind -> Kind -> Set
KripkeFunction Delta_1  kappa_1  kappa_2 =  forall {Delta_2} -> 
  Renaming Delta_1  Delta_2 -> SemType Delta_2  kappa_1 -> SemType Delta_2  kappa_2
\end{agda}

The first three equations thus far are standard for this style of Agda mechanization, borrowing from \citet{ChapmanKNW19}. Novel to our development is the interpretation of row-kinded types. First, we define the interpretation of row literals as finitely indexed maps to label-type pairs. (Here the type !Label! is a synonym for !String!, but could be any type with decidable equality and a strict total-order.)

\begin{agda} 
Row : Set -> Set
Row A = exists[ n ](Fin n -> Label times A)
\end{agda}

\Ni Next, we define a !RowType! inductively as one of four cases: either a row literal constructed by !row!, a neutral-labeled row singleton constructed by !_:=_!, an inert map constructed by !_.map._!, or an inert row complement constructed by !_COMPL_! (\cref{fig:semantic-rows}).
\begin{figure}
\begin{agda}
data RowType (Delta : Env) 
             (T : Env -> Set) : Kind -> Set where 
  row      : (rho : Row (T Delta)) -> 
              OrderedRow rho -> 
              RowType Delta T R[ kappa ]
  _:=_     : NeutralType Delta L -> 
             T Delta -> 
             RowType Delta T R[ kappa ]
  _.map._  : (forall {Delta'} -> 
                Renaming Delta Delta' -> 
                NeutralType Delta' kappa_1 -> 
                T Delta') -> 
             NeutralType Delta R[ kappa_1 ] -> 
             RowType Delta T R[ kappa_2 ]
  _COMPL_  : (rho_2  rho_1 : RowType Delta T R[ kappa ]) -> 
             {nor : NotRow rho_2  or  notRow rho_1} -> 
             RowType Delta T R[ kappa ]
\end{agda}
\caption{Semantic row type}
\label{fig:semantic-rows}
\end{figure}

Care must be taken to explain some nuances of each constructor. First, the !row! and !_COMPL_! constructors are each constrained by predicates. The !OrderedRow rho! predicate asserts that !rho! has its string labels totally and ascendingly ordered---guaranteeing that labels in the row are unique and that rows are definitionally equal modulo ordering. The !NotRow rho! predicate asserts simply that !rho! was \emph{not} constructed by !row!. In other words, it is not a row literal. This is important, as the complement of two row literals should reduce to a !Row!, so we must disallow the formation of complements in which at least one of the operands is a literal. 

The next set of nuances come from dancing around Agda's positivity and termination checking. It would have been preferable for us to have written the !row! and !_.map._! constructors as follows: 
\begin{agda}
  row      : (rho : Row (SemType Delta kappa)) -> 
             OrderedRow rho -> 
             RowType Delta T R[ kappa ]
  _.map._  : (forall {Delta'} -> 
                Renaming Delta Delta' -> 
                SemType Delta' kappa_1 -> 
                SemType Delta' kappa_2) -> 
             NeutralType Delta R[ kappa_1 ] -> 
             RowType Delta T R[ kappa_2 ]
\end{agda}

\Ni Such a definition would have necessarily made the types !RowType! and !SemType! mutually inductive-recursive. But this would run afoul of Agda's termination and positivity checkers for the following reasons:
\begin{enumerate}
  \item in the constructor !row!, the input !Row! !(SemType! !Delta! !kappa)! makes a recursive call to !SemType Delta kappa!, where it's not clear (to Agda) that this is a strictly smaller recursive call. To get around this, we parameterize the !RowType! type by !T : Env -> Set! so that we may enforce this recursive call to be structurally smaller---hence the definition of !SemType! at kind !R[ kappa ]! passes the argument !(\ Delta' ->! !SemType Delta' kappa)!, which varies in environment but is at a strictly smaller kind.
  \item  The !_.map._! constructor takes a !KripkeFunction! as input, in which !SemType! !Delta' kappa_1! occurs negatively, which Agda must outright reject. Here we borrow some clever machinery from \citet{AllaisBM13} and instead make the !KripkeFunction! accept the input !NeutralType Delta' kappa_1!, which is already defined. The trick is that, as we will show in the next section, every !NeutralType! may be promoted to a !SemType!. In practice this is sufficient for our needs.
\end{enumerate}

\subsection{Reflection \& reification}

We have now declared three domains: the syntax of types, the syntax of normal and neutral types, and the embedded domain of semantic types. Normalization by evaluation involves producing a \emph{reflection} from neutral types to semantic types, a \emph{reification} from semantic types to normal types, and an \emph{evaluation} from types to semantic types. It follows thereafter that normalization is the reification of evaluation. Because we reason about types modulo $\eta$-expansion, reflection and reification are necessarily mutually recursive. (This is not the case however with e.g. \citet{ChapmanKNW19}.)

Reflection is defined in \cref{fig:reflection}. Types at kind !*! and !L! can be promoted straightforwardly with the !ne! constructor. Neutral types at arrow kind must be expanded into Kripke functions. Note that the input \verb!v! has type \verb!SemType Î” Îºâ‚! and must be reified; additionally, !tau! is kinded in environment !Delta_1! and so must be renamed to !Delta_2!, the environment of !v!. The syntax $\cdot$ is used to construct an application of a !neutralType! to a !normalType!. Finally, a neutral row (e.g., a row variable) must be expanded into an inert mapping by !(\ r n -> reflect n)!, which is effectively the identity function. 
\begin{figure}
\begin{agda}
reflect : NeutralType Delta kappa -> SemType Delta kappa 
reify : SemType Delta kappa -> NormalType Delta kappa

reflect {kappa = *} tau = ne tau
reflect {kappa = L} tau = ne tau
reflect {kappa = kappa_1 -> kappa_2} = 
  \ r v -> reflect ((rename r tau) cdot reify v)
reflect {kappa = R[ kappa ]} rho = (\ r n -> reflect n) .map. rho
\end{agda}
\caption{reflection}
\label{fig:reflection}
\end{figure}

The definition of reification is a little more involved (\cref{fig:reification}). The first two equations are expected (!tau! is already in normal form). Functions are reified effectively by $\eta$\--expan\-sion; note that we are using intrinsically-scoped De Bruijn variables, so !Z! constructs the zero'th variable and !S! induces a renaming in which each variable is incremented by one. (Recall that !phi! is a Kripke function space and so expects a renaming as argument.) The constructor !`! promotes a type variable to a !neutralType!. 

The equation of interest is in reifying rows. We pun the !row! constructor to construct row literals at type !NormalType!, which likewise expects a proof that the row is well-ordered. Such a proof is given by the auxiliary lemma !reify!\-!Preserves!\-!Ordering!, which proves what it says. Next, we use a helper function !reifyRow! to recursively build a list of !Label!\--!Normal!\-!Type! pairs (that is, the form of !NormalType! row literals) from a semantic row. The empty case is trivial; the successor case must inspect the head of the list by destructing !P! !fzero!, i.e., the label\--type association of the zero'th finite index. From there we yield a semantic type !tau! which we reify and append to the result of recursing.
\begin{figure}
\begin{agda}
reify {kappa = *} tau = tau
reify {kappa = L} tau = tau
reify {kappa = kappa_1 -> kappa_2} phi = `\ (reify (phi S (` Z)))
reify {kappa = R[ kappa ]} (row rho q) = 
  row (reifyRow rho) (reifyPreservesOrdering q)
  where
    reifyRow : Row (SemType Delta kappa) -> 
               List (Label times NormalType Delta kappa)
    reifyRow (0 , P) = [] 
    reifyRow (suc n , P) with P fzero 
    ... | (l , tau) = 
      (l , reify tau) :: reifyRow (n , P . fsuc)
\end{agda}
\caption{reification}
\label{fig:reification}
\end{figure}

Finally, we have asserted that types are reduced modulo $\beta$-reduction and $\eta$-expansion. It follows that a given !NeutralType! should, after reflection and reification, end up in an expanded form. This is precisely how we define the promotion of !NeutralType!s to !NormalType!s: 

\begin{agda}
eta-norm : NeutralType Delta kappa -> NormalType Delta kappa
eta-norm = reify . reflect
\end{agda}

This function is necessary: the !NormalType! constructor !ne! stipulates that we may only promote neutral derivations to normal derivations at \emph{ground kind} (rule \kruleNF{ne}). Hence !eta!!-norm! is the only means by which we may promote neutral types at row or arrow kind.

\subsection{Helping evaluation}
We will build our evaluation function incrementally; we find it clearer to incrementally build helpers for sub-computation (e.g., mapping or the complement) on our way up to full evaluation. We describe these helpers next.

\subsubsection{Semantic application.}

We define semantic application straightforwardly as Agda application under the identity renaming.

\begin{agda}
_cdot'_ : SemType Delta (kappa_1 -> kappa_2) -> 
          SemType Delta kappa_1 -> 
          SemType Delta kappa_2
phi cdot' v = phi id v
\end{agda}
% \caption{semantic application}
% \label{fig:semantic-application}
% \end{figure}

\subsubsection{Semantic mapping}
Mapping over rows is a form of computation novel to \Rome's equivalence relation. We define the mapping !phi .map. rho! over the four cases a semantic row may take (\cref{fig:semantic-mapping}). When !rho! is neutral-labeled, we simply apply !phi! to its contents. The case where !rho! is a row literal is interesting in that our choice of representation for row literals as Agda functions comes to pay off: we may express the mapping of !phi! across the row !(n , P)! by pre-composing !P! with !phi! (note that we must appropriately fmap !phi! over the pair's second component). The mapping of !phi! over a complement is distributive, following rule \errule{map$_{\setminus}$}. Likewise, we follow rule \errule{map$_\circ$} in grouping the nested map !phi! !.map.! !(phi_2 .map. n)! into a composed map. 

\begin{figure}
\begin{agda}
_.map.'_ : SemType Delta (kappa_1 -> kappa_2) -> 
           SemType Delta R[ kappa_1 ] -> 
           SemType Delta R[ kappa_2 ]
phi .map.' (l := tau) = l := (phi cdot' tau)
phi .map.' (row (n , P) q) = row (n , fmap (phi id) . P)
phi .map.' (rho_2 - rho_1) = (phi .map. rho_2) - (phi .map. rho_1)
phi_1 .map.' (phi_2 .map. n) = (\ r -> phi_1 r . phi_2 r) .map. n
\end{agda}
\caption{semantic mapping}
\label{fig:semantic-mapping}
\end{figure}

\subsubsection{Semantic complement} The complement of two row-kinded semantic types is always inert when one (or both) are not row literals, and thus constructed simply by the !_COMPL_! constructor. The interesting case is when we must reduce two row literals to another row literal (\cref{fig:semantic-complement}). Here our implementation differs slightly to the syntactic presentation present in \cref{fig:equivalence}. We proceed by induction on the length of the left-hand row: The resulting row is the empty row !0 , \ ()! when the left-hand row is empty. (That is to say, an empty row minus any other row is empty.) Otherwise, we check if the current label !P fzero .fst! is in the right-hand row. If so, we omit it and proceed with recursion. If not, we retain it. 

\begin{figure}
\begin{agda}
_In?_ : Label -> Row (SemType Delta kappa) -> Bool

_COMPL'_ : Row (SemType Delta kappa) -> Row (SemType Delta kappa) -> 
           Row (SemType Delta kappa)
(zero , P) COMPL' (m , Q) = 0 , \ () 
(suc n , P) COMPL' (m , Q) with P fzero .fst In? Q 
... | true = (P . fsuc) COMPL' Q
... | false = suc n , \ { fzero -> P fzero , 
                          fsuc _ -> (P . fsuc) COMPL' Q }
\end{agda}
\caption{Semantic complement}
\label{fig:semantic-complement}
\end{figure}

\subsubsection{Semantic flap}
The rule \errule{lift$_\Xi$} describes how $\Pi$ and $\Sigma$ reassociate from e.g. !(Pi rho) a! to !Pi (rho ?? a)!. We define a semantic version of the flap (flipped map) operator as follows:

\begin{agda}
_??'_ : SemType Delta R[ kappa_1 -> kappa_2 ] -> 
       SemType Delta kappa_1 -> SemType Delta R[ kappa_2 ]
phi ??' a = (\ r f -> f cdot' (rename r a)) .map.' phi
\end{agda}

\subsubsection{Semantic $\Pi$ and $\Sigma$} The defining equations for the reduction of $\Pi$ is given in \cref{fig:semantic-pi}. (The logic for $\Sigma$ is identical and omitted.)

\begin{figure}
\begin{agda}
Pi' : SemType Delta R[ kappa ] -> SemType Delta kappa
Pi' {kappa = *} x = Pi (reify x)
Pi' {kappa = kappa_1 -> kappa_1} phi = \ r v -> Pi' (rename r phi ??' v)
Pi' {kappa = R[ kappa ]} x = (\ r v -> Pi' v) .map.' x
\end{agda}
\caption{Semantic $\Pi$}
\label{fig:semantic-pi}
\end{figure}
 
The input row to !Pi'! has kind !R[ kappa ]!; we proceed by destructing !kappa!. Recall that we may only construct record types in normal form at kind !*!, and so for the case that !kappa = *! we simply reify the input and construct the record via the !NormalType! constructor !Pi!. We exclude the case that !kappa = L! because it is impossible: in the !Type! syntax, we restrict the formation of the !Pi! constructor by the following predicate:

\begin{agda}
NotLabel : Kind -> Set
NotLabel * = Top
NotLabel L = Bot
NotLabel (kappa_1 -> kappa_2) = NotLabel kappa_2
NotLabel R[ kappa ] = NotLabel kappa
\end{agda}

This is to say, one may not apply !Pi! to an input that is a row of labels, a label-valued function, or a nested row of labels. Next, when applying !Pi'! to a function, we must expand the semantic $\lambda$-binding outwards. Thereafter, we apply rule \errule{lift$_\Xi$} to explain how !Pi'! operates on a single operand. Finally, we implement rule \errule{$\Xi$} directly in the last equation: the application of !Pi'! to a row-kinded input !x! is simply the mapping of !Pi'!  over !x!.

\subsection{Evaluation}
Evaluation warrants an environment that maps type variables to semantic types. The identity environment, which fixes the meaning of variables, is given as the composition of reflection and !`!, the constructor of !NeutralType!s from !TVar!s. 


\begin{agda}
SemEnv : Env -> Env -> Set
SemEnv Delta_1  Delta_2 = TVar Delta_1 -> SemType Delta_2 kappa 
idEnv : SemEnv Delta Delta
idEnv = reflect . `
\end{agda}

\subsection{Normalization}

Normalization in the NbE approach is simply the composition of reification after evaluation. 

\begin{agda} 
Down : Type Delta kappa -> NormalType Delta kappa
Down tau = reify (eval tau idEnv)
\end{agda}


It will be helpful in the coming metatheory to define an inverse embedding by induction over the !NormalType! structure. The definition is entirely expected and omitted. 

\begin{agda}
Up : NormalType Delta kappa -> Type Delta kappa
\end{agda}

\section{Mechanized metatheory}

This section gives a deeper exposition on the metatheory summarized in \cref{sec:metatheory-summary}. We forego syntactic tyding of claims and give a deeper explanation of the proof techniques involved.

\subsection{Stability}

Stability follows by simple induction on the input derivation $\KindJNF \Delta \tau \kappa$. Here it is clearer that we are stating !Down! is left-inverse to !Up!.

\begin{agda}
stability : forall (tau : NormalType Delta kappa) -> Down (Up tau) .=. tau
\end{agda}
Stability implies idempotency:
\begin{agda}
idempotency : forall (tau : Type Delta kappa) -> 
              (Up . Down . Up . Down) tau .=. (Up . Down) tau
idempotency tau rewrite (Down tau) = refl
\end{agda}
\Ni and surjectivity: 

\begin{agda}
surjectivity : forall (tau : NormalType Delta kappa) -> 
               exists[ upsilon ] (Down upsilon .=. tau)
surjectivity tau = ( Up tau , stability tau )
\end{agda}

Dual to surjectivity, stability also implies that embedding is injective.

\begin{agda}
Up-inj : forall (tau_1  tau_2 : NormalType Delta kappa) -> 
         Up tau_1 .=. Up tau_2 -> tau_1 .=. tau_2
Up-inj  tau_1  tau_2  eq = 
  trans 
    (sym (stability tau_1))          
    (trans 
      (cong Down eq)
      (stability tau_2))
\end{agda}

\subsection{A logical relation for completeness}

\subsubsection{Properties}

\subsubsection{Logical environments}

\subsubsection{The fundamental theorem and completeness}

\subsection{A logical relation for soundness}

\subsubsection{Properties}

\subsubsection{Logical environments}

\subsubsection{The fundamental theorem and Soundness}

\section{Most closely related work}

\bibliographystyle{plainnat}
\bibliography{NBE}
\end{document}
%%% Local Variables: 
%%% TeX-command-extra-options: "-shell-escape"
%%% End:
%  LocalWords:  denotational Agda Wadler dPoint sqrt subtyping coercions Intr
%  LocalWords:  RowTypes Bool eval GHC reified HillerstromL Leijen LindleyM RO
%  LocalWords:  ChapmanKNW Aydemir AbelAHPMSS AbelC AbelOV plfa HubersIMM STLC
%  LocalWords:  MorrisM denotationally DenotationalSoundness RowTheories Suc de
%  LocalWords:  ReifyingVariants RowTheory BerthomieuM CardelliMMS HarperP NatF
%  LocalWords:  XueOX GasterJ Sipser SaffrichTM Env Expr Agda's Leivant ChanW
%  LocalWords:  ThiemannW ImpredicativeSet ImpredicativeSetSucks AbelP chapman
%  LocalWords:  AltenkirchK KaposiKK Gaster XieOBS BiXOS Chlipala objTypes Bahr
%  LocalWords:  Garrigue KEnv PEnv
