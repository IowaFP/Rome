\documentclass[authoryear, acmsmall, screen, review, nonacm]{acmart} % % use acmtog for two-column
\overfullrule=1mm
% \usepackage[margin=1.5in]{geometry}

\include{header.tex} 
\usepackage{agda}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% ACM garbage
\setcopyright{none}
\citestyle{acmauthoryear}
\settopmatter{printacmref=false, printfolios=true}
\renewcommand{\footnotetextcopyrightpermission}{} 
% Redefine the \acmDOI command to do nothing 
\pagestyle{empty}
\fancyfoot{}

%\usepackage[utf8]{inputenc}
% \numberwithin{equation}{section}
% \numberwithin{theorem}{section}

\title{Normalization By Evaluation of Types in \Rome}
\author{Alex Hubers}
\orcid{0000-0002-6237-3326}
\affiliation{
  \department{Department of Computer Science}
  \institution{The University of Iowa}
  \streetaddress{14 MacLean Hall}
  \city{Iowa City}
  \state{Iowa}
  \country{USA}}
\email{alexander-hubers@uiowa.edu}

\usepackage{newunicodechar}
\newunicodechar{‚àã}{$\ni$}
\newunicodechar{Œµ}{$\epsilon$}
\newunicodechar{¬∑}{$\cdot$}
\newunicodechar{‚ä¢}{$\vdash$}
\newunicodechar{‚ãÜ}{${}^\star$}
\newunicodechar{Œ†}{$\Pi$}
\newunicodechar{‚áí}{$\Rightarrow$}
\newunicodechar{∆õ}{$\lambdabar$}
\newunicodechar{‚àÖ}{$\emptyset$}
\newunicodechar{‚àÄ}{$\forall$}
\newunicodechar{œï}{$\Phi$}
\newunicodechar{œÜ}{$\phi$}
\newunicodechar{œà}{$\Psi$}
\newunicodechar{œÅ}{$\rho$}
\newunicodechar{Œ±}{$\alpha$}
\newunicodechar{Œ≤}{$\beta$}
\newunicodechar{Œº}{$\mu$}
\newunicodechar{œÉ}{$\sigma$}
\newunicodechar{‚â°}{$\equiv$}
\newunicodechar{Œì}{$\Gamma$}
\newunicodechar{‚à•}{$\parallel$}
\newunicodechar{Œõ}{$\Lambda$}
\newunicodechar{‚ÇÇ}{$_2$}
\newunicodechar{Œ∏}{$\theta$}
\newunicodechar{Œò}{$\Theta$}
\newunicodechar{‚àò}{$\circ$}
\newunicodechar{Œî}{$\Delta$}
\newunicodechar{‚òÖ}{$\star$}
\newunicodechar{Œª}{$\lambda$}
\newunicodechar{‚äß}{$\models$}
\newunicodechar{‚äé}{$\uplus$}
\newunicodechar{Œ∑}{$\eta$}
\newunicodechar{‚ä•}{$\bot$}
\newunicodechar{Œ£}{$\Sigma$}
\newunicodechar{Œæ}{$\xi$}
\newunicodechar{‚ÇÅ}{$_1$}
\newunicodechar{‚Çñ}{$_k$}
\newunicodechar{‚ÇÉ}{$_3$}
\newunicodechar{‚Ñï}{$\mathbb{N}$}
\newunicodechar{·∂ú}{${}^c$}
\newunicodechar{Œ¶}{$\Phi$}
\newunicodechar{Œ®}{$\Psi$}
\newunicodechar{‚ä§}{$\top$}
\newunicodechar{Œ∫}{$\kappa$}
\newunicodechar{œÑ}{$\tau$}
\newunicodechar{œÄ}{$\pi$}
\newunicodechar{‚åä}{$\lfloor$}
\newunicodechar{‚åã}{$\rfloor$}
\newunicodechar{‚â≤}{$\lesssim$}
\newunicodechar{‚ñπ}{$\triangleright$}
\newunicodechar{‚Ñì}{$\ell$}
\newunicodechar{œÖ}{$\upsilon$}

\newunicodechar{‚Üí}{$\rightarrow$}
\newunicodechar{√ó}{$\times$}
\newunicodechar{œâ}{$\omega$}
\newunicodechar{‚àÉ}{$\exists$}
\newunicodechar{‚àà}{$\in$}
\newunicodechar{‚áë}{$\Uparrow$}
\newunicodechar{‚áì}{$\Downarrow$}
\newunicodechar{‚âã}{$\approx$}
\newunicodechar{‚Çó}{$_l$}
\newunicodechar{·µ£}{$_r$}
\newunicodechar{‚ü¶}{$\llbracket$}
\newunicodechar{‚üß}{$\rrbracket$}
\newunicodechar{‚Åª}{$^{-}$}
\newunicodechar{¬π}{$^{1}$}
\newunicodechar{‚ÇÑ}{$_{4}$}
\newunicodechar{‚¶Ö}{$\llparenthesis$}
\newunicodechar{‚¶Ü}{$\rrparenthesis$}
\newunicodechar{‚îÄ}{$\setminus$}
\newunicodechar{‚à∑}{$\co\co$}
\newunicodechar{‚Çñ}{$_{k}$}
\newunicodechar{‚Çô}{$_{n}$}
\newunicodechar{‚âü}{$\overset{?}{=}$}
\newunicodechar{ùíØ}{$\mathcal T$}
\newunicodechar{‚®æ}{$\co$}
\newunicodechar{Œû}{$\Xi$}
\newunicodechar{Œæ}{$\xi$}

\begin{document}

\maketitle

\section*{Abstract}
We describe the normalization-by-evaluation (NbE) of types in \Rome, a row calculus with recursive types, qualified types, and a novel \emph{row complement} operator. Types are normalized to $\beta\eta$-long forms modulo a type equivalence relation. Because the type system of \Rome is a strict extension of System \Fome, much of the type reduction is isomorphic to reduction of terms in the STLC. Novel to this report are the reductions of row, record, and variant types.

\section{The \Rome{} calculus}

For reference, \cref{fig:syntax-types} describes the syntax of kinds, predicates, and types in \Rome. We forego further description to the next section.

\begin{figure}[H]
\begin{gather*}
\begin{array}{r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l}
\text{Type variables} & \alpha \in \mathcal A & \text{Labels} & \ell \in \mathcal L
\end{array}
\\[5px]
\begin{doublesyntaxarray}
  \mcl{\text{Kinds}} & \kappa & ::= & \TypeK \mid \LabK \mid \RowK \kappa \mid \kappa \to \kappa \\
  \mcl{\text{Predicates}} & \pi, \psi & ::= & \LeqP \rho \rho \mid \PlusP \rho \rho \rho \\
  \text{Types} & \mcr{\Types \ni \phi, \tau, \upsilon, \rho, \xi} & ::= & \alpha \mid \pi \then \tau \mid \forall \alpha\co\kappa. \tau \mid \lambda \alpha\co\kappa. \tau \mid \tau \, \tau \\
               &                              &     & \mid    & \RowIx i 0 m {\LabTy {\xi_i} {\tau_i}} \mid \ell \mid \Sing{\tau} \mid \Mapp{\phi}{\rho} \mid \rho \Compl \rho \\ 
               &                              &     & \mid & \tau \to \tau \mid \Pi \mid \Sigma \mid \mu \, \phi 
\end{doublesyntaxarray}
\end{gather*}
\caption{Syntax}
\label{fig:syntax-types}
\end{figure}

\subsection{Example types and the need for reduction}
% Add motivation for where this incurs type normalization. Show "hidden" maps and hidden reductions. How does $(\Pi\, (\ell \triangleright f)) \, \tau$ reduce?
We will write Rome types in programs in the slightly-altered syntax of \emph{Rosi}, our experimental implementation of \Rome. 
Wand's problem:

\begin{rosi}
wand : forall l x y z t. x + y ~ z, {l := t} < z => #l -> Pi x -> Pi y -> t
\end{rosi}

Here we can simulate the deriving of functor typeclass instances: given a record of \verb!fmap! instances, I can give you a \verb!Functor! instance for $\Sigma\, z$.

\begin{rosi}
type Functor : (* -> *) -> *
type Functor = \f. forall a b. (a -> b) -> f a -> f b

fmapS : forall z : R[* -> *]. Pi (Functor z) -> Functor (Sigma z)
\end{rosi}

Let's first elaborate this type by rendering an implicit map explicit.

\begin{rosi}
fmapS : forall z : R[* -> *]. Pi (Functor z) -> Functor (Sigma z)
\end{rosi}

\Ni And a desugaring of booleans to Church encodings:

\begin{rosi}
desugar : forall y. BoolF < y, LamF < y - BoolF =>
          Pi (Functor (y - BoolF)) -> Mu (Sigma y) -> Mu (Sigma (y - BoolF))
\end{rosi}

\section{Type Reduction}
\subsection{Normal forms}

By directing the type equivalence relation we define computation on types. This serves as a sort of specification on the shape normal forms of types ought to have. Our grammar for normal types must be carefully crafted so as to be neither too "large" nor too "small". In particular, we wish our normalization algorithm to be \emph{stable}, which implies surjectivity. Hence if the normal syntax is too large---i.e., it produces junk types---then these junk types will have pre-images in the domain of normalization. Inversely, if the normal syntax is too small, then there will be types whose normal forms cannot be expressed. \Cref{fig:type-normalization} specifies the syntax and typing of normal types, given as reference. We describe the syntax in more depth by describing its intrinsic mechanization.

\begin{figure}[H]
\begin{gather*}
\begin{array}{r@{\hspace{7px}}l@{\qquad\qquad}r@{\hspace{7px}}l}
  \text{Type variables} & \alpha \in \mathcal A &
  \text{Labels} & \ell \in \mathcal L
\end{array} \\
\begin{doublesyntaxarray}
  \mcl{\text{Ground Kinds}}  & \gamma   & ::= & \TypeK \mid \LabK \\
  \mcl{\text{Kinds}}         & \kappa    & ::= & \gamma \mid \kappa \to \kappa \mid  \RowK \kappa \\
  \mcl{\text{Row Literals}}   & \NormalRows \ni \Normal \rho    & ::= & \RowIx i 0 m {\LabTy {\ell_i} {\Normal {\tau_i}}} \\
  \mcl{\text{Neutral Types}} & n    & ::= & \alpha \mid n \, {\Normal \tau}  \\
  \mcl{\text{Normal Types}}  & \NormalTypes \ni \Normal \tau, \Normal \phi & ::= & n \mid \Mapp {\hat{\phi}} {n} \mid \Normal{\rho} \mid \Normal{\pi} \then \Normal{\tau} \mid \forall \alpha\co\kappa. \Normal{\tau} \mid \lambda \alpha\co\kappa. \Normal{\tau} \\
                             &       &     & \mid & \LabTy n {\Normal \tau} \mid \ell \mid \Sing {\Normal \tau} \mid {\Normal \tau} \Compl {\Normal \tau} \mid \Pi \, {\Normal \tau} \mid \Sigma \, {\Normal \tau}  \\
\end{doublesyntaxarray}
\end{gather*}
\caption{Normal type forms}
\label{fig:type-normalization}
\end{figure}

\subsection{Metatheory}
\subsubsection{Canonicity of normal types}

The syntax of normal types is defined precisely so as to enjoy canonical forms
based on kind.
\subsubsection{Completeness of normalization}
\subsubsection{Soundness of normalization}
\subsubsection{Decidability of type conversion}

\section{Normalization by Evaluation (NbE)}
\begin{code}[hide]
postulate
  bot : ‚àÄ (X : Set) ‚Üí X
open import Rome.Kinds.Syntax
open import Rome.Kinds.GVars
open import Rome.Types.Syntax
open import Rome.Types.Normal.Syntax
open import Rome.Types.Semantic.Syntax
open import Rome.Prelude
\end{code}

\subsection{The semantic domain}

\subsection{Reflection \& reification}

\subsection{Evaluation}

\subsection{Normalization}
\begin{code}
-- ‚áì : ‚àÄ {Œî} ‚Üí Type Œî Œ∫ ‚Üí NormalType Œî Œ∫
-- ‚áì œÑ = reify (eval œÑ idEnv)
\end{code}

\section{Mechanizing Metatheory}

\subsection{Stability}

\begin{code}
-- stability   : ‚àÄ (œÑ : NormalType Œî Œ∫) ‚Üí ‚áì (‚áë œÑ) ‚â° œÑ
-- stabilityNE : ‚àÄ (œÑ : NeutralType Œî Œ∫) ‚Üí eval (‚áëNE œÑ) (idEnv {Œî}) ‚â° reflect œÑ
-- stabilityPred : ‚àÄ (œÄ : NormalPred Œî R[ Œ∫ ]) ‚Üí evalPred (‚áëPred œÄ) idEnv ‚â° œÄ
-- stabilityRow : ‚àÄ (œÅ : SimpleRow NormalType Œî R[ Œ∫ ]) ‚Üí reifyRow (evalRow (‚áëRow œÅ) idEnv) ‚â° œÅ
\end{code}
\begin{code}[hide]
-- stability     = bot _
-- stabilityNE   = bot _
-- stabilityPred = bot _
-- stabilityRow = bot _
\end{code}

Stability implies surjectivity and idempotency.

\begin{code}
-- idempotency : ‚àÄ (œÑ : Type Œî Œ∫) ‚Üí (‚áë ‚àò ‚áì ‚àò ‚áë ‚àò ‚áì) œÑ ‚â°  (‚áë ‚àò ‚áì)  œÑ
-- idempotency œÑ rewrite stability (‚áì œÑ) = refl

-- surjectivity : ‚àÄ (œÑ : NormalType Œî Œ∫) ‚Üí ‚àÉ[ œÖ ] (‚áì œÖ ‚â° œÑ)
-- surjectivity œÑ = ( ‚áë œÑ , stability œÑ ) 
\end{code}

Dual to surjectivity, stability also implies that embedding is injective.
 
\begin{code}
-- ‚áë-inj : ‚àÄ (œÑ‚ÇÅ œÑ‚ÇÇ : NormalType Œî Œ∫) ‚Üí ‚áë œÑ‚ÇÅ ‚â° ‚áë œÑ‚ÇÇ ‚Üí œÑ‚ÇÅ ‚â° œÑ‚ÇÇ                   
-- ‚áë-inj œÑ‚ÇÅ œÑ‚ÇÇ eq = trans (sym (stability œÑ‚ÇÅ)) (trans (cong ‚áì eq) (stability œÑ‚ÇÇ))
\end{code}

\subsection{A logical relation for completeness}

\begin{code}
-- subst-Row : ‚àÄ {A : Set} {n m : ‚Ñï} ‚Üí (n ‚â° m) ‚Üí (f : Fin n ‚Üí A) ‚Üí Fin m ‚Üí A 
-- subst-Row refl f = f

-- -- Completeness relation on semantic types
-- _‚âã_ : SemType Œî Œ∫ ‚Üí SemType Œî Œ∫ ‚Üí Set
-- _‚âã‚ÇÇ_ : ‚àÄ {A} ‚Üí (x y : A √ó SemType Œî Œ∫) ‚Üí Set
-- (l‚ÇÅ , œÑ‚ÇÅ) ‚âã‚ÇÇ (l‚ÇÇ , œÑ‚ÇÇ) = l‚ÇÅ ‚â° l‚ÇÇ √ó œÑ‚ÇÅ ‚âã œÑ‚ÇÇ
-- _‚âãR_ : (œÅ‚ÇÅ œÅ‚ÇÇ : Row (SemType Œî Œ∫)) ‚Üí Set 
-- (n , P) ‚âãR (m , Q) = Œ£[ pf ‚àà (n ‚â° m) ] (‚àÄ (i : Fin m) ‚Üí  (subst-Row pf P) i ‚âã‚ÇÇ Q i)

-- PointEqual-‚âã : ‚àÄ {Œî‚ÇÅ} {Œ∫‚ÇÅ} {Œ∫‚ÇÇ} (F G : KripkeFunction Œî‚ÇÅ Œ∫‚ÇÅ Œ∫‚ÇÇ) ‚Üí Set
-- PointEqualNE-‚âã : ‚àÄ {Œî‚ÇÅ} {Œ∫‚ÇÅ} {Œ∫‚ÇÇ} (F G : KripkeFunctionNE Œî‚ÇÅ Œ∫‚ÇÅ Œ∫‚ÇÇ) ‚Üí Set
-- Uniform :  ‚àÄ {Œî} {Œ∫‚ÇÅ} {Œ∫‚ÇÇ} ‚Üí KripkeFunction Œî Œ∫‚ÇÅ Œ∫‚ÇÇ ‚Üí Set
-- UniformNE :  ‚àÄ {Œî} {Œ∫‚ÇÅ} {Œ∫‚ÇÇ} ‚Üí KripkeFunctionNE Œî Œ∫‚ÇÅ Œ∫‚ÇÇ ‚Üí Set

-- _‚âã_ {Œ∫ = ‚òÖ} œÑ‚ÇÅ œÑ‚ÇÇ = œÑ‚ÇÅ ‚â° œÑ‚ÇÇ
-- _‚âã_ {Œ∫ = L} œÑ‚ÇÅ œÑ‚ÇÇ = œÑ‚ÇÅ ‚â° œÑ‚ÇÇ
-- _‚âã_ {Œî‚ÇÅ} {Œ∫ = Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ} F G = 
--   Uniform F √ó Uniform G √ó PointEqual-‚âã {Œî‚ÇÅ} F G 
-- _‚âã_ {Œî‚ÇÅ} {R[ Œ∫‚ÇÇ ]} (_<$>_ {Œ∫‚ÇÅ} œÜ‚ÇÅ n‚ÇÅ) (_<$>_ {Œ∫‚ÇÅ'} œÜ‚ÇÇ n‚ÇÇ) = 
--   Œ£[ pf ‚àà (Œ∫‚ÇÅ ‚â° Œ∫‚ÇÅ') ]  
--     UniformNE œÜ‚ÇÅ
--   √ó UniformNE œÜ‚ÇÇ
--   √ó (PointEqualNE-‚âã (convKripkeNE‚ÇÅ pf œÜ‚ÇÅ) œÜ‚ÇÇ
--   √ó convNE pf n‚ÇÅ ‚â° n‚ÇÇ)
-- _‚âã_ {Œî‚ÇÅ} {R[ Œ∫‚ÇÇ ]} (œÜ‚ÇÅ <$> n‚ÇÅ) _ = ‚ä•
-- _‚âã_ {Œî‚ÇÅ} {R[ Œ∫‚ÇÇ ]} _ (œÜ‚ÇÅ <$> n‚ÇÅ) = ‚ä•
-- _‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (l‚ÇÅ ‚ñπ œÑ‚ÇÅ) (l‚ÇÇ ‚ñπ œÑ‚ÇÇ) = l‚ÇÅ ‚â° l‚ÇÇ √ó œÑ‚ÇÅ ‚âã œÑ‚ÇÇ
-- _‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (x‚ÇÅ ‚ñπ x‚ÇÇ) (row œÅ x‚ÇÉ) = ‚ä•
-- _‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (x‚ÇÅ ‚ñπ x‚ÇÇ) (œÅ‚ÇÇ ‚îÄ œÅ‚ÇÉ) = ‚ä•
-- _‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (row œÅ x‚ÇÅ) (x‚ÇÇ ‚ñπ x‚ÇÉ) = ‚ä•
-- _‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (row (n , P) x‚ÇÅ) (row (m , Q) x‚ÇÇ) = (n , P) ‚âãR (m , Q)
-- _‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (row œÅ x‚ÇÅ) (œÅ‚ÇÇ ‚îÄ œÅ‚ÇÉ) = ‚ä•
-- _‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (œÅ‚ÇÅ ‚îÄ œÅ‚ÇÇ) (x‚ÇÅ ‚ñπ x‚ÇÇ) = ‚ä•
-- _‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (œÅ‚ÇÅ ‚îÄ œÅ‚ÇÇ) (row œÅ x‚ÇÅ) = ‚ä•
-- _‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (œÅ‚ÇÅ ‚îÄ œÅ‚ÇÇ) (œÅ‚ÇÉ ‚îÄ œÅ‚ÇÑ) = œÅ‚ÇÅ ‚âã œÅ‚ÇÉ √ó œÅ‚ÇÇ ‚âã œÅ‚ÇÑ

-- PointEqual-‚âã {Œî‚ÇÅ} {Œ∫‚ÇÅ} {Œ∫‚ÇÇ} F G = 
--   ‚àÄ {Œî‚ÇÇ} (œÅ : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) {V‚ÇÅ V‚ÇÇ : SemType Œî‚ÇÇ Œ∫‚ÇÅ} ‚Üí 
--   V‚ÇÅ ‚âã V‚ÇÇ ‚Üí F œÅ V‚ÇÅ ‚âã G œÅ V‚ÇÇ

-- PointEqualNE-‚âã {Œî‚ÇÅ} {Œ∫‚ÇÅ} {Œ∫‚ÇÇ} F G = 
--   ‚àÄ {Œî‚ÇÇ} (œÅ : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) (V : NeutralType Œî‚ÇÇ Œ∫‚ÇÅ) ‚Üí 
--   F œÅ V ‚âã G œÅ V

-- Uniform {Œî‚ÇÅ} {Œ∫‚ÇÅ} {Œ∫‚ÇÇ} F = 
--   ‚àÄ {Œî‚ÇÇ Œî‚ÇÉ} (œÅ‚ÇÅ : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) (œÅ‚ÇÇ : Renaming‚Çñ Œî‚ÇÇ Œî‚ÇÉ) (V‚ÇÅ V‚ÇÇ : SemType Œî‚ÇÇ Œ∫‚ÇÅ) ‚Üí
--   V‚ÇÅ ‚âã V‚ÇÇ ‚Üí (renSem œÅ‚ÇÇ (F œÅ‚ÇÅ V‚ÇÅ)) ‚âã (renKripke œÅ‚ÇÅ F œÅ‚ÇÇ (renSem œÅ‚ÇÇ V‚ÇÇ))

-- UniformNE {Œî‚ÇÅ} {Œ∫‚ÇÅ} {Œ∫‚ÇÇ} F = 
--   ‚àÄ {Œî‚ÇÇ Œî‚ÇÉ} (œÅ‚ÇÅ : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) (œÅ‚ÇÇ : Renaming‚Çñ Œî‚ÇÇ Œî‚ÇÉ) (V : NeutralType Œî‚ÇÇ Œ∫‚ÇÅ) ‚Üí
--   (renSem œÅ‚ÇÇ (F œÅ‚ÇÅ V)) ‚âã F (œÅ‚ÇÇ ‚àò œÅ‚ÇÅ) (ren‚ÇñNE œÅ‚ÇÇ V)

-- Env-‚âã : (Œ∑‚ÇÅ Œ∑‚ÇÇ : Env Œî‚ÇÅ Œî‚ÇÇ) ‚Üí Set
-- Env-‚âã Œ∑‚ÇÅ Œ∑‚ÇÇ = ‚àÄ {Œ∫} (x : TVar _ Œ∫) ‚Üí (Œ∑‚ÇÅ x) ‚âã (Œ∑‚ÇÇ x)
\end{code}

\subsubsection{Properties}~

\begin{code}
-- reflect-‚âã  : ‚àÄ {œÑ‚ÇÅ œÑ‚ÇÇ : NeutralType Œî Œ∫} ‚Üí œÑ‚ÇÅ ‚â° œÑ‚ÇÇ ‚Üí reflect œÑ‚ÇÅ ‚âã reflect œÑ‚ÇÇ
-- reify-‚âã    : ‚àÄ {V‚ÇÅ V‚ÇÇ : SemType Œî Œ∫}     ‚Üí V‚ÇÅ ‚âã V‚ÇÇ ‚Üí reify V‚ÇÅ   ‚â° reify V‚ÇÇ 
-- reifyRow-‚âã : ‚àÄ {n} (P Q : Fin n ‚Üí Label √ó SemType Œî Œ∫) ‚Üí  
--                (‚àÄ (i : Fin n) ‚Üí P i ‚âã‚ÇÇ Q i) ‚Üí 
--                reifyRow (n , P) ‚â° reifyRow (n , Q)
\end{code}
\begin{code}[hide]
-- reflect-‚âã  = bot _ 
-- reify-‚âã    = bot _ 
-- reifyRow-‚âã = bot _ 
\end{code}

\subsection{The fundamental theorem and completeness}

\begin{code}
-- fundC : ‚àÄ {œÑ‚ÇÅ œÑ‚ÇÇ : Type Œî‚ÇÅ Œ∫} {Œ∑‚ÇÅ Œ∑‚ÇÇ : Env Œî‚ÇÅ Œî‚ÇÇ} ‚Üí 
--        Env-‚âã Œ∑‚ÇÅ Œ∑‚ÇÇ ‚Üí œÑ‚ÇÅ ‚â°t œÑ‚ÇÇ ‚Üí eval œÑ‚ÇÅ Œ∑‚ÇÅ ‚âã eval œÑ‚ÇÇ Œ∑‚ÇÇ
-- fundC-pred : ‚àÄ {œÄ‚ÇÅ œÄ‚ÇÇ : Pred Type Œî‚ÇÅ R[ Œ∫ ]} {Œ∑‚ÇÅ Œ∑‚ÇÇ : Env Œî‚ÇÅ Œî‚ÇÇ} ‚Üí 
--             Env-‚âã Œ∑‚ÇÅ Œ∑‚ÇÇ ‚Üí œÄ‚ÇÅ ‚â°p œÄ‚ÇÇ ‚Üí evalPred œÄ‚ÇÅ Œ∑‚ÇÅ ‚â° evalPred œÄ‚ÇÇ Œ∑‚ÇÇ
-- fundC-Row : ‚àÄ {œÅ‚ÇÅ œÅ‚ÇÇ : SimpleRow Type Œî‚ÇÅ R[ Œ∫ ]} {Œ∑‚ÇÅ Œ∑‚ÇÇ : Env Œî‚ÇÅ Œî‚ÇÇ} ‚Üí 
--             Env-‚âã Œ∑‚ÇÅ Œ∑‚ÇÇ ‚Üí œÅ‚ÇÅ ‚â°r œÅ‚ÇÇ ‚Üí evalRow œÅ‚ÇÅ Œ∑‚ÇÅ ‚âãR evalRow œÅ‚ÇÇ Œ∑‚ÇÇ
\end{code}
\begin{code}[hide]
-- fundC = bot _
-- fundC-pred = bot _
-- fundC-Row = bot _
\end{code}

\begin{code}
-- idEnv-‚âã : ‚àÄ {Œî} ‚Üí Env-‚âã (idEnv {Œî}) (idEnv {Œî})
-- idEnv-‚âã x = reflect-‚âã refl

-- completeness : ‚àÄ {œÑ‚ÇÅ œÑ‚ÇÇ : Type Œî Œ∫} ‚Üí œÑ‚ÇÅ ‚â°t œÑ‚ÇÇ ‚Üí ‚áì œÑ‚ÇÅ ‚â° ‚áì œÑ‚ÇÇ
-- completeness eq = reify-‚âã (fundC idEnv-‚âã eq)  

-- completeness-row : ‚àÄ {œÅ‚ÇÅ œÅ‚ÇÇ : SimpleRow Type Œî R[ Œ∫ ]} ‚Üí œÅ‚ÇÅ ‚â°r œÅ‚ÇÇ ‚Üí ‚áìRow œÅ‚ÇÅ ‚â° ‚áìRow œÅ‚ÇÇ
\end{code}
\begin{code}[hide]
-- completeness-row = bot _
\end{code}

\subsection{A logical relation for soundness}
\begin{code}
-- infix 0 ‚ü¶_‚üß‚âã_
-- ‚ü¶_‚üß‚âã_ : ‚àÄ {Œ∫} ‚Üí Type Œî Œ∫ ‚Üí SemType Œî Œ∫ ‚Üí Set
-- ‚ü¶_‚üß‚âãne_ : ‚àÄ {Œ∫} ‚Üí Type Œî Œ∫ ‚Üí NeutralType Œî Œ∫ ‚Üí Set

-- ‚ü¶_‚üßr‚âã_ : ‚àÄ {Œ∫} ‚Üí SimpleRow Type Œî R[ Œ∫ ] ‚Üí Row (SemType Œî Œ∫) ‚Üí Set
-- ‚ü¶_‚üß‚âã‚ÇÇ_ : ‚àÄ {Œ∫} ‚Üí Label √ó Type Œî Œ∫ ‚Üí Label √ó SemType Œî Œ∫ ‚Üí Set
-- ‚ü¶ (l‚ÇÅ , œÑ) ‚üß‚âã‚ÇÇ (l‚ÇÇ , V) = (l‚ÇÅ ‚â° l‚ÇÇ) √ó (‚ü¶ œÑ ‚üß‚âã V)

-- SoundKripke : Type Œî‚ÇÅ (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ) ‚Üí KripkeFunction Œî‚ÇÅ Œ∫‚ÇÅ Œ∫‚ÇÇ ‚Üí Set
-- SoundKripkeNE : Type Œî‚ÇÅ (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ) ‚Üí KripkeFunctionNE Œî‚ÇÅ Œ∫‚ÇÅ Œ∫‚ÇÇ ‚Üí Set

-- -- œÑ is equivalent to neutral `n` if it's equivalent 
-- -- to the Œ∑ and map-id expansion of n
-- ‚ü¶_‚üß‚âãne_ œÑ n = œÑ ‚â°t ‚áë (Œ∑-norm n)

-- ‚ü¶_‚üß‚âã_ {Œ∫ = ‚òÖ} œÑ‚ÇÅ œÑ‚ÇÇ = œÑ‚ÇÅ ‚â°t ‚áë œÑ‚ÇÇ
-- ‚ü¶_‚üß‚âã_ {Œ∫ = L} œÑ‚ÇÅ œÑ‚ÇÇ = œÑ‚ÇÅ ‚â°t ‚áë œÑ‚ÇÇ
-- ‚ü¶_‚üß‚âã_ {Œî‚ÇÅ} {Œ∫ = Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ} f F = SoundKripke f F
-- ‚ü¶_‚üß‚âã_ {Œî} {Œ∫ = R[ Œ∫ ]} œÑ (row (n , P)  oœÅ) =
--     let xs = ‚áëRow (reifyRow (n , P)) in 
--     (œÑ ‚â°t ‚¶Ö xs ‚¶Ü (fromWitness (Ordered‚áë (reifyRow (n , P)) (reifyRowOrdered' n P oœÅ)))) √ó 
--     (‚ü¶ xs ‚üßr‚âã (n , P))
-- ‚ü¶_‚üß‚âã_ {Œî} {Œ∫ = R[ Œ∫ ]} œÑ (l ‚ñπ V) = (œÑ ‚â°t (‚áëNE l ‚ñπ ‚áë (reify V))) √ó (‚ü¶ ‚áë (reify V) ‚üß‚âã V)
-- ‚ü¶_‚üß‚âã_ {Œî} {Œ∫ = R[ Œ∫ ]} œÑ ((œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) {nr}) = (œÑ ‚â°t (‚áë (reify ((œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) {nr})))) √ó (‚ü¶ ‚áë (reify œÅ‚ÇÇ) ‚üß‚âã œÅ‚ÇÇ) √ó (‚ü¶ ‚áë (reify œÅ‚ÇÅ) ‚üß‚âã œÅ‚ÇÅ)
-- ‚ü¶_‚üß‚âã_ {Œî} {Œ∫ = R[ Œ∫ ]} œÑ (œÜ <$> n) = 
--   ‚àÉ[ f ] ((œÑ ‚â°t (f <$> ‚áëNE n)) √ó (SoundKripkeNE f œÜ))
-- ‚ü¶ [] ‚üßr‚âã (zero , P) = ‚ä§
-- ‚ü¶ [] ‚üßr‚âã (suc n , P) = ‚ä•
-- ‚ü¶ x ‚à∑ œÅ ‚üßr‚âã (zero , P) = ‚ä•
-- ‚ü¶ x ‚à∑ œÅ ‚üßr‚âã (suc n , P) =  (‚ü¶ x ‚üß‚âã‚ÇÇ (P fzero)) √ó ‚ü¶ œÅ ‚üßr‚âã (n , P ‚àò fsuc)

-- SoundKripke {Œî‚ÇÅ = Œî‚ÇÅ} {Œ∫‚ÇÅ = Œ∫‚ÇÅ} {Œ∫‚ÇÇ = Œ∫‚ÇÇ} f F =     
--     ‚àÄ {Œî‚ÇÇ} (œÅ : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) {v V} ‚Üí 
--       ‚ü¶ v ‚üß‚âã V ‚Üí 
--       ‚ü¶ (ren‚Çñ œÅ f ¬∑ v) ‚üß‚âã (renKripke œÅ F ¬∑V V)

-- SoundKripkeNE {Œî‚ÇÅ = Œî‚ÇÅ} {Œ∫‚ÇÅ = Œ∫‚ÇÅ} {Œ∫‚ÇÇ = Œ∫‚ÇÇ} f F =     
--     ‚àÄ {Œî‚ÇÇ} (r : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) {v V} ‚Üí 
--       ‚ü¶ v ‚üß‚âãne  V ‚Üí 
--       ‚ü¶ (ren‚Çñ r f ¬∑ v) ‚üß‚âã (F r V)
\end{code}

\subsubsection{Properties}~
\begin{code}
-- reflect-‚ü¶‚üß‚âã : ‚àÄ {œÑ : Type Œî Œ∫} {œÖ :  NeutralType Œî Œ∫} ‚Üí 
--              œÑ ‚â°t ‚áëNE œÖ ‚Üí ‚ü¶ œÑ ‚üß‚âã (reflect œÖ)
-- reify-‚ü¶‚üß‚âã : ‚àÄ {œÑ : Type Œî Œ∫} {V :  SemType Œî Œ∫} ‚Üí 
--                ‚ü¶ œÑ ‚üß‚âã V ‚Üí œÑ ‚â°t ‚áë (reify V)
-- Œ∑-norm-‚â°t : ‚àÄ (œÑ : NeutralType Œî Œ∫) ‚Üí ‚áë (Œ∑-norm œÑ) ‚â°t ‚áëNE œÑ 
-- subst-‚ü¶‚üß‚âã : ‚àÄ {œÑ‚ÇÅ œÑ‚ÇÇ : Type Œî Œ∫} ‚Üí 
--   œÑ‚ÇÅ ‚â°t œÑ‚ÇÇ ‚Üí {V : SemType Œî Œ∫} ‚Üí ‚ü¶ œÑ‚ÇÅ ‚üß‚âã V ‚Üí ‚ü¶ œÑ‚ÇÇ ‚üß‚âã V 
\end{code}

\subsubsection{Logical environments}~
\begin{code}
-- ‚ü¶_‚üß‚âãe_ : ‚àÄ {Œî‚ÇÅ Œî‚ÇÇ} ‚Üí Substitution‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí Env Œî‚ÇÅ Œî‚ÇÇ ‚Üí Set  
-- ‚ü¶_‚üß‚âãe_ {Œî‚ÇÅ} œÉ Œ∑ = ‚àÄ {Œ∫} (Œ± : TVar Œî‚ÇÅ Œ∫) ‚Üí ‚ü¶ (œÉ Œ±) ‚üß‚âã (Œ∑ Œ±)

-- Identity relation
-- idSR : ‚àÄ {Œî‚ÇÅ} ‚Üí  ‚ü¶ ` ‚üß‚âãe (idEnv {Œî‚ÇÅ})
-- idSR Œ± = reflect-‚ü¶‚üß‚âã eq-refl
\end{code}
\begin{code}[hide]
-- reflect-‚ü¶‚üß‚âã = bot _
-- reify-‚ü¶‚üß‚âã = bot _
-- Œ∑-norm-‚â°t = bot _
-- subst-‚ü¶‚üß‚âã = bot _
-- \end{code}
-- \subsection{The fundamental theorem and soundness}
-- \begin{code}
-- fundS : ‚àÄ {Œî‚ÇÅ Œî‚ÇÇ Œ∫}(œÑ : Type Œî‚ÇÅ Œ∫){œÉ : Substitution‚Çñ Œî‚ÇÅ Œî‚ÇÇ}{Œ∑ : Env Œî‚ÇÅ Œî‚ÇÇ} ‚Üí 
--           ‚ü¶ œÉ ‚üß‚âãe Œ∑  ‚Üí ‚ü¶ sub‚Çñ œÉ œÑ ‚üß‚âã (eval œÑ Œ∑)
-- fundSRow : ‚àÄ {Œî‚ÇÅ Œî‚ÇÇ Œ∫}(xs : SimpleRow Type Œî‚ÇÅ R[ Œ∫ ]){œÉ : Substitution‚Çñ Œî‚ÇÅ Œî‚ÇÇ}{Œ∑ : Env Œî‚ÇÅ Œî‚ÇÇ} ‚Üí 
--           ‚ü¶ œÉ ‚üß‚âãe Œ∑  ‚Üí ‚ü¶ subRow‚Çñ œÉ xs ‚üßr‚âã (evalRow xs Œ∑)
-- fundSPred : ‚àÄ {Œî‚ÇÅ Œ∫}(œÄ : Pred Type Œî‚ÇÅ R[ Œ∫ ]){œÉ : Substitution‚Çñ Œî‚ÇÅ Œî‚ÇÇ}{Œ∑ : Env Œî‚ÇÅ Œî‚ÇÇ} ‚Üí 
--           ‚ü¶ œÉ ‚üß‚âãe Œ∑ ‚Üí (subPred‚Çñ œÉ œÄ) ‚â°p ‚áëPred (evalPred œÄ Œ∑) 
\end{code}

\begin{code}[hide]
-- fundS = bot _
-- fundSRow = bot _
-- fundSPred = bot _
\end{code}

\begin{code}
--------------------------------------------------------------------------------
-- Fundamental theorem when substitution is the identity
-- sub‚Çñ-id : ‚àÄ (œÑ : Type Œî Œ∫) ‚Üí sub‚Çñ ` œÑ ‚â° œÑ 

-- ‚ä¢‚ü¶_‚üß‚âã : ‚àÄ (œÑ : Type Œî Œ∫) ‚Üí ‚ü¶ œÑ ‚üß‚âã eval œÑ idEnv
-- ‚ä¢‚ü¶ œÑ ‚üß‚âã = subst-‚ü¶‚üß‚âã (inst (sub‚Çñ-id œÑ)) (fundS œÑ idSR)
\end{code}
\begin{code}[hide]
-- sub‚Çñ-id œÑ = bot _
\end{code}

\begin{code}
--------------------------------------------------------------------------------
-- Soundness claim  

-- soundness :  ‚àÄ {Œî‚ÇÅ Œ∫} ‚Üí (œÑ : Type Œî‚ÇÅ Œ∫) ‚Üí œÑ ‚â°t ‚áë (‚áì œÑ) 
-- soundness œÑ = reify-‚ü¶‚üß‚âã (‚ä¢‚ü¶ œÑ ‚üß‚âã)

 --------------------------------------------------------------------------------
-- If œÑ‚ÇÅ normalizes to ‚áì œÑ‚ÇÇ then the embedding of œÑ‚ÇÅ is equivalent to œÑ‚ÇÇ

-- embed-‚â°t : ‚àÄ {œÑ‚ÇÅ : NormalType Œî Œ∫} {œÑ‚ÇÇ : Type Œî Œ∫}  ‚Üí œÑ‚ÇÅ ‚â° (‚áì œÑ‚ÇÇ) ‚Üí ‚áë œÑ‚ÇÅ ‚â°t œÑ‚ÇÇ
-- embed-‚â°t {œÑ‚ÇÅ = œÑ‚ÇÅ} {œÑ‚ÇÇ} refl = eq-sym (soundness œÑ‚ÇÇ) 

--------------------------------------------------------------------------------
-- Soundness implies the converse of completeness, as desired

-- Completeness‚Åª¬π : ‚àÄ {Œî Œ∫} ‚Üí (œÑ‚ÇÅ œÑ‚ÇÇ : Type Œî Œ∫) ‚Üí ‚áì œÑ‚ÇÅ ‚â° ‚áì œÑ‚ÇÇ ‚Üí œÑ‚ÇÅ ‚â°t œÑ‚ÇÇ
-- Completeness‚Åª¬π œÑ‚ÇÅ œÑ‚ÇÇ eq = eq-trans (soundness œÑ‚ÇÅ) (embed-‚â°t eq)
\end{code}


\bibliographystyle{plainnat}
\bibliography{NBE}
\end{document}
%%% Local Variables: 
%%% TeX-command-extra-options: "-shell-escape"
%%% End:
%  LocalWords:  denotational Agda Wadler dPoint sqrt subtyping coercions Intr
%  LocalWords:  RowTypes Bool eval GHC reified HillerstromL Leijen LindleyM RO
%  LocalWords:  ChapmanKNW Aydemir AbelAHPMSS AbelC AbelOV plfa HubersIMM STLC
%  LocalWords:  MorrisM denotationally DenotationalSoundness RowTheories Suc de
%  LocalWords:  ReifyingVariants RowTheory BerthomieuM CardelliMMS HarperP NatF
%  LocalWords:  XueOX GasterJ Sipser SaffrichTM Env Expr Agda's Leivant ChanW
%  LocalWords:  ThiemannW ImpredicativeSet ImpredicativeSetSucks AbelP chapman
%  LocalWords:  AltenkirchK KaposiKK Gaster XieOBS BiXOS Chlipala objTypes Bahr
%  LocalWords:  Garrigue KEnv PEnv
