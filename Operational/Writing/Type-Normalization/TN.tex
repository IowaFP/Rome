\documentclass[authoryear, acmsmall, screen, review, nonacm]{acmart}
\overfullrule=1mm
% \usepackage[margin=1.5in]{geometry}

\include{header.tex} 
\usepackage{agda}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% ACM garbage
\setcopyright{none}
\citestyle{acmauthoryear}
\settopmatter{printacmref=false, printfolios=true}
\renewcommand{\footnotetextcopyrightpermission}{} 
% Redefine the \acmDOI command to do nothing 
\pagestyle{empty}
\fancyfoot{}

%\usepackage[utf8]{inputenc}
% \numberwithin{equation}{section}
% \numberwithin{theorem}{section}

\title{Type Normalization in \Rome}
\author{Alex Hubers}
\orcid{0000-0002-6237-3326}
\affiliation{
  \department{Department of Computer Science}
  \institution{The University of Iowa}
  \streetaddress{14 MacLean Hall}
  \city{Iowa City}
  \state{Iowa}
  \country{USA}}
\email{alexander-hubers@uiowa.edu}

\usepackage{newunicodechar}
\newunicodechar{∋}{$\ni$}
\newunicodechar{ε}{$\epsilon$}
\newunicodechar{·}{$\cdot$}
\newunicodechar{⊢}{$\vdash$}
\newunicodechar{⋆}{${}^\star$}
\newunicodechar{Π}{$\Pi$}
\newunicodechar{⇒}{$\Rightarrow$}
\newunicodechar{ƛ}{$\lambdabar$}
\newunicodechar{∅}{$\emptyset$}
\newunicodechar{∀}{$\forall$}
\newunicodechar{ϕ}{$\Phi$}
\newunicodechar{ψ}{$\Psi$}
\newunicodechar{ρ}{$\rho$}
\newunicodechar{α}{$\alpha$}
\newunicodechar{β}{$\beta$}
\newunicodechar{μ}{$\mu$}
\newunicodechar{σ}{$\sigma$}
\newunicodechar{≡}{$\equiv$}
\newunicodechar{Γ}{$\Gamma$}
\newunicodechar{∥}{$\parallel$}
\newunicodechar{Λ}{$\Lambda$}
\newunicodechar{₂}{$_2$}
\newunicodechar{θ}{$\theta$}
\newunicodechar{Θ}{$\Theta$}
\newunicodechar{∘}{$\circ$}
\newunicodechar{Δ}{$\Delta$}
\newunicodechar{★}{$\star$}
\newunicodechar{λ}{$\lambda$}
\newunicodechar{⊧}{$\models$}
\newunicodechar{⊎}{$\uplus$}
\newunicodechar{η}{$\eta$}
\newunicodechar{⊥}{$\bot$}
\newunicodechar{Σ}{$\Sigma$}
\newunicodechar{ξ}{$\xi$}
\newunicodechar{₁}{$_1$}
\newunicodechar{ₖ}{$_k$}
\newunicodechar{₃}{$_3$}
\newunicodechar{ℕ}{$\mathbb{N}$}
\newunicodechar{ᶜ}{${}^c$}
\newunicodechar{Φ}{$\Phi$}
\newunicodechar{Ψ}{$\Psi$}
\newunicodechar{⊤}{$\top$}
\newunicodechar{κ}{$\kappa$}
\newunicodechar{τ}{$\tau$}
\newunicodechar{π}{$\pi$}
\newunicodechar{⌊}{$\lfloor$}
\newunicodechar{⌋}{$\rfloor$}
\newunicodechar{≲}{$\lesssim$}
\newunicodechar{▹}{$\triangleright$}
\newunicodechar{ℓ}{$\ell$}
\newunicodechar{υ}{$\upsilon$}

\newunicodechar{→}{$\rightarrow$}
\newunicodechar{×}{$\times$}
\newunicodechar{ω}{$\omega$}
\newunicodechar{∃}{$\exists$}
\newunicodechar{∈}{$\in$}
\newunicodechar{⇑}{$\Uparrow$}
\newunicodechar{⇓}{$\Downarrow$}
\newunicodechar{≋}{$\approx$}
\newunicodechar{ₗ}{$_l$}
\newunicodechar{ᵣ}{$_r$}
\newunicodechar{⟦}{$\llbracket$}
\newunicodechar{⟧}{$\rrbracket$}
\newunicodechar{⁻}{$^{-}$}
\newunicodechar{¹}{$^{1}$}

\begin{document}

\maketitle

\section{Introduction}

\begin{code}[hide]%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{bot}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{X}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{X}\<%
\end{code}
We describe the normalization-by-evaluation (NBE) of types in \Rome. Types are normalized modulo $\beta$- and $\eta$-equivalence---that is, to $\beta\eta$-long forms. Because the type system of \Rome is a strict extension of System \Fome, type level computation for arrow kinds is isomorphic to reduction of arrow types in the STLC. Novel to this report are the reductions of $\Pi$, $\Sigma$, and row types.

\section{The \Rome{} calculus}

We present the type calculus of \Rome. The syntax of kinds, types, and predicates are given in \figref{syntax-types} for reference. We describe the mechanized syntax in the sections that follow.

\begin{figure}[H]
\begin{gather*}
\begin{array}{r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l}
\text{Type variables} & \alpha \in \mathcal A & \text{Labels} & \ell \in \mathcal L
\end{array}
\\[5px]
\begin{doublesyntaxarray}
  \mcl{\text{Kinds}} & \kappa & ::= & \TypeK \mid \LabK \mid \RowK \kappa \mid \kappa \to \kappa \\
  \mcl{\text{Predicates}} & \pi, \psi & ::= & \LeqP \rho \rho \mid \PlusP \rho \rho \rho \\
  \text{Types} & \mcr{\Types \ni \phi, \tau, \upsilon, \rho, \xi} & ::= & \alpha \mid \pi \then \tau \mid \forall \alpha\co\kappa. \tau \mid \lambda \alpha\co\kappa. \tau \mid \tau \, \tau \\
               &                              &     & \mid    & \RowIx i 0 m {\LabTy {\xi_i} {\tau_i}} \mid \ell \mid \Sing{\tau} \mid \Mapp{\phi}{\rho} \mid \rho \Compl \rho \\ 
               &                              &     & \mid & \tau \to \tau \mid \Pi \, \rho \mid \Sigma \, \rho \mid \mu \, \phi 
\end{doublesyntaxarray}
\end{gather*}
\caption{Syntax}
\label{fig:syntax-types}
\end{figure}

\subsection{Kind syntax}
Our formalization of \Rome types is \emph{intrinsic}, meaning we define the syntax of \emph{typing} and \emph{kinding judgments}, foregoing any formalization of / indexing by untyped syntax. The syntax of types is indexed by kinding environments and kinds, defined below.

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Kind}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{★}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Kind}\<%
\\
%
\>[2]\AgdaInductiveConstructor{L}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Kind}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}`→\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Kind}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Kind}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Kind}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{R[\AgdaUnderscore{}]}}%
\>[8]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Kind}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Kind}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{5}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}`→\AgdaUnderscore{}}}\<%
\end{code}

The kind system of \Rome defines $\star$ as the type of types; $L$ as the type of labels; $(\to)$ as the type of type operators; and $R[\kappa]$ as the type of \emph{rows} containing types at kind $\kappa$.

The syntax of kinding environments is given below. Kinding environments are isomorphic to lists of kinds.

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{KEnv}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{ε}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{KEnv}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},,\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{KEnv}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Kind}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{KEnv}\<%
\end{code}

Let the metavariables $\Delta$ and $\kappa$ range over kinding environments and kinds, respectively. Correspondingly, we define \emph{generalized variables} in Agda at these names. 

\begin{code}%
\>[0]\AgdaKeyword{private}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{variable}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaGeneralizable{Δ₃}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{KEnv}\<%
\\
%
\>[4]\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Kind}\<%
\end{code}

The syntax of intrinsically well-scoped De-Bruijn type variables is given below. We say that the type variable $x$ is indexed by kinding environment $\Delta$ and kind $\kappa$ to specify that $x$ has kind $\kappa$ in kinding environment $\Delta$.

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{TVar}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{KEnv}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Kind}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{Z}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{TVar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
%
\>[2]\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{TVar}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{TVar}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\<%
\end{code}

\subsection{Type syntax}

\Rome is a qualified type system with predicates of the form $\rho_1 \lesssim \rho_2$ and $\rho_1 \cdot \rho_2 \sim \rho_3$ for row-kinded types $\rho_1$, $\rho_2$, and $\rho_3$. Because predicates occur in types and types occur in predicates, the syntax of well-kinded types and well-kinded predicates are mutually recursive. The syntax for each is given below. we describe (in this order) the syntactic components belonging to System $\Fome$, qualified type systems, and system \RO.

\begin{code}[hide]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.String}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{String}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{Label}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{String}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{infixl}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}·\AgdaUnderscore{}}}\<%
\\
\>[0]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{2}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⇒\AgdaUnderscore{}}}\<%
\end{code}

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Pred}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Δ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{KEnv}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Kind}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Kind}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{`}%
\>[96I]\AgdaSymbol{:}\<%
\\
\>[.][@{}l@{}]\<[96I]%
\>[4]\AgdaSymbol{(}\AgdaBound{α}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{TVar}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}·\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}`→\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{`∀}%
\>[8]\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{μ}%
\>[8]\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{★}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\<%
\end{code}

The first three constructors are analogous to the terms of the STLC. the constructor \verb!`→! classifies term functions; the constructor \verb!`∀! classifies type-in-term quantification; and the constructor \verb!μ! classifies recursive terms. Note that \verb!μ! could be further generalized to kind \verb!κ `→ ★!; however, we found that kind \verb!★ `→ ★! was sufficient for our needs while simplifying both presentation and mechanization.

The syntax of qualified types is given below.

\begin{code}%
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⇒\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{π}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Pred}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\<%
\end{code}

The type \verb!π ⇒ τ! states that \verb!τ! is \emph{qualified} by the predicate \verb!π!---that is, the type variables bound in \verb!τ! are restricted in instantiation to just those that satisfy the predicate \verb!π!. This is completely analogous to identical syntax used in Haskell to introduce typeclass qualification. Predicates are defined below (after the presentation of type syntax).

We now describe the syntax exclusive to \Rome, beginning with label kind introduction and elimination. Labels are first-class entities in \Rome, and may be represented by both constants and variables. 

\begin{code}%
%
\>[2]\AgdaInductiveConstructor{lab}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Label}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{⌊\AgdaUnderscore{}⌋}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\<%
\end{code}

Label constants in \Rome are constructed from the type \verb!Label!; in our mechanization, \verb!Label! is a type synonym for \verb!String!, but one could choose any other candidate with decidable equality. Types at label kind \verb!L! may be cast to \emph{label singletons} by the \verb!⌊_⌋! constructor. This makes labels first-class entities: for example, as the type \verb!⌊ lab "l" ⌋! has kind $\star$, it can be inhabited by a term.

Types at row kind are constructed by one of the following three constructors.

\begin{code}%
%
\>[2]\AgdaInductiveConstructor{ε}%
\>[192I]\AgdaSymbol{:}\<%
\\
\>[.][@{}l@{}]\<[192I]%
\>[4]\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}▹\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}<\$>\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\end{code}

Rows in \Rome are either the empty row \verb!ε!, a labeled row \verb!(l ▹ τ)!, or a row mapping \verb!f <$> τ!. The row mapping \verb!f <$> (l ▹ τ)! describes the lifting of the function \verb!f! over row \verb!(l ▹ τ)!, which we will define to equal \verb!(l ▹ f τ)! in the case where the right hand applicand is a labeled row. We will show that rows in Rome (that is, types at row kind) reduce to either the empty row \verb!ε! or a labeled row \verb!(l ▹ τ)! after normalization. There are two important consequences of this canonicity: firstly, we treat row mapping \verb!_<$>_! as having latent computation to perform (there are no normal types with form \verb!f <$> τ! except when \verb!τ! is a neutral variable). The second consequence is that we do not permit the formation of rows with more than one label-type association. Such rows are instead formed as type variables with predicates specifying the shape of the row.

Rows in \Rome are eliminated by the \verb!Π! and \verb!Σ! constructors.

\begin{code}%
%
\>[2]\AgdaInductiveConstructor{Π}%
\>[8]\AgdaSymbol{:}\<%
\\
\>[8][@{}l@{\AgdaIndent{0}}]%
\>[10]\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{Σ}%
\>[8]\AgdaSymbol{:}\<%
\\
\>[8][@{}l@{\AgdaIndent{0}}]%
\>[10]\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\<%
\end{code}

Given a type $\rho$ at row kind, $\Pi \rho$ constructs a record with label-type associations from \verb!ρ! and $\Sigma \rho$ constructs a variant that has label and type from \verb!ρ!. We choose to represent \verb!Π! and \verb!Σ! as type constants at kind \verb!(R[ κ ] `→ κ)!; we will show that many applications of \verb!Π! and \verb!Σ! induce type reductions, and hence it is convenient to group such reductions with type application.

The syntax of predicates is given below. The predicate $\LeqP {\rho_1} {\rho_2}$ states that label-to-type mappings in $\rho_1$ are a subset of those in $\rho_2$; the predicate $\PlusP {\rho_1} {\rho_2} {\rho_3}$ states that the combination of mappings in $\rho_1$ and $\rho_2$ equals $\rho_3$.

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Pred}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}·\AgdaUnderscore{}\textasciitilde{}\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSpace{}%
\AgdaBound{ρ₃}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{Pred}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}≲\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{Pred}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\end{code}

\citet{HubersM23} implicitly define two type-level row lifting operators, \emph{left mapping} \verb!<$>! and \emph{right mapping} \verb!<?>!, but the latter is superfluous. We appeal to the kinds of these operators for their intuition: left mapping \verb!f <$> ρ! lifts a function at arrow kind \verb!f : κ₁ → κ₂! into a function at kind \verb!R[ κ₁ ] → R[ κ₂ ]! and then applies it to \verb!ρ : R[ κ₂ ]!. We may define right mapping (named \emph{flap} and written \verb!<?>!, after similar Haskell operators) of row function $f : R[ \kappa_1 \to \kappa_2 ]$ over type $\tau : \kappa_1$ using left mapping under the following identity:

\[
f\, \verb!<?>!\, \tau = (\lambda\, g.\, g \, \tau) \, \verb!<$>!\, f
\]

\Ni which we encode in Agda as follows:

\begin{code}%
\>[0]\AgdaFunction{flap}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{flap}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{))))}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<\$>}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{))))}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}<?>\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
\>[0]\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<?>}}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{flap}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{a}\<%
\end{code}

\Ni (We choose to define \verb!_<?>_! as the application of \verb!flap! to inputs \verb!f! and \verb!a! so that we needn't pollute the definition with weakenings of its arguments.)


\subsubsection{Type renaming}

We closely follow \citet{plfa22} and \citet{ChapmanKNW19}  in defining a \emph{type renaming} as a function from type variables in one kinding environment to type variables in another. This is the \emph{parallel renaming and substitution} approach for which weakening and single variable substitution are special cases. The code we establish now will be mimicked again for both normal types and for terms; many names are reused, and so we find it helpful to index duplicate names by a suffix. The suffix $_k$ specifies that this definition describes the \verb!Type! syntax.

\begin{code}%
\>[0]\AgdaFunction{Renamingₖ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{KEnv}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{KEnv}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{Renamingₖ}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{TVar}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{TVar}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaBound{κ}\<%
\end{code}

\Ni We will let the metavariable $\rho$ range over both renamings and types at row kind.

Lifting can be thought of as the weakening of a renaming, and permits renamings to be pushed under binders.

\begin{code}%
\>[0]\AgdaFunction{liftₖ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Renamingₖ}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Renamingₖ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{liftₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\<%
\\
\>[0]\AgdaFunction{liftₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\end{code}

We define renaming as a function that translates a kinding derivation in kinding environment \verb!Δ₁! to environment \verb!Δ₂! provided a renaming from \verb!Δ₁! to \verb!Δ₂!. The definition proceeds by induction on the input kinding derivation. In the variable case, we use $\rho$ to rename variable $x$. In the \verb!`λ! and \verb!`∀! cases, we must lift the renaming $\rho$ over the type variable introduced by these binders. The rest of the cases are effectively just congruence over the type structure.

\begin{code}%
\>[0]\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Renamingₖ}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
\>[0]\AgdaFunction{renPredₖ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Renamingₖ}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Pred}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Pred}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}%
\>[18]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}%
\>[18]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{liftₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}%
\>[18]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{renPredₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ}\<%
\\
\>[0]\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`∀}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}%
\>[18]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{`∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{liftₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}%
\>[18]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\<%
\\
\>[0]\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}%
\>[18]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{μ}\AgdaSpace{}%
\AgdaBound{F}\AgdaSymbol{)}%
\>[18]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{μ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{F}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaInductiveConstructor{Π}%
\>[18]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{Π}\<%
\\
\>[0]\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaInductiveConstructor{Σ}%
\>[18]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{Σ}\<%
\\
\>[0]\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{lab}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}%
\>[18]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{lab}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}%
\>[18]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ}\<%
\\
\>[0]\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌊}}\AgdaSpace{}%
\AgdaBound{ℓ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌋}}%
\>[18]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌊}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{ℓ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌋}}\<%
\\
\>[0]\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<\$>}}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}%
\>[18]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<\$>}}\AgdaSpace{}%
\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{m}\<%
\end{code}

As \verb!Type! and \verb!Pred! are mutually inductive, we must define \verb!renPredₖ! as mutually recursive to \verb!renₖ!. Its definition is completely unsuprising.

\begin{code}%
\>[0]\AgdaFunction{renPredₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\textasciitilde{}}}\AgdaSpace{}%
\AgdaBound{ρ₃}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\textasciitilde{}}}\AgdaSpace{}%
\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{ρ₃}\<%
\\
\>[0]\AgdaFunction{renPredₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{≲}}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{ρ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{≲}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSymbol{)}\<%
\end{code}

Finally, weakening is a special case of renaming.

\begin{code}%
\>[0]\AgdaFunction{weakenₖ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\<%
\\
\>[0]\AgdaFunction{weakenₖ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaInductiveConstructor{S}\<%
\end{code}

\subsubsection{Type substitution}

We wish to give both a declarative and algorithmic treatment of type equivalence. For the latter, we will normalize types to normal forms, meaning types are equivalent iff their normal forms are definitionally equal. For the former, we must define $\beta$-substitution syntactically so that we can express $\beta$-equivalence of types declaratively. In our development, $\beta$-reduction is a special case of substitution.

We define a substitution as a function mapping type variables in context $\Delta_1$ to types in context $\Delta_2$.

\begin{code}%
\>[0]\AgdaFunction{Substitutionₖ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{KEnv}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{KEnv}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{Substitutionₖ}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{TVar}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaBound{κ}\<%
\end{code}

Substitutions must be lifted over binders, just as is done for renamings. 

\begin{code}%
\>[0]\AgdaFunction{liftsₖ}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[10]\AgdaFunction{Substitutionₖ}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Substitutionₖ}\AgdaSymbol{(}\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{liftsₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\<%
\\
\>[0]\AgdaFunction{liftsₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{weakenₖ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\end{code}

Substitution is defined inductively over types in a similar fashion to renaming. Note that this is
\emph{simultaneous} substitution and renaming---The variable case translates type variable \verb!x! to the type $\sigma \, \tau$, for which the substitution \verb!σ! also performs a renaming from environment $\Delta_1$ to $\Delta_2$. The rest of the cases (as with renaming) are either congruences over the type structure or congruences plus lifting of the substitution. Again, substitution over predicates is defined mutually recursively.

\begin{code}%
\>[0]\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Substitutionₖ}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
\>[0]\AgdaFunction{subPredₖ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Substitutionₖ}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Pred}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Pred}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
\>[0]\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\<%
\\
\>[0]\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{liftsₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{subPredₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{τ}\<%
\\
\>[0]\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`∀}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{`∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{liftsₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{μ}\AgdaSpace{}%
\AgdaBound{F}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{μ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{F}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{Π}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{Π}\<%
\\
\>[0]\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaInductiveConstructor{Σ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{Σ}\<%
\\
\>[0]\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{lab}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{lab}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{τ}\<%
\\
\>[0]\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌊}}\AgdaSpace{}%
\AgdaBound{ℓ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌋}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌊}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{ℓ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌋}}\<%
\\
\>[0]\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<\$>}}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<\$>}}\AgdaSpace{}%
\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{a}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{subPredₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\textasciitilde{}}}\AgdaSpace{}%
\AgdaBound{ρ₃}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\textasciitilde{}}}\AgdaSpace{}%
\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{ρ₃}\<%
\\
\>[0]\AgdaFunction{subPredₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{≲}}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{ρ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{≲}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSymbol{)}\<%
\end{code}

We define the extension of a substitution $\sigma$ by the type $\tau$ functionally. If we had chosen to represent a \verb!Substitutionₖ! as a list, extension would be done by the \verb!cons! constructor. In a De-Bruijn representation, the most recently appended variable is zero---hence an extension here maps the zero variable to \verb!τ! in the \verb!Z! case and maps each variable \verb!(S x)! to its value in \verb!σ! at predecessor \verb!x!.

\begin{code}%
\>[0]\AgdaFunction{extendₖ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Substitutionₖ}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Substitutionₖ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\<%
\\
\>[0]\AgdaFunction{extendₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{τ}\<%
\\
\>[0]\AgdaFunction{extendₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}

Finally, $\beta$-substitution is simply a special case of substitution. Note that the constructor \verb!`! has type \verb!TVar Δ κ → Type Δ κ!, making it a substitution. It is in fact an identity substitution, which fixes the meaning of its type variables, hence it is the substitution we choose to extend when defining $\beta$-substitution.

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}βₖ[\AgdaUnderscore{}]}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\<%
\\
\>[0]\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{βₖ[}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{extendₖ}\AgdaSpace{}%
\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{τ₁}\<%
\end{code}

\subsection{Type equivalence}

We define type and predicate equivalence mutually recursively. You may think of type equivalence also as a sort of small-step relation on types, as we include rules to equate $\beta$-equivalent and $\eta$-equivalent types, as well as a number of computational steps a row kinded type may take.

\begin{code}%
\>[0]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡t\AgdaUnderscore{}}}\<%
\\
\>[0]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡p\AgdaUnderscore{}}}\<%
\\
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡p\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Pred}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Pred}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡t\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\end{code}

Unless otherwise quantified, let the metavariable \verb!l! range over types with label kind, let \verb!π! range over predicates, and let \verb!τ! and \verb!υ! range over types:

\begin{code}%
\>[0]\AgdaKeyword{private}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaKeyword{variable}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[8]\AgdaGeneralizable{l}\AgdaSpace{}%
\AgdaGeneralizable{l₁}\AgdaSpace{}%
\AgdaGeneralizable{l₂}\AgdaSpace{}%
\AgdaGeneralizable{l₃}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\<%
\\
%
\>[8]\AgdaGeneralizable{ρ₁}\AgdaSpace{}%
\AgdaGeneralizable{ρ₂}\AgdaSpace{}%
\AgdaGeneralizable{ρ₃}%
\>[19]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\>[8]\AgdaGeneralizable{π₁}\AgdaSpace{}%
\AgdaGeneralizable{π₂}%
\>[17]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Pred}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\>[8]\AgdaGeneralizable{τ}\AgdaSpace{}%
\AgdaGeneralizable{τ₁}\AgdaSpace{}%
\AgdaGeneralizable{τ₂}\AgdaSpace{}%
\AgdaGeneralizable{τ₃}\AgdaSpace{}%
\AgdaGeneralizable{υ}\AgdaSpace{}%
\AgdaGeneralizable{υ₁}\AgdaSpace{}%
\AgdaGeneralizable{υ₂}\AgdaSpace{}%
\AgdaGeneralizable{υ₃}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\end{code}

The rules for predicate equivalence are uninteresting: two predicates are considered equivalent when their component types are equivalent.

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡p\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}eq-≲\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[8]\AgdaGeneralizable{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{υ₁}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{τ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{υ₂}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[8]\AgdaGeneralizable{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{≲}}\AgdaSpace{}%
\AgdaGeneralizable{τ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡p}}%
\>[20]\AgdaGeneralizable{υ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{≲}}\AgdaSpace{}%
\AgdaGeneralizable{υ₂}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}eq-·\AgdaUnderscore{}\textasciitilde{}\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[8]\AgdaGeneralizable{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{υ₁}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{τ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{υ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{τ₃}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{υ₃}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[8]\AgdaGeneralizable{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaGeneralizable{τ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\textasciitilde{}}}\AgdaSpace{}%
\AgdaGeneralizable{τ₃}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡p}}%
\>[25]\AgdaGeneralizable{υ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaGeneralizable{υ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\textasciitilde{}}}\AgdaSpace{}%
\AgdaGeneralizable{υ₃}\<%
\end{code}

The first three rules for type equivalence state that it is an equivalence relation.

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡t\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{eq-refl}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaGeneralizable{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{τ}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{eq-sym}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaGeneralizable{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{τ₂}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaGeneralizable{τ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{τ₁}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{eq-trans}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaGeneralizable{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{τ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{τ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{τ₃}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaGeneralizable{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{τ₃}\<%
\end{code}

Type equivalence is congruent over the total structure of types, including $\lambda$-bindings (hence you may view type normalization as being \emph{call-by-value}). We omit the other eight congruence rules.

\begin{code}%
%
\>[2]\AgdaInductiveConstructor{eq-λ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ}\AgdaSpace{}%
\AgdaBound{υ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaBound{υ}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaBound{υ}\<%
\end{code}
\begin{code}[hide]%
%
\>[2]\AgdaInductiveConstructor{eq-→}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaGeneralizable{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{τ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{υ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{υ₂}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaGeneralizable{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{υ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{τ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{υ₂}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{eq-∀}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaGeneralizable{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{υ}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaInductiveConstructor{`∀}\AgdaSpace{}%
\AgdaGeneralizable{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaInductiveConstructor{`∀}\AgdaSpace{}%
\AgdaGeneralizable{υ}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{eq-μ}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaGeneralizable{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{υ}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaInductiveConstructor{μ}\AgdaSpace{}%
\AgdaGeneralizable{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaInductiveConstructor{μ}\AgdaSpace{}%
\AgdaGeneralizable{υ}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{eq-·}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaGeneralizable{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{υ₁}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{τ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{υ₂}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaGeneralizable{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaGeneralizable{τ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{υ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaGeneralizable{υ₂}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{eq-<\$>}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaBound{υ₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{)\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaBound{υ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaBound{υ₁}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaBound{υ₂}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<\$>}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaBound{υ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<\$>}}\AgdaSpace{}%
\AgdaBound{υ₂}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{eq-⌊⌋}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaGeneralizable{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{υ}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[6]\AgdaOperator{\AgdaInductiveConstructor{⌊}}\AgdaSpace{}%
\AgdaGeneralizable{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌋}}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌊}}\AgdaSpace{}%
\AgdaGeneralizable{υ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌋}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{eq-▹}%
\>[1038I]\AgdaSymbol{:}\<%
\\
\>[.][@{}l@{}]\<[1038I]%
\>[7]\AgdaGeneralizable{l₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{l₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{τ₂}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaSymbol{(}\AgdaGeneralizable{l₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaGeneralizable{τ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{l₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaGeneralizable{τ₂}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{eq-⇒}%
\>[1052I]\AgdaSymbol{:}\<%
\\
\>[.][@{}l@{}]\<[1052I]%
\>[7]\AgdaGeneralizable{π₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡p}}\AgdaSpace{}%
\AgdaGeneralizable{π₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaGeneralizable{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaGeneralizable{τ₂}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaSymbol{(}\AgdaGeneralizable{π₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaGeneralizable{τ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{π₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaGeneralizable{τ₂}\AgdaSymbol{)}\<%
\end{code}

We have one $\eta$-equivalence rule. It is henceforth useful to view the following rules as directed left-to-right, as normal forms are produced on the right-hand side.

\begin{code}%
%
\>[2]\AgdaInductiveConstructor{eq-η}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{)\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{weakenₖ}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{))}\<%
\end{code}

The rules that remain as \emph{computational}---these are precisely the rules we would use to define small-step reduction of types. We begin with the $\beta$-equivalence rule, which states that lambda abstractions applied to arguments are equivalent to their beta reduction.


\begin{code}%
%
\>[2]\AgdaInductiveConstructor{eq-β}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{((}\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{βₖ[}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{]}}\AgdaSymbol{)}\<%
\end{code}

The next two rules specify the computational behavior of mapping over rows. Rule (\verb!eq-<$>ε!) states that mapping over the empty row $\epsilon$ should yield the empty row; rule \verb!eq-▹$! states that mapping over a labeled row should push the left applicand into the body of the row.

\begin{code}%
%
\>[2]\AgdaInductiveConstructor{eq-<\$>ε}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{)\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{F}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<\$>}}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{eq-▹\$}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{l}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{)\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{F}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<\$>}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{F}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{))}\<%
\end{code}

We wish to establish that normal forms of types at row kind are either the empty row \verb!ε! or labeled rows. This is, of course, not the case for types in general. For example, the type \verb!Π · (l ▹ τ)! has row kind when $\tau$ has row kind \verb!R[ κ ]!. In this case, rule \verb!eq-Π▹! pushes the $\Pi$ over the label so that a canonical form is restored.

\begin{code}%
%
\>[2]\AgdaInductiveConstructor{eq-Π▹}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{l}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{Π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{Π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{))}\<%
\end{code}

\Ni The application of $\Pi$ and $\Sigma$ to a type $\tau$ at nested-row kind is in fact just the mapping of $\Pi$ and $\Sigma$ over $\tau$:

\begin{code}%
%
\>[2]\AgdaInductiveConstructor{eq-Π}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{Π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaInductiveConstructor{Π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<\$>}}\AgdaSpace{}%
\AgdaBound{τ}\<%
\end{code}

Likewise to rows, we wish to show that normal forms of types at arrow kind are canonically $\lambda$-bound. However, the type \verb!Π · (l ▹ `λ τ)! has arrow kind! Rule \verb!eq-Πλ! pushes the $\lambda$ outwards in order to restore canonicity and so that application of \verb!Π · (l ▹ `λ τ)! to an applicand is simply $\beta$-reduction.

\begin{code}%
%
\>[2]\AgdaInductiveConstructor{eq-Πλ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{l}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{Π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{Π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{weakenₖ}\AgdaSpace{}%
\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{))}\<%
\end{code}

Finally, in many cases (such as record concatenation and variant branching) it is necessary to reassociate the application $(\Pi\, \rho)\, \tau$ inward so that $\Pi$ (or $\Sigma$) are the outermost syntax. We observe the following reassociation identity:

\begin{code}%
%
\>[2]\AgdaInductiveConstructor{eq-Π-assoc}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaInductiveConstructor{Π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaInductiveConstructor{Π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<?>}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\end{code}

The definition of \verb!_≡t_! concludes by repeating the last four rules, replacing each $\Pi$ with $\Sigma$. As a final aside, it might be thought that we could have rid ourselves of the syntax for mapping by elaborating types at kind \verb!R[ κ₁ → κ₂]!. For example, the type \verb!(l ▹ λ x : κ₁. τ)! could perhaps have its $\lambda$ binding pushed outside to yield \verb!λ x : κ₁. (l ▹ τ)!. However, this would not be kind-preserving (the latter has kind \verb!κ₁ → R[ κ₂ ]!), and therefore such a translation would induce a normalization that does not preserve kinds. We believe it would be possible but complicated to consider a kind-changing translation.

\section{Normal Types}

As is common in other \emph{normalization by evaluation} approaches, we separate \emph{neutral types} from \emph{normal types.} These two definitions are defined mutually inductively with the data type for normal predicates:
\begin{code}[hide]%
\>[0]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{1}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}▹\AgdaUnderscore{}}}\<%
\end{code}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Δ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{KEnv}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Kind}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{NormalPred}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Δ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{KEnv}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Kind}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Kind}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\end{code}

A type is neutral if it is (respectively) (i) a variable, (ii) the application of a variable to an argument, or (iii) the mapping of a normal function type over a neutral row type. Intuitively, neutral forms are forms for which computation is "stuck" waiting on a variable to be substituted for a canonical form. Note that this third neutral form (row mapping) is novel to our development, and, in comparison to application, inverts the normal/neutral expectation of its arguments. It captures the stuck nature of a type such as \verb!(l ▹ λ x. M) <$> ρ!---that is, we are unable to map a function over a type variable.

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{`}%
\>[1262I]\AgdaSymbol{:}\<%
\\
\>[.][@{}l@{}]\<[1262I]%
\>[4]\AgdaSymbol{(}\AgdaBound{α}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{TVar}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}·\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}<\$>\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\<%
\end{code}

A predicate is normal if its component types are each normal.

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{NormalPred}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}·\AgdaUnderscore{}\textasciitilde{}\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSpace{}%
\AgdaBound{ρ₃}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NormalPred}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}≲\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NormalPred}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\end{code}

Because we consider the normalization of types modulo $\eta$-equivalence, we wish to restrict our normal types to $\eta$-long form. This can be done by restricting the construction of normal-neutral types to just ground kind.  This also ensures a canonical form for arrow-kinded normal types, as neutral types at arrow-kind cannot be promoted to normal types. We define a \verb!Ground! predicate on types that maps all non-arrow kinds to the unit type \verb!⊤! and maps the arrow kind to \verb!⊥!. (In other words, \verb!Ground κ! is trivially inhabitable so long as $\kappa \neq \kappa_1 \to \kappa_2$.)

\begin{code}[hide]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Nullary}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{Dec}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Unit}\AgdaSpace{}%
\AgdaKeyword{hiding}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≟\AgdaUnderscore{}}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{public}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Empty}\AgdaSpace{}%
\AgdaKeyword{public}\<%
\end{code}
\begin{code}%
\>[0]\AgdaFunction{Ground}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Kind}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{Ground}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{⊤}\<%
\\
\>[0]\AgdaFunction{Ground}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{⊤}\<%
\\
\>[0]\AgdaFunction{Ground}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\\
\>[0]\AgdaFunction{Ground}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{⊤}\<%
\end{code}

\Ni It is easy to show that this predicate is decidable.

\begin{code}%
\>[0]\AgdaFunction{ground?}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Dec}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Ground}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{ground?}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\<%
\\
\>[0]\AgdaFunction{ground?}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\<%
\\
\>[0]\AgdaFunction{ground?}\AgdaSpace{}%
\AgdaSymbol{(\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{no}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaSymbol{())}\<%
\\
\>[0]\AgdaFunction{ground?}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{yes}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\<%
\end{code}

Now we may restrict the \verb!ne! constructor to promoting just neutral types at ground kind by adding the (implicit) requirement that \verb!ne! only be used when \verb!Ground κ! is satisfied. To make this evidence easy to populate when $\kappa$ is known, we employ a well-known proof-by-reflection trick (see \citet{plfa22}) and require evidence of the form \verb!True (ground? κ)!.

\begin{code}[hide]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Nullary.Decidable}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{True}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{toWitness}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{fromWitness}\AgdaSymbol{)}\<%
\end{code}
\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{ground}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{True}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{ground?}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
\>[0]\<%
\end{code}

Likewise, to ensure canonical forms of rows, we restrict \verb!Π! and \verb!Σ! to formation at kind \verb!★! and \verb!L!. The constructors for record types are given below.

\begin{code}%
\>[0][@{}l@{\AgdaIndent{1}}]%
\>[2]\AgdaInductiveConstructor{Π}%
\>[5]\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{ΠL}%
\>[6]\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\<%
\end{code}

The rest of the \verb!NormalType! syntax is identical to the \verb!Type! syntax with the exception that we remove the \verb!`! constructor for variables and \verb!Π! and \verb!Σ! constructors at arbitrary kind. We choose not to omit this syntax, as our proofs of canonicity follow from knowing the totality of \verb!NormalType! constructors.

\begin{code}%
%
\>[2]\AgdaComment{--\ Fω}\<%
\\
%
\>[2]\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}`→\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{`∀}%
\>[8]\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{\{}\AgdaBound{κ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Kind}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{μ}%
\>[8]\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{★}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaComment{--\ Qualified\ types}\<%
\\
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}⇒\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{π}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalPred}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaComment{--\ Rω}\<%
\\
%
\>[2]\AgdaInductiveConstructor{ε}%
\>[1499I]\AgdaSymbol{:}\<%
\\
\>[.][@{}l@{}]\<[1499I]%
\>[4]\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{}▹\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{lab}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Label}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaOperator{\AgdaInductiveConstructor{⌊\AgdaUnderscore{}⌋}}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\<%
\\
%
\>[2]\AgdaInductiveConstructor{Σ}%
\>[5]\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaInductiveConstructor{ΣL}%
\>[6]\AgdaSymbol{:}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[4]\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\<%
\end{code}

\subsubsection{Renaming}
We define renaming over \verb!NormalType!s in the same fashion as defined over \verb!Type!s. Note that we use the suffix \verb!ₖNF! now to denote functions which operate on \verb!NormalType! syntax. Definitions are unsurprising and omitted.

\begin{code}%
\>[0]\AgdaFunction{renₖNE}%
\>[11]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Renamingₖ}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
\>[0]\AgdaFunction{renₖNF}%
\>[11]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Renamingₖ}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
\>[0]\AgdaFunction{weakenₖNF}%
\>[11]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\<%
\\
\>[0]\AgdaFunction{weakenₖNE}%
\>[11]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\<%
\end{code}
\begin{code}[hide]%
\>[0]\AgdaFunction{renPredₖNF}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Renamingₖ}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{NormalPred}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{NormalPred}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{renₖNE}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{renₖNE}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{renₖNE}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ₂}\<%
\\
\>[0]\AgdaFunction{renₖNE}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{F}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<\$>}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<\$>}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNE}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}%
\>[13]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\<%
\\
\>[0]\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{g}\AgdaSymbol{\})}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNE}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{g}\AgdaSymbol{\}}\<%
\\
\>[0]\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{l}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{liftₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{renPredₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ}\<%
\\
\>[0]\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`∀}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{`∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{liftₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{μ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{μ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{lab}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{lab}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌊}}\AgdaSpace{}%
\AgdaBound{ℓ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌋}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌊}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{ℓ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌋}}\<%
\\
\>[0]\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{Π}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{Π}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ΠL}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ΠL}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{Σ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{Σ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ΣL}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ΣL}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{renPredₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\textasciitilde{}}}\AgdaSpace{}%
\AgdaBound{ρ₃}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{ρ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\textasciitilde{}}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{ρ₃}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{renPredₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{≲}}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{ρ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{≲}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{weakenₖNF}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaInductiveConstructor{S}\<%
\\
\>[0]\AgdaFunction{weakenₖNE}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{renₖNE}\AgdaSpace{}%
\AgdaInductiveConstructor{S}\<%
\end{code}


\subsection{Properties of normal types}
We use Agda to confirm the desired canonicity properties. First, we wish for arrow kinds to be canonically formed by $\lambda$-abstractions. This can be shown easily by induction on arrow-kinded \verb!f!.

\begin{code}[hide]%
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Sum}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{Sum}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}⊎\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}or\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₁}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaInductiveConstructor{left}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{inj₂}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaInductiveConstructor{right}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Sum}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}or\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{left}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{right}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{Product}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{renaming}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{proj₁}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaField{fst}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{proj₂}\AgdaSpace{}%
\AgdaSymbol{to}\AgdaSpace{}%
\AgdaField{snd}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Product}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}×\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{fst}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{snd}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{Σ-syntax}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{∃}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{∃-syntax}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaKeyword{public}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Binary.PropositionalEquality}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{Eq}\AgdaSpace{}%
\AgdaKeyword{public}\<%
\end{code}
\begin{code}%
\>[0]\AgdaFunction{arrow-canonicity}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{∃[}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{arrow-canonicity}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaBound{f}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}

Second, we wish for types at row kind to be canonically either (i) a labeled type \verb!(l ▹ τ)!, (ii) a neutral type, or (iii) the empty row \verb!ε!. The \verb!row-canonicity! lemma below states precisely this. Note that we permit row-kinded types to be neutral because we do not $\eta$-expand arrow-kinded rows. Recall our discussion above that such an expansion would not be kind-preserving. This means arrow-kinded rows must be permitted to be canonically neutral.

\begin{code}%
\>[0]\AgdaFunction{row-canonicity}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{∃[}\AgdaSpace{}%
\AgdaBound{l}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{ρ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{))))}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{or}}\<%
\\
%
\>[2]\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{or}}\<%
\\
%
\>[2]\AgdaBound{ρ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\<%
\\
\>[0]\AgdaFunction{row-canonicity}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{left}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{row-canonicity}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{right}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{left}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{))}\<%
\\
\>[0]\AgdaFunction{row-canonicity}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{right}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{right}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{)}\<%
\end{code}
\subsection{Type embeddings}

We establish an embedding back from normal types to types below. The embedding is written \verb!⇑! because its type is converse to our definition of normalization, written \verb!⇓!. We will show in later sections precisely that \verb!⇑! is right-inverse to \verb!⇓!.

\begin{code}%
\>[0]\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
\>[0]\AgdaFunction{⇑NE}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
\>[0]\AgdaFunction{⇑Pred}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalPred}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Pred}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\end{code}

Much of the embedding is defined by using like-for-like constructors and recursing on the subdata.

\begin{code}%
\>[0]\AgdaFunction{⇑NE}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaFunction{⇑NE}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑NE}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{⇑NE}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{F}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<\$>}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{F}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<\$>}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑NE}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{⇑Pred}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\textasciitilde{}}}\AgdaSpace{}%
\AgdaBound{ρ₃}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{ρ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\textasciitilde{}}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{ρ₃}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{⇑Pred}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{≲}}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{ρ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{≲}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}%
\>[6]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\<%
\\
\>[0]\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⇑NE}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{l}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{τ₂}\<%
\\
\>[0]\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`∀}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{`∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{μ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{μ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{lab}\AgdaSpace{}%
\AgdaBound{l}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{lab}\AgdaSpace{}%
\AgdaBound{l}\<%
\\
\>[0]\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌊}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌋}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌊}}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌋}}\<%
\\
\>[0]\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑Pred}\AgdaSpace{}%
\AgdaBound{π}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\end{code}

\Ni An exception is made for record and variant constructors, which we must reconstruct as applications:

\begin{code}%
\>[0]\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{Π}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{Π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ΠL}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{Π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{Σ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{Σ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{ΣL}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{Σ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}

\section{Semantic types}

We next define \verb!SemType Δ κ!, the semantic interpretation of types. \verb!SemType!s are defined by induction on the kind $\kappa$ and mutually-recursively with \verb!KripkeFunction!s, the interpretation of type functions.

\begin{code}[hide]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Maybe}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{Maybe}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{nothing}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaKeyword{public}\<%
\end{code}
\begin{code}%
\>[0]\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{KEnv}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Kind}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{KripkeFunction}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{KEnv}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Kind}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Kind}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\end{code}

Type functions are interpreted as Kripke function spaces because they must permit arbitrary and intermediate renaming. That is, they are functions at "any world."
\begin{code}%
\>[0]\AgdaFunction{KripkeFunction}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSpace{}%
\AgdaBound{κ₂}\AgdaSpace{}%
\AgdaSymbol{=}%
\>[27]\AgdaSymbol{(∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Renamingₖ}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaBound{κ₂}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{κ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{KripkeFunction}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSpace{}%
\AgdaBound{κ₂}\<%
\end{code}

\Ni We interpret \verb!★! and \verb!L! kinded types as their normal forms.

\begin{code}%
\>[0]\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\<%
\\
\>[0]\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\<%
\end{code}

\Ni We interpret rows as either \verb!nothing! (the empty row), \verb!just (left x)! for neutral \verb!x!, or \verb!just (right (l , τ))! for normal \verb!l! and \verb!τ!. These cases correspond precisely to the three canonical forms of types with row kind.

\begin{code}%
\>[0]\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{Maybe}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{((}\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{or}}\<%
\\
%
\>[2]\AgdaSymbol{(}\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{))}\<%
\end{code}

\subsection{Renaming \& substitution}
Renaming is defined over semantic types in an obvious fashion. Definitions are omitted except in the functional case.


\begin{code}%
\>[0]\AgdaFunction{renSem}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Renamingₖ}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
\>[0]\AgdaFunction{weakenSem}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\<%
\end{code}

\Ni Because \Rome functions are interpreted into Kripke function spaces, renaming of arrow-kinded types is simply composition by the function's renaming.

\begin{code}[hide]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Function}\<%
\end{code}
\begin{code}%
\>[0]\AgdaFunction{renKripke}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Renamingₖ}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{KripkeFunction}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{KripkeFunction}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\<%
\\
\>[0]\AgdaFunction{renKripke}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{ρ'}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ'}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{renSem}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{renKripke}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{F}\<%
\end{code}



\begin{code}[hide]%
\>[0]\AgdaFunction{renSem}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ}\<%
\\
\>[0]\AgdaFunction{renSem}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ}\<%
\\
\>[0]\AgdaFunction{renSem}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{left}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{left}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNE}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{))}\<%
\\
\>[0]\AgdaFunction{renSem}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{right}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)))}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{right}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNF}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{renSem}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{))}\<%
\\
\>[0]\AgdaFunction{renSem}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaInductiveConstructor{nothing}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{nothing}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{weakenSem}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{renSem}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{Δ₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaBound{τ}\<%
\end{code}

\subsection{Normalization by evaluation}

Our \emph{normalization by evaluation} proceeds in a standard fashion. We will define \verb!reflect!, which maps neutral types to semantic types, and \verb!reify!, which maps semantic types to normal types. We then write an evaluator that takes a \verb!Type! into the semantic domain. During this process, function applications (and other forms of computation) are reduced. We finally reify the semantic type back to a normal form.

Reflection and reification are defined mutually recursively. We define the type synonym \verb!reifyKripke!, the reification of types at arrow kind, for repeated use later.

\begin{code}%
\>[0]\AgdaFunction{reflect}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaBound{κ}\<%
\\
\>[0]\AgdaFunction{reify}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaBound{κ}\<%
\\
\>[0]\AgdaFunction{reifyKripke}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{KripkeFunction}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{)}\<%
\end{code}

Reflection of neutral types at ground kind leaves the type undisturbed. 
\begin{code}%
\>[0]\AgdaFunction{reflect}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{τ}%
\>[29]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaBound{τ}\<%
\\
\>[0]\AgdaFunction{reflect}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{τ}%
\>[29]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaBound{τ}\<%
\\
\>[0]\AgdaFunction{reflect}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{τ}%
\>[29]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{left}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\end{code}

\Ni Reflection of neutral types at arrow kind must be $\eta$-expanded into a Kripke function. Note here that is necessary to reify the input \verb!v! back to a normal type.

\begin{code}%
\>[0]\AgdaFunction{reflect}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{τ}%
\>[29]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{reflect}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖNE}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{reify}\AgdaSpace{}%
\AgdaBound{v}\AgdaSymbol{)}\<%
\end{code}

\Ni Reification similarly leaves ground types undisturbed. Semantic types at $\star$ and label kind are already in normal form; semantic types at row kind must be translated from their semantic constructors to their \verb!NormalType! constructors.

\begin{code}%
\>[0]\AgdaFunction{reify}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{τ}\<%
\\
\>[0]\AgdaFunction{reify}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{τ}\<%
\\
\>[0]\AgdaFunction{reify}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{left}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ne}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaFunction{reify}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{right}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)))}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reify}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{reify}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaInductiveConstructor{nothing}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\<%
\end{code}

Semantic functions must be reified from Agda functions back into \verb!NormalType! syntax. This is done by reifying the application of semantic function \verb!F! to the reflection of the $\eta$-expanded variable \verb!` Z!.

\begin{code}%
\>[0]\AgdaFunction{reify}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{reifyKripke}\AgdaSpace{}%
\AgdaBound{F}\<%
\\
\>[0]\AgdaFunction{reifyKripke}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reify}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{F}\AgdaSpace{}%
\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reflect}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{))))}\<%
\end{code}

Observe that neutral types can be forced into $\eta$-long form simply by composing reification and reflection. This will prove helpful later, as the neutral type former \verb!ne! has the same type except restricted to ground kind, but we will need to be able to promote from neutral to normal type at \emph{all} kinds.

\begin{code}%
\>[0]\AgdaFunction{η-norm}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
\>[0]\AgdaFunction{η-norm}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{reify}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaFunction{reflect}\<%
\end{code}

Towards writing an evaluator, we define a semantic environment as a function mapping type variables to semantic types.

\begin{code}%
\>[0]\AgdaFunction{Env}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{KEnv}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{KEnv}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{Env}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{TVar}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaBound{κ}\<%
\end{code}

\Ni Environment extension and lifting can be written in a straightforward manner.
\begin{code}%
\>[0]\AgdaFunction{extende}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Env}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{V}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Env}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\<%
\\
\>[0]\AgdaFunction{lifte}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Env}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Env}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\<%
\end{code}

\begin{code}[hide]%
\>[0]\AgdaFunction{extende}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaBound{V}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}%
\>[18]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{V}\<%
\\
\>[0]\AgdaFunction{extende}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaBound{V}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{S}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{lifte}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{η}%
\>[23]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{extende}\AgdaSpace{}%
\AgdaFunction{η'}\AgdaSpace{}%
\AgdaFunction{V}\AgdaSpace{}%
\AgdaComment{--\ extende\ η'\ V}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{where}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{η'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Env}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{)}\<%
\\
%
\>[4]\AgdaFunction{η'}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ'}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{weakenSem}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{Δ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ'}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ₂}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{\})}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{η}\AgdaSpace{}%
\AgdaBound{v}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[4]\AgdaFunction{V}%
\>[7]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,,}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{κ}\<%
\\
%
\>[4]\AgdaFunction{V}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{reflect}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaInductiveConstructor{Z}\AgdaSymbol{)}\<%
\end{code}

The identity environment now maps type variables to semantic types. Unlike in \citet{ChapmanKNW19}, this environment can no longer be truly said to be an identity: type variables are de facto put into $\eta$-long form during reflection. However this change is mandatory for normalization, so we cannot define an environment that does not.

\begin{code}%
\>[0]\AgdaFunction{idEnv}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Env}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\<%
\\
\>[0]\AgdaFunction{idEnv}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{reflect}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaInductiveConstructor{`}\<%
\end{code}

\subsection{Helping evaluation}

In aid of writing an evaluator, we found it helpful to develop \emph{semantic} notions of the syntax introduced by \Rome. For example, we define a type synonym for application, which is simply Agda application within the identity renaming.

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}·V\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\<%
\\
\>[0]\AgdaBound{F}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{·V}}\AgdaSpace{}%
\AgdaBound{V}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaFunction{id}\AgdaSpace{}%
\AgdaBound{V}\<%
\end{code}

We can further define the constructors of the three canonical forms of row-kinded types:

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}▹V\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}▹V\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{ℓ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{right}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ℓ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{))}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{ne-R}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
\>[0]\AgdaFunction{ne-R}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{∘}}\AgdaSpace{}%
\AgdaInductiveConstructor{left}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{εV}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
\>[0]\AgdaFunction{εV}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{nothing}\<%
\end{code}



\Ni The definition of semantic row mapping varies by the shape of the row \verb!V! over which we are lifting. If \verb!V! is neutral, so too must the mapping of \verb!F! over !V! be neutral. Hence we reify \verb!F! to normal form and leave its mapping in neutral form. If \verb!V! is a labeled row \verb!(l ▹ τ)!, we push the application of \verb!F! over \verb!τ!. Finally, if \verb!V! is the empty row, its mapping is empty.

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}<\$>V\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}<\$>V\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{left}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{ne-R}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reifyKripke}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<\$>}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}<\$>V\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{right}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)))}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{▹V}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{F}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{·V}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{))}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}<\$>V\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaInductiveConstructor{nothing}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{εV}\<%
\end{code}

Although the flap operator \verb!_<?>_! is expressible as a special case of row mapping, we nevertheless find it a useful abstraction to express as a semantic function. It is defined below in terms of semantic row mapping; we find it likewise helpful to give a type synonym \verb!apply! to the left hand side of this equation.

\begin{code}%
\>[0]\AgdaFunction{apply}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{apply}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{·V}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renSem}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{infixr}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}<?>V\AgdaUnderscore{}}}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}<?>V\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
\>[0]\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<?>V}}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{apply}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<\$>V}}\AgdaSpace{}%
\AgdaBound{f}\<%
\end{code}

Much of the latent computation in \Rome occurs under an outermost $\Pi$ and $\Sigma$ syntax. To this end, we chose to represent $\Pi$ and $\Sigma$ as arrow-kinded type-constants---meaning they will evaluate into Agda functions. This provides an opportunity to concisely abstract their reduction logic. We define a semantic combinator for the $\Pi$ type constant below. The first two equations state that record types at $\star$ and label kind may be formed provided normal bodies; The third equation pushes the $\lambda$-binding of $F$ outside of the record type; the fourth equation states that application \emph{is} mapping at nested row kind.

\begin{code}%
\>[0]\AgdaFunction{ΠV}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
\>[0]\AgdaFunction{ΠV}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{Π}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reify}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{ΠV}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ΠL}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reify}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{ΠV}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{ΠV}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renSem}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<?>V}}\AgdaSpace{}%
\AgdaBound{v}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{ΠV}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{ΠV}\AgdaSpace{}%
\AgdaBound{v}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<\$>V}}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code} 

\Ni We can turn the semantic helper \verb!ΠV! into a true Kripke function easily:

\begin{code}%
\>[0]\AgdaFunction{Π-Kripke}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{KripkeFunction}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
\>[0]\AgdaFunction{Π-Kripke}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{ΠV}\AgdaSpace{}%
\AgdaBound{v}\<%
\end{code}
\begin{code}[hide]%
\>[0]\AgdaFunction{ΣV}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
\>[0]\AgdaFunction{ΣV}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{Σ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reify}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{ΣV}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{ΣL}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reify}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{ΣV}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{ΣV}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renSem}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<?>V}}\AgdaSpace{}%
\AgdaBound{v}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{ΣV}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{ΣV}\AgdaSpace{}%
\AgdaBound{v}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<\$>V}}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaFunction{Σ-Kripke}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{KripkeFunction}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
\>[0]\AgdaFunction{Σ-Kripke}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{ΣV}\AgdaSpace{}%
\AgdaBound{v}\<%
\end{code}

\Ni We omit the definitions of \verb!ΣV! and \verb!Σ-Kripke!, as they are identical modulo the use of \verb!Π! constants.

\subsection{Evaluation}

We now write an evaluator that translates \verb!Type!s to semantic types; that is, translating syntactic forms to the semantic domain. A normalizer composes reification with evaluation. One can see this in the definition of \verb!evalPred!, the predicate normalizer. (Predicates must be fully normalized as they do not have a semantic image.)

\begin{code}%
\>[0]\AgdaFunction{eval}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Env}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
\>[0]\AgdaFunction{evalPred}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Pred}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Env}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{NormalPred}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{evalPred}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\textasciitilde{}}}\AgdaSpace{}%
\AgdaBound{ρ₃}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{reify}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaBound{η}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaFunction{reify}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSpace{}%
\AgdaBound{η}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\textasciitilde{}}}\AgdaSpace{}%
\AgdaFunction{reify}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{ρ₃}\AgdaSpace{}%
\AgdaBound{η}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{evalPred}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{≲}}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{reify}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaBound{η}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{≲}}\AgdaSpace{}%
\AgdaFunction{reify}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSpace{}%
\AgdaBound{η}\AgdaSymbol{)}\<%
\end{code}

Evaluation is defined by induction over the type structure. The first three cases have types which may occur at any kind. The variable case simply uses the environment to perform a lookup; application defers to our semantic combinator \verb!_·V_!; and evaluation of arrow types is defined recursively.

\begin{code}%
\>[0]\AgdaFunction{eval}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
\>[0]\AgdaFunction{eval}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaBound{η}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{·V}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaBound{η}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{eval}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaBound{η}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaBound{η}\AgdaSymbol{)}\<%
\end{code}

\Ni The next four cases are for types that only occur at kind $\star$. The qualified type and label singleton cases proceed by recursion over the type structure. For \verb!`∀!-bound types, we must lift the environment $\eta$ appropriately. In the $\mu$ case, $\tau$ has kind $\star \to \star$ and so its evaluation must be reified back to \verb!NormalType!.

\begin{code}%
\>[0]\AgdaFunction{eval}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{π}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{evalPred}\AgdaSpace{}%
\AgdaBound{π}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⇒}}\AgdaSpace{}%
\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaBound{η}\<%
\\
\>[0]\AgdaFunction{eval}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌊}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌋}}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌊}}\AgdaSpace{}%
\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌋}}\<%
\\
\>[0]\AgdaFunction{eval}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`∀}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{`∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{lifte}\AgdaSpace{}%
\AgdaBound{η}\AgdaSymbol{))}\<%
\\
\>[0]\AgdaFunction{eval}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{μ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{μ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reify}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaBound{η}\AgdaSymbol{))}\<%
\end{code}


\Ni There is only one type with exclusively label kind. Its definition is unsurprising (it houses only a \verb!String! label).

\begin{code}%
\>[0]\AgdaFunction{eval}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{lab}\AgdaSpace{}%
\AgdaBound{l}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{lab}\AgdaSpace{}%
\AgdaBound{l}\<%
\end{code}


\Ni We evaluate $\lambda$-bound functions by evaluating their bodies in environments extended by the meaning their input $v$. Note that we are building a Kripke function and so \verb!ρ! is a renaming from $\Delta_1$ to $\Delta_2$ and \verb!v! is an input of type \verb!SemType Δ₂ κ₁!.

\begin{code}%
\>[0]\AgdaFunction{eval}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{`λ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{extende}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{v'}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{renSem}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{η}\AgdaSpace{}%
\AgdaBound{v'}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaBound{v}\AgdaSymbol{)}\<%
\end{code}

\Ni Lastly, we define evaluation over the row-kinded constants and operators. As $\Pi$ and $\Sigma$ are represented as type constants in the \verb!Type! syntax, they translate directly to the Kripke functions we defined for $\Pi$ and $\Sigma$ as semantic helpers. Likewise, the row mapping and labeled-row cases are interpreted immediately and desirably by their semantic helpers.

\begin{code}%
\>[0]\AgdaFunction{eval}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaInductiveConstructor{Π}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Π-Kripke}\<%
\\
\>[0]\AgdaFunction{eval}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaInductiveConstructor{Σ}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Σ-Kripke}\<%
\\
\>[0]\AgdaFunction{eval}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{<\$>}}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{η}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{<\$>V}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{η}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{eval}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{l}\AgdaSpace{}%
\AgdaBound{η}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{▹V}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaBound{η}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{eval}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{εV}\<%
\end{code}

Finally, we define a normalizer as the reification of evaluation.

\begin{code}%
\>[0]\AgdaFunction{⇓}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
\>[0]\AgdaFunction{⇓}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{reify}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaFunction{idEnv}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{⇓NE}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\<%
\\
\>[0]\AgdaFunction{⇓NE}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{reify}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑NE}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{idEnv}\AgdaSymbol{)}\<%
\end{code}

\section{Metatheory}

% AH> We also desire normalization algorithm because you can't reason over an equivalence relation.
% We desire a normalization algorithm to remove the need for explicit type conversion proofs in terms: two types are equal iff they reduce to the same normal form, and so a normalization algorithm effectively gives a decision procedure for type equivalence. 

\InlineOn{}
We now verify that \verb!⇓! indeed behaves as a normalization function ought to. We first show that normalization is \emph{stable}. Stability states that embedding \verb!⇑! is a right-inverse to normalization \verb!⇓!, or, in categorical terms, that \verb!⇓! is a split-monomorphism. The proof is by induction over \verb!τ!.

\begin{code}%
\>[0]\AgdaFunction{stability}%
\>[12]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⇓}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{τ}\<%
\end{code}
\begin{code}[hide]%
\>[0]\AgdaFunction{stability}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{bot}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\end{code}

\Ni It is desirable that a normalization algorithm adheres to this property, as it states effectively that there is "no more work" to be done by re-normalization. Both idempotency and surjectivity are implied.

\begin{code} %
\>[0]\AgdaFunction{idempotency}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇓}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇓}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{))))}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇓}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{idempotency}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaKeyword{rewrite}\AgdaSpace{}%
\AgdaFunction{stability}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇓}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{surjectivity}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NormalType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{∃[}\AgdaSpace{}%
\AgdaBound{υ}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇓}\AgdaSpace{}%
\AgdaBound{υ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{surjectivity}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaFunction{stability}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{)}\<%
\end{code}

It next falls upon us to verify that this normalization algorithm indeed respects our syntactic account of type equivalence. How we do so is fairly routine to other normalization-by-evaluation efforts. We show that the algorithm is complete with respect to syntactic type equivalence:

\begin{code}%
\>[0]\AgdaFunction{completeness}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⇓}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaFunction{⇓}\AgdaSpace{}%
\AgdaBound{τ₂}\<%
\end{code}
\begin{code}[hide]%
\>[0]\AgdaFunction{completeness}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{bot}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\end{code}

\Ni Completeness here states that equivalent types normalize to the same types. Soundness states that every type is equivalent to its normalization.

\begin{code}%
\>[0]\AgdaFunction{soundness}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇓}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\end{code}
\begin{code}[hide]%
\>[0]\AgdaFunction{soundness}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{bot}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\end{code}

Soundness implies the converse of \verb!completeness!, hence we may conclude that \verb!τ₁ ≡t τ₂! iff \verb!⇓ τ₁ ≡ ⇓ τ₂!.

\begin{code}%
\>[0]\AgdaFunction{completeness⁻¹}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⇓}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaFunction{⇓}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaBound{τ₂}\<%
\\
\>[0]\AgdaFunction{completeness⁻¹}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaBound{eq}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{eq-trans}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaFunction{soundness}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaSymbol{(}\AgdaInductiveConstructor{eq-trans}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(}\AgdaFunction{inst}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{cong}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{eq}\AgdaSymbol{))}\<%
\\
%
\>[2]\AgdaSymbol{(}\AgdaInductiveConstructor{eq-sym}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{soundness}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)))}\<%
\\
%
\>[2]\AgdaKeyword{where}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaFunction{inst}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{υ₁}\AgdaSpace{}%
\AgdaBound{υ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{υ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{υ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{υ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaBound{υ₂}\<%
\\
%
\>[4]\AgdaFunction{inst}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{eq-refl}\<%
\end{code}

\subsection{A logical relation for completeness}
We will prove completeness using a logical relation on semantic types. We would like to be able to equate semantic types, but they prove to be "too large": in particular, our definition of Kripke functions permit functions which may not respect composition of renaming. The solution is to reason about semantic types modulo a partial equivalence relation (PER) that both respects renamings (which we call \emph{uniformity}) and also equates functions extensionally. We write \verb!τ₁ ≋ τ₂! to denote that the semantic types \verb!τ₁! and \verb!τ₂! are equivalent modulo this relation. For clarity, we give names to the two properties (\emph{uniformity} and \emph{point equality}) we desire related types to hold, and define them mutually recursively.

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≋\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{PointEqual-≋}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{F}\AgdaSpace{}%
\AgdaBound{G}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{KripkeFunction}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSpace{}%
\AgdaBound{κ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{Uniform}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[11]\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{KripkeFunction}\AgdaSpace{}%
\AgdaBound{Δ}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSpace{}%
\AgdaBound{κ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\end{code}


\Ni We define \verb!_≋_! recursively over the kind of its equated types. In the first two cases, \verb!τ₁! and \verb!τ₂! are normal types, which we equate propositionally. In the third case, we assert that Kripke functions \verb!F! and \verb!G! are uniform and point-equal to one another. Uniformity asserts a certain commutativity of renaming: you may either rename the result of applying \verb!F! to \verb!V₁!, or you may rename \verb!F! before applying it to a renamed input. point equality on Kripke functions \verb!F! and \verb!G! asserts that \verb!F! and \verb!G! take related inputs to related outputs. The latter property is what one should expect of a logical relation; the former property can be attributed to \citet{ChapmanKNW19}, who in turn attribute \citet{AllaisBM13}. 

\begin{code}%
\>[0]\AgdaFunction{Uniform}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaBound{Δ₃}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Renamingₖ}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Renamingₖ}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaBound{Δ₃}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{V₁}\AgdaSpace{}%
\AgdaBound{V₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[2]\AgdaBound{V₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaBound{V₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renSem}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{F}\AgdaSpace{}%
\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaBound{V₁}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renKripke}\AgdaSpace{}%
\AgdaBound{ρ₁}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renSem}\AgdaSpace{}%
\AgdaBound{ρ₂}\AgdaSpace{}%
\AgdaBound{V₂}\AgdaSymbol{))}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{PointEqual-≋}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaBound{G}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Renamingₖ}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{V₁}\AgdaSpace{}%
\AgdaBound{V₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[2]\AgdaBound{V₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaBound{V₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{V₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaBound{G}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{V₂}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≋\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{τ₂}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≋\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{τ₂}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≋\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaBound{G}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{Uniform}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaFunction{Uniform}\AgdaSpace{}%
\AgdaBound{G}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaFunction{PointEqual-≋}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaBound{G}\<%
\end{code}

The last six cases are over row kinded semantic types. The first case states that neutral rows must be propositionally equal; the second states that two rows of the form $(\Row {l_1} {\tau_1})$ and $(\Row {l_2} {\tau_2})$ are related iff their labels are equal and their types are related. The third case states that the empty row is related to itself (which is always true). All other cases are nonsensical, and so are set to $\bot$.

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≋\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{left}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{left}\AgdaSpace{}%
\AgdaBound{y}\AgdaSymbol{))}%
\>[67]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{y}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≋\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{right}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSymbol{)))}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{right}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l₂}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{)))}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{l₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{l₂}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaBound{τ₂}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≋\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaInductiveConstructor{nothing}\AgdaSpace{}%
\AgdaInductiveConstructor{nothing}%
\>[67]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{⊤}\<%
\\
\>[0]\AgdaCatchallClause{\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≋\AgdaUnderscore{}}}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaSymbol{\{}}\AgdaCatchallClause{\AgdaArgument{κ}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaSymbol{=}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaOperator{\AgdaInductiveConstructor{R[}}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaBound{κ}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaOperator{\AgdaInductiveConstructor{]}}}\AgdaCatchallClause{\AgdaSymbol{\}}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaSymbol{(}}\AgdaCatchallClause{\AgdaInductiveConstructor{just}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaSymbol{\AgdaUnderscore{})}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaSymbol{(}}\AgdaCatchallClause{\AgdaInductiveConstructor{just}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaSymbol{\AgdaUnderscore{})}}%
\>[67]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\\
\>[0]\AgdaCatchallClause{\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≋\AgdaUnderscore{}}}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaSymbol{\{}}\AgdaCatchallClause{\AgdaArgument{κ}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaSymbol{=}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaOperator{\AgdaInductiveConstructor{R[}}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaBound{κ}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaOperator{\AgdaInductiveConstructor{]}}}\AgdaCatchallClause{\AgdaSymbol{\}}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaSymbol{(}}\AgdaCatchallClause{\AgdaInductiveConstructor{just}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaSymbol{\AgdaUnderscore{})}}\AgdaSpace{}%
\AgdaCatchallClause{\AgdaInductiveConstructor{nothing}}%
\>[67]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≋\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaInductiveConstructor{nothing}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})}%
\>[67]\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{⊥}\<%
\end{code}


\subsubsection{Properties of the completeness relation}

The completeness relation forms a \emph{partial equivalence relation} (PER). As uniformity is a unary property, it follows quickly that \verb!_≋_! cannot be reflexive, but a limited form of reflexivity does hold: provided that \verb!V! is related to \emph{some} other \verb!V'!, it relates to itself. The other properties (symmetry and transitivity) are simple enough to show. We introduce two helpers, \verb!refl-≋ₗ! and \verb!refl-≋ᵣ! to describe left and right reflexive projections.

\begin{code}%
\>[0]\AgdaFunction{refl-≋ₗ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{V₁}\AgdaSpace{}%
\AgdaBound{V₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{\}}%
\>[38]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{V₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaBound{V₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{V₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaBound{V₁}\<%
\\
\>[0]\AgdaFunction{refl-≋ᵣ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{V₁}\AgdaSpace{}%
\AgdaBound{V₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{\}}%
\>[38]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{V₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaBound{V₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{V₂}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaBound{V₂}\<%
\\
\>[0]\AgdaFunction{sym-≋}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{\}}%
\>[37]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaBound{τ₁}\<%
\\
\>[0]\AgdaFunction{trans-≋}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaBound{τ₃}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaBound{τ₃}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaBound{τ₃}\<%
\end{code}
\begin{code}[hide]%
\>[0]\AgdaFunction{sym-≋}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{\}}%
\>[15]\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
\>[0]\AgdaFunction{sym-≋}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSymbol{\}}%
\>[15]\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
\>[0]\AgdaFunction{sym-≋}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSymbol{\}}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{\{}\AgdaBound{F}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{G}\AgdaSymbol{\}}\<%
\\
%
\>[2]\AgdaSymbol{(}\AgdaBound{Unif-F}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Unif-G}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{Ext}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[5]\AgdaBound{Unif-G}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}%
\>[15]\AgdaBound{Unif-F}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{V₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{V₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{z}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{sym-≋}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Ext}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{sym-≋}\AgdaSpace{}%
\AgdaBound{z}\AgdaSymbol{)))}\<%
\\
\>[0]\AgdaFunction{sym-≋}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{left}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{left}\AgdaSpace{}%
\AgdaBound{x₁}\AgdaSymbol{)\}}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{sym}\AgdaSpace{}%
\AgdaBound{q}\<%
\\
\>[0]\AgdaFunction{sym-≋}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{nothing}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{nothing}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\<%
\\
\>[0]\AgdaFunction{sym-≋}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{right}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSymbol{))\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{right}\AgdaSpace{}%
\AgdaSymbol{(\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{))\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{sym-≋}\AgdaSpace{}%
\AgdaBound{q}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{refl-≋ₗ}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{trans-≋}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{sym-≋}\AgdaSpace{}%
\AgdaBound{q}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{refl-≋ᵣ}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{refl-≋ₗ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{sym-≋}\AgdaSpace{}%
\AgdaBound{q}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{trans-≋}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{q₁}\AgdaSpace{}%
\AgdaBound{q₂}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{trans}\AgdaSpace{}%
\AgdaBound{q₁}\AgdaSpace{}%
\AgdaBound{q₂}\<%
\\
\>[0]\AgdaFunction{trans-≋}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{q₁}\AgdaSpace{}%
\AgdaBound{q₂}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{trans}\AgdaSpace{}%
\AgdaBound{q₁}\AgdaSpace{}%
\AgdaBound{q₂}\<%
\\
\>[0]\AgdaFunction{trans-≋}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{F}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{G}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{H}\AgdaSymbol{\}}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaSymbol{(}\AgdaBound{unif-F}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{unif-G}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{Ext-F-G}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{unif-G'}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{unif-H}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{Ext-G-H}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaBound{unif-F}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\<%
\\
%
\>[4]\AgdaBound{unif-H}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\<%
\\
%
\>[4]\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{q}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{trans-≋}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Ext-F-G}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{q}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{Ext-G-H}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{refl-≋ₗ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{sym-≋}\AgdaSpace{}%
\AgdaBound{q}\AgdaSymbol{)))}\<%
\\
\>[0]\AgdaFunction{trans-≋}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{left}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{left}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{left}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{})\}}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\\
\>[0]\AgdaFunction{trans-≋}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{nothing}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{nothing}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{nothing}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\<%
\\
\>[0]\AgdaFunction{trans-≋}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{right}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSymbol{))\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{right}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDottedPattern{\AgdaSymbol{.}}\AgdaDottedPattern{\AgdaBound{l}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSymbol{))\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{right}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDottedPattern{\AgdaSymbol{.}}\AgdaDottedPattern{\AgdaBound{l}}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{τ₃}\AgdaSymbol{))\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{q₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{q₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{trans-≋}\AgdaSpace{}%
\AgdaBound{q₁}\AgdaSpace{}%
\AgdaBound{q₂}\AgdaSymbol{)}\<%
\end{code}

we commonly invoke two main lemmas. \verb!reflect-≋! reflects propositional equality to semantic equivalence, and \verb!reify-≋! reifies equivalent semantic types to propositional equality. We make great use of the latter lemma, which states intuitively that related types should have the same reifications. One may alternatively think of this lemma as congruence of reification modulo semantic equivalence. 

\begin{code}%
\>[0]\AgdaFunction{reflect-≋}%
\>[11]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{reflect}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaFunction{reflect}\AgdaSpace{}%
\AgdaBound{τ₂}\<%
\\
\>[0]\AgdaFunction{reify-≋}%
\>[11]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{\}}%
\>[41]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{reify}\AgdaSpace{}%
\AgdaBound{τ₁}%
\>[64]\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaFunction{reify}\AgdaSpace{}%
\AgdaBound{τ₂}\<%
\end{code}
\begin{code}[hide]%
\>[0]\AgdaFunction{reflect-≋}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{bot}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaFunction{reify-≋}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{bot}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\end{code}


\subsection{The fundamental theorem \& completeness}

We would like to show that all well-kinded equivalent types have semantically equivalent evaluations. Completeness follows shortly thereafter. The fundamental theorem for completeness (\verb!fundC!) states that equivalent types evaluate to related types under related environments. Towards this goal, we first define a point-wise equivalence on semantic environments.

\begin{code}%
\>[0]\AgdaFunction{Env-≋}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{η₁}\AgdaSpace{}%
\AgdaBound{η₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Env}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{Env-≋}\AgdaSpace{}%
\AgdaBound{η₁}\AgdaSpace{}%
\AgdaBound{η₂}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{TVar}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{η₁}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{η₂}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\end{code}

\Ni We show that related environments remain related when extended with related arguments.
\begin{code}%
\>[0]\AgdaFunction{extend-≋}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[3878I]\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{η₁}\AgdaSpace{}%
\AgdaBound{η₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Env}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Env-≋}\AgdaSpace{}%
\AgdaBound{η₁}\AgdaSpace{}%
\AgdaBound{η₂}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[3878I][@{}l@{\AgdaIndent{0}}]%
\>[12]\AgdaSymbol{\{}\AgdaBound{V₁}\AgdaSpace{}%
\AgdaBound{V₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[12]\AgdaBound{V₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaBound{V₂}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[12]\AgdaFunction{Env-≋}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{extende}\AgdaSpace{}%
\AgdaBound{η₁}\AgdaSpace{}%
\AgdaBound{V₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{extende}\AgdaSpace{}%
\AgdaBound{η₂}\AgdaSpace{}%
\AgdaBound{V₂}\AgdaSymbol{)}\<%
\end{code}
\begin{code}[hide]%
\>[0]\AgdaFunction{extend-≋}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{bot}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\end{code}

It is easy to show as well that the identity environment relates to itself.

\begin{code}%
\>[0]\AgdaFunction{idEnv-≋}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Env-≋}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{idEnv}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ}\AgdaSymbol{\})}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{idEnv}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ}\AgdaSymbol{\})}\<%
\\
\>[0]\AgdaFunction{idEnv-≋}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{reflect-≋}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\<%
\end{code}

We may now state the fundamental theorem for completeness. Again, as we have no semantic image of predicates, the fundamental theorem for predicates simply asserts that the evaluation of equivalent predicates are propositional equal.

\begin{code}%
\>[0]\AgdaFunction{fundC}%
\>[3921I]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{η₁}\AgdaSpace{}%
\AgdaBound{η₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Env}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[3921I][@{}l@{\AgdaIndent{0}}]%
\>[7]\AgdaFunction{Env-≋}\AgdaSpace{}%
\AgdaBound{η₁}\AgdaSpace{}%
\AgdaBound{η₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaBound{η₁}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{≋}}\AgdaSpace{}%
\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaBound{η₂}\<%
\\
\>[0]\AgdaFunction{fundC-pred}%
\>[3950I]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{π₁}\AgdaSpace{}%
\AgdaBound{π₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Pred}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{η₁}\AgdaSpace{}%
\AgdaBound{η₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Env}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{Δ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[3950I][@{}l@{\AgdaIndent{0}}]%
\>[12]\AgdaFunction{Env-≋}\AgdaSpace{}%
\AgdaBound{η₁}\AgdaSpace{}%
\AgdaBound{η₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{π₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡p}}\AgdaSpace{}%
\AgdaBound{π₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{evalPred}\AgdaSpace{}%
\AgdaBound{π₁}\AgdaSpace{}%
\AgdaBound{η₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaFunction{evalPred}\AgdaSpace{}%
\AgdaBound{π₂}\AgdaSpace{}%
\AgdaBound{η₂}\<%
\end{code}
\begin{code}[hide]%
\>[0]\AgdaFunction{fundC}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{bot}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaFunction{fundC-pred}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{bot}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\end{code}

Completeness follows immediatelly as a special case of the fundamental theorem.

\begin{code}%
\>[0]\AgdaFunction{Completeness}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaBound{τ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{⇓}\AgdaSpace{}%
\AgdaBound{τ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaFunction{⇓}\AgdaSpace{}%
\AgdaBound{τ₂}\<%
\\
\>[0]\AgdaFunction{Completeness}\AgdaSpace{}%
\AgdaBound{eq}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{reify-≋}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{fundC}\AgdaSpace{}%
\AgdaFunction{idEnv-≋}\AgdaSpace{}%
\AgdaBound{eq}\AgdaSymbol{)}\<%
\end{code}


\subsection{Soundness}

Soundness states that every type is equivalent to its normalization. Intuitively, completeness tells us that all "computation" inherent in the equivalence relation is captured by normalization; coversely, soundness tells us that all computation inherent in the normalization algorithm is declared in the equivalence relation.

\subsubsection{A logical relation}

We prove soundness by a separate logical relation that relates (unnormalized) types to semantic types. We write \verb!⟦ τ ⟧≋ V! to denote that the type $\tau$ is related to the semantic type $V$. This syntax is inspired by the result we wish to show: that evaluating $\tau$ yields a semantic type $V$. We give the type synonym \verb!SoundKripke! for the functional case.

\begin{code}%
\>[0]\AgdaKeyword{infix}\AgdaSpace{}%
\AgdaNumber{0}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟦\AgdaUnderscore{}⟧≋\AgdaUnderscore{}}}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{⟦\AgdaUnderscore{}⟧≋\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{SoundKripke}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{KripkeFunction}\AgdaSpace{}%
\AgdaGeneralizable{Δ₁}\AgdaSpace{}%
\AgdaGeneralizable{κ₁}\AgdaSpace{}%
\AgdaGeneralizable{κ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\end{code}

In two of the ground cases, \verb!V! is a normal type, and so we simply assert type equivalence with the normal type's embedding.
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{⟦\AgdaUnderscore{}⟧≋\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{★}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaBound{V}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{V}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{⟦\AgdaUnderscore{}⟧≋\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{L}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaBound{V}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaBound{V}\<%
\end{code}

In the row case, we assert (resp.) that (i) if $\tau$ relates to \verb!nothing! then it must be equivalent to the empty row; (ii) if $\tau$ relates to a neutral row then it must be equivalent to a neutral row; and (iii) if $\tau$ relates to a labeled rows then it must be equivalent to a labeled row and that labeled row's component type must relate to itself.
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{⟦\AgdaUnderscore{}⟧≋\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaInductiveConstructor{nothing}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaInductiveConstructor{ε}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{⟦\AgdaUnderscore{}⟧≋\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{left}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇑NE}\AgdaSpace{}%
\AgdaBound{n}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{⟦\AgdaUnderscore{}⟧≋\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{R[}}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{]}}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{just}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{right}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{υ}\AgdaSymbol{)))}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{l}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{▹}}\AgdaSpace{}%
\AgdaFunction{reify}\AgdaSpace{}%
\AgdaBound{υ}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{×}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reify}\AgdaSpace{}%
\AgdaBound{υ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧≋}}\AgdaSpace{}%
\AgdaBound{υ}\AgdaSymbol{)}\<%
\end{code}

In the functional case, we assert that logically related functions map related inputs to related outputs.

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{⟦\AgdaUnderscore{}⟧≋\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{`→}}\AgdaSpace{}%
\AgdaBound{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{SoundKripke}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{F}\<%
\\
\>[0]\AgdaFunction{SoundKripke}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{Δ₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ₁}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaArgument{κ₂}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{κ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaSymbol{(∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{ρ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Renamingₖ}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{v}\AgdaSpace{}%
\AgdaBound{V}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧≋}}\AgdaSpace{}%
\AgdaBound{V}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
%
\>[6]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renₖ}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{·}}\AgdaSpace{}%
\AgdaBound{v}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧≋}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{renKripke}\AgdaSpace{}%
\AgdaBound{ρ}\AgdaSpace{}%
\AgdaBound{F}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{·V}}\AgdaSpace{}%
\AgdaBound{V}\AgdaSymbol{))}\<%
\end{code}

\subsection{Properties of the soundness relation}

We reflect type equivalence to the relation and reify the relation to type equivalence as so.

\begin{code}%
\>[0]\AgdaFunction{reflect-⟦⟧≋}%
\>[4158I]\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{υ}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[37]\AgdaDatatype{NeutralType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[4158I][@{}l@{\AgdaIndent{0}}]%
\>[13]\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaFunction{⇑NE}\AgdaSpace{}%
\AgdaBound{υ}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧≋}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reflect}\AgdaSpace{}%
\AgdaBound{υ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{reify-⟦⟧≋}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}%
\>[4181I]\AgdaSymbol{\{}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{V}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[35]\AgdaFunction{SemType}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[4181I][@{}l@{\AgdaIndent{0}}]%
\>[15]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧≋}}\AgdaSpace{}%
\AgdaBound{V}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{reify}\AgdaSpace{}%
\AgdaBound{V}\AgdaSymbol{)}\<%
\end{code}
\begin{code}[hide]%
\>[0]\AgdaFunction{reflect-⟦⟧≋}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{bot}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\\
\>[0]\AgdaFunction{reify-⟦⟧≋}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{bot}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\end{code}

\subsubsection{The fundamental theorem \& soundness}

Towards defining the fundamental theorem, we first define a relation between syntactic environments (substitutions) and semantic environments. Intuitively, the substitution $\sigma$ is related to the environment $\eta$ if each type mapped to by $\sigma$ point-wise relates to the semantic type mapped to by $\eta$.

\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{⟦\AgdaUnderscore{}⟧≋e\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Substitutionₖ}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Env}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{⟦\AgdaUnderscore{}⟧≋e\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{α}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{TVar}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{α}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧≋}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{η}\AgdaSpace{}%
\AgdaBound{α}\AgdaSymbol{)}\<%
\end{code}

The fundamental theorem for soundness states that the substitution of $\tau$ by $\sigma$ is related to the evaluation of $\tau$ by $\eta$. Intuitively, substitution may be thought of as a syntactic notion of evaluation, and hence we are stating that syntactic and semantic evaluations relate.

\begin{code}%
\>[0]\AgdaFunction{fundS}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}%
\>[4240I]\AgdaSymbol{\{}\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{\}(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{)\{}\AgdaBound{σ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Substitutionₖ}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSymbol{\}\{}\AgdaBound{η}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Env}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{Δ₂}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[.][@{}l@{}]\<[4240I]%
\>[10]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧≋e}}\AgdaSpace{}%
\AgdaBound{η}%
\>[21]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaBound{σ}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧≋}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{eval}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaBound{η}\AgdaSymbol{)}\<%
\end{code}
\begin{code}[hide]%
\>[0]\AgdaFunction{fundS}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{bot}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\end{code}

We show that the identity substitution \verb!`! is related to the identity environment:

\begin{code}%
\>[0]\AgdaFunction{idSR}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₁}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}%
\>[17]\AgdaOperator{\AgdaFunction{⟦}}\AgdaSpace{}%
\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⟧≋e}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{idEnv}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₁}\AgdaSymbol{\})}\<%
\\
\>[0]\AgdaFunction{idSR}\AgdaSpace{}%
\AgdaBound{α}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{reflect-⟦⟧≋}\AgdaSpace{}%
\AgdaInductiveConstructor{eq-refl}\<%
\end{code}


\Ni and also show that \verb!`! is indeed an identity substitution: it fixes the meaning of the type over which it is substituted.

\begin{code}%
\>[0]\AgdaFunction{subₖ-id}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaGeneralizable{Δ}\AgdaSpace{}%
\AgdaGeneralizable{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{subₖ}\AgdaSpace{}%
\AgdaInductiveConstructor{`}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡}}\AgdaSpace{}%
\AgdaBound{τ}\<%
\end{code}

Soundness follows as a special case of the fundamental theorem.

\begin{code}%
\>[0]\AgdaFunction{Soundness}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Type}\AgdaSpace{}%
\AgdaBound{Δ₁}\AgdaSpace{}%
\AgdaBound{κ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaOperator{\AgdaDatatype{≡t}}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇓}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{Soundness}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{subst}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡t}}\AgdaSpace{}%
\AgdaFunction{⇑}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{⇓}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{subₖ-id}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaFunction{reify-⟦⟧≋}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{fundS}\AgdaSpace{}%
\AgdaBound{τ}\AgdaSpace{}%
\AgdaFunction{idSR}\AgdaSymbol{)))}\<%
\end{code}
\begin{code}[hide]%
\>[0]\AgdaFunction{subₖ-id}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{bot}\AgdaSpace{}%
\AgdaSymbol{\AgdaUnderscore{}}\<%
\end{code}


\section{Remark}

\subsection{Comparison to \citet{ChapmanKNW19}}
Our mechanization has closely resembled that of \citet{ChapmanKNW19}. Our definition of semantic types, however, has differed, as our normalization is with respect to both $\beta$- and $\eta$-equivalence, whereas Chapman et al's is simply $\beta$-equivalence. Changing this definition simplifies some things and complicates others. The definition of semantic types is simpler: whereas Chapman et al permit function types to be interpreted as \verb!NeutralType!s, ours must be interpreted into solely Kripke function spaces. This complicates the definitions of \verb!reify! and \verb!reflect!, which must become mutually recursive, as we are unable to reflect neutral types at arrow kind to neutral types. We will show later that some of Chapman et al's metatheory relies on neutral forms to not be disturbed by normalization. This complicates the definition of term-level, normality-preserving substitution.


\bibliographystyle{plainnat}
\bibliography{TN}
\end{document}
%%% Local Variables: 
%%% TeX-command-extra-options: "-shell-escape"
%%% End:
%  LocalWords:  denotational Agda Wadler dPoint sqrt subtyping coercions Intr
%  LocalWords:  RowTypes Bool eval GHC reified HillerstromL Leijen LindleyM RO
%  LocalWords:  ChapmanKNW Aydemir AbelAHPMSS AbelC AbelOV plfa HubersIMM STLC
%  LocalWords:  MorrisM denotationally DenotationalSoundness RowTheories Suc de
%  LocalWords:  ReifyingVariants RowTheory BerthomieuM CardelliMMS HarperP NatF
%  LocalWords:  XueOX GasterJ Sipser SaffrichTM Env Expr Agda's Leivant ChanW
%  LocalWords:  ThiemannW ImpredicativeSet ImpredicativeSetSucks AbelP chapman
%  LocalWords:  AltenkirchK KaposiKK Gaster XieOBS BiXOS Chlipala objTypes Bahr
%  LocalWords:  Garrigue KEnv PEnv
