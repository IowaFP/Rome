\documentclass[authoryear, acmsmall, screen, review, nonacm]{acmart}
\overfullrule=1mm
% \usepackage[margin=1.5in]{geometry}

\include{header.tex} 
\usepackage{agda}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% ACM garbage
\setcopyright{none}
\citestyle{acmauthoryear}
\settopmatter{printacmref=false, printfolios=true}
\renewcommand{\footnotetextcopyrightpermission}{} 
% Redefine the \acmDOI command to do nothing 
\pagestyle{empty}
\fancyfoot{}

%\usepackage[utf8]{inputenc}
% \numberwithin{equation}{section}
% \numberwithin{theorem}{section}

\title{Normalization By Evaluation of Types in \Rome}
\author{Alex Hubers}
\orcid{0000-0002-6237-3326}
\affiliation{
  \department{Department of Computer Science}
  \institution{The University of Iowa}
  \streetaddress{14 MacLean Hall}
  \city{Iowa City}
  \state{Iowa}
  \country{USA}}
\email{alexander-hubers@uiowa.edu}

\usepackage{newunicodechar}
\newunicodechar{‚àã}{$\ni$}
\newunicodechar{Œµ}{$\epsilon$}
\newunicodechar{¬∑}{$\cdot$}
\newunicodechar{‚ä¢}{$\vdash$}
\newunicodechar{‚ãÜ}{${}^\star$}
\newunicodechar{Œ†}{$\Pi$}
\newunicodechar{‚áí}{$\Rightarrow$}
\newunicodechar{∆õ}{$\lambdabar$}
\newunicodechar{‚àÖ}{$\emptyset$}
\newunicodechar{‚àÄ}{$\forall$}
\newunicodechar{œï}{$\Phi$}
\newunicodechar{œÜ}{$\phi$}
\newunicodechar{œà}{$\Psi$}
\newunicodechar{œÅ}{$\rho$}
\newunicodechar{Œ±}{$\alpha$}
\newunicodechar{Œ≤}{$\beta$}
\newunicodechar{Œº}{$\mu$}
\newunicodechar{œÉ}{$\sigma$}
\newunicodechar{‚â°}{$\equiv$}
\newunicodechar{Œì}{$\Gamma$}
\newunicodechar{‚à•}{$\parallel$}
\newunicodechar{Œõ}{$\Lambda$}
\newunicodechar{‚ÇÇ}{$_2$}
\newunicodechar{Œ∏}{$\theta$}
\newunicodechar{Œò}{$\Theta$}
\newunicodechar{‚àò}{$\circ$}
\newunicodechar{Œî}{$\Delta$}
\newunicodechar{‚òÖ}{$\star$}
\newunicodechar{Œª}{$\lambda$}
\newunicodechar{‚äß}{$\models$}
\newunicodechar{‚äé}{$\uplus$}
\newunicodechar{Œ∑}{$\eta$}
\newunicodechar{‚ä•}{$\bot$}
\newunicodechar{Œ£}{$\Sigma$}
\newunicodechar{Œæ}{$\xi$}
\newunicodechar{‚ÇÅ}{$_1$}
\newunicodechar{‚Çñ}{$_k$}
\newunicodechar{‚ÇÉ}{$_3$}
\newunicodechar{‚Ñï}{$\mathbb{N}$}
\newunicodechar{·∂ú}{${}^c$}
\newunicodechar{Œ¶}{$\Phi$}
\newunicodechar{Œ®}{$\Psi$}
\newunicodechar{‚ä§}{$\top$}
\newunicodechar{Œ∫}{$\kappa$}
\newunicodechar{œÑ}{$\tau$}
\newunicodechar{œÄ}{$\pi$}
\newunicodechar{‚åä}{$\lfloor$}
\newunicodechar{‚åã}{$\rfloor$}
\newunicodechar{‚â≤}{$\lesssim$}
\newunicodechar{‚ñπ}{$\triangleright$}
\newunicodechar{‚Ñì}{$\ell$}
\newunicodechar{œÖ}{$\upsilon$}

\newunicodechar{‚Üí}{$\rightarrow$}
\newunicodechar{√ó}{$\times$}
\newunicodechar{œâ}{$\omega$}
\newunicodechar{‚àÉ}{$\exists$}
\newunicodechar{‚àà}{$\in$}
\newunicodechar{‚áë}{$\Uparrow$}
\newunicodechar{‚áì}{$\Downarrow$}
\newunicodechar{‚âã}{$\approx$}
\newunicodechar{‚Çó}{$_l$}
\newunicodechar{·µ£}{$_r$}
\newunicodechar{‚ü¶}{$\llbracket$}
\newunicodechar{‚üß}{$\rrbracket$}
\newunicodechar{‚Åª}{$^{-}$}
\newunicodechar{¬π}{$^{1}$}
\newunicodechar{‚ÇÑ}{$_{4}$}
\newunicodechar{‚¶Ö}{$\llparenthesis$}
\newunicodechar{‚¶Ü}{$\rrparenthesis$}
\newunicodechar{‚îÄ}{$\setminus$}
\newunicodechar{‚à∑}{$\co\co$}
\newunicodechar{‚Çñ}{$_{k}$}
\newunicodechar{‚Çô}{$_{n}$}
\newunicodechar{‚âü}{$\overset{?}{=}$}
\newunicodechar{ùíØ}{$\mathcal T$}
\newunicodechar{‚®æ}{$\co$}
\newunicodechar{Œû}{$\Xi$}
\newunicodechar{Œæ}{$\xi$}

\begin{document}

\maketitle

\section*{Abstract}
We describe the normalization-by-evaluation (NbE) of types in \Rome, a row calculus with recursive types, qualified types, and a novel \emph{row complement} operator. Types are normalized to $\beta\eta$-long forms modulo a type equivalence relation. Because the type system of \Rome is a strict extension of System \Fome, much of the type reduction is isomorphic to reduction of terms in the STLC. Novel to this report are the reductions of row, record, and variant types.

\begin{code}[hide]
postulate
  bot : ‚àÄ (X : Set) ‚Üí X

open import Prelude
\end{code}

\section{The \Rome{} calculus}

For reference, \cref{fig:syntax-types} describes the syntax of kinds, predicates, and types in \Rome. We forego further description to the next section.

\begin{figure}[H]
\begin{gather*}
\begin{array}{r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l}
\text{Type variables} & \alpha \in \mathcal A & \text{Labels} & \ell \in \mathcal L
\end{array}
\\[5px]
\begin{doublesyntaxarray}
  \mcl{\text{Kinds}} & \kappa & ::= & \TypeK \mid \LabK \mid \RowK \kappa \mid \kappa \to \kappa \\
  \mcl{\text{Predicates}} & \pi, \psi & ::= & \LeqP \rho \rho \mid \PlusP \rho \rho \rho \\
  \text{Types} & \mcr{\Types \ni \phi, \tau, \upsilon, \rho, \xi} & ::= & \alpha \mid \pi \then \tau \mid \forall \alpha\co\kappa. \tau \mid \lambda \alpha\co\kappa. \tau \mid \tau \, \tau \\
               &                              &     & \mid    & \RowIx i 0 m {\LabTy {\xi_i} {\tau_i}} \mid \ell \mid \Sing{\tau} \mid \Mapp{\phi}{\rho} \mid \rho \Compl \rho \\ 
               &                              &     & \mid & \tau \to \tau \mid \Pi \mid \Sigma \mid \mu \, \phi 
\end{doublesyntaxarray}
\end{gather*}
\caption{Syntax}
\label{fig:syntax-types}
\end{figure}

\subsection{Example types}

Wand's problem and a record modifier:

\begin{rosi}
wand : forall l x y z t. x + y ~ z, {l := t} < z => #l -> Pi x -> Pi y -> t
modify : forall l t u y z1 z2. {l := t} + y ~ z1, {l := u} + y ~ z2 =>
         #l -> (t -> u) -> Pi z1 -> Pi z2
\end{rosi}

\Ni "Deriving" functor typeclass instances: 

\begin{rosi}
type Functor : (* -> *) -> *
type Functor = \f. forall a b. (a -> b) -> f a -> f b

fmapS : forall z : R[* -> *]. Pi (Functor z) -> Functor (Sigma z)
fmapP : forall z : R[* -> *]. Pi (Functor z) -> Functor (Pi z)
\end{rosi}

\Ni And a desugaring of booleans to Church encodings:

\begin{rosi}
desugar : forall y. BoolF < y, LamF < y - BoolF =>
          Pi (Functor (y - BoolF)) -> Mu (Sigma y) -> Mu (Sigma (y - BoolF))
\end{rosi}

\section{Mechanized syntax}

\subsection{Kind syntax}

Our formalization of \Rome types is \emph{intrinsic}, meaning we define the syntax of \emph{typing} and \emph{kinding judgments}, foregoing any formalization of or indexing-by untyped syntax. The only "untyped" syntax is that of kinds, which are well-formed grammatically. We give the syntax of kinds and kinding environments below.

\begin{code}
data Kind : Set where
  ‚òÖ     : Kind
  L     : Kind
  _`‚Üí_ : Kind ‚Üí Kind ‚Üí Kind
  R[_]  : Kind ‚Üí Kind

infixr 5 _`‚Üí_
\end{code}

The kind system of \Rome defines $\star$ as the type of types; $L$ as the type of labels; $(\to)$ as the type of type operators; and $R[\kappa]$ as the type of \emph{rows} containing types at kind $\kappa$.

The syntax of kinding environments is given below. Kinding environments are isomorphic to lists of kinds.

\begin{code}
data KEnv : Set where
  ‚àÖ : KEnv
  _,,_ : KEnv ‚Üí Kind ‚Üí KEnv
\end{code}

Let the metavariables $\Delta$ and $\kappa$ range over kinding environments and kinds, respectively. Correspondingly, we define \emph{generalized variables} in Agda at these names. 

\begin{code}
private
  variable
    Œî Œî‚ÇÅ Œî‚ÇÇ Œî‚ÇÉ : KEnv
    Œ∫ Œ∫‚ÇÅ Œ∫‚ÇÇ : Kind
\end{code}

The syntax of intrinsically well-scoped De-Bruijn type variables is given below. Type variables indexed in this way are analogous to the \verb!_‚àà_! relation for Agda lists---that is, each type variable is itself a proof of its location within the kinding environment.

\begin{code}
data TVar : KEnv ‚Üí Kind ‚Üí Set where
  Z : TVar (Œî ,, Œ∫) Œ∫
  S : TVar Œî Œ∫‚ÇÅ ‚Üí TVar (Œî ,, Œ∫‚ÇÇ) Œ∫‚ÇÅ
\end{code}

\subsubsection{Partitioning kinds} It will be necessary to partition kinds by two predicates. The predicate \verb!NotLabel Œ∫! is satisfied if $\kappa$ is neither of label kind, a row of label kind, nor a type operator that returns a labeled kind. It is trivial to show that this predicate is decidable.

\begin{minipage}[t]{0.45\textwidth}
\begin{code}
NotLabel : Kind ‚Üí Set 
NotLabel ‚òÖ = ‚ä§
NotLabel L = ‚ä•
NotLabel (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ) = NotLabel Œ∫‚ÇÇ
NotLabel R[ Œ∫ ] = NotLabel Œ∫
\end{code}
\end{minipage}%
\hfill
\begin{minipage}[t]{0.45\textwidth}
\begin{code}
notLabel? : ‚àÄ Œ∫ ‚Üí Dec (NotLabel Œ∫)
notLabel? ‚òÖ = yes tt
notLabel? L = no Œª ()
notLabel? (Œ∫ `‚Üí Œ∫‚ÇÅ) = notLabel? Œ∫‚ÇÅ
notLabel? R[ Œ∫ ] = notLabel? Œ∫
\end{code}
\end{minipage}

The predicate \verb!Ground Œ∫! is satisfied when $\kappa$ is the kind of types or labels, and is necessary to reserve the promotion of neutral types to just those at these kinds. It is again trivial to show that this predicate is decidable, and so a definition of \verb!ground?! is omitted.

\begin{code}
Ground : Kind ‚Üí Set 
ground? : ‚àÄ Œ∫ ‚Üí Dec (Ground Œ∫)
Ground ‚òÖ = ‚ä§
Ground L = ‚ä§
Ground (Œ∫ `‚Üí Œ∫‚ÇÅ) = ‚ä•
Ground R[ Œ∫ ] = ‚ä•
\end{code}
\begin{code}[hide]
ground? ‚òÖ = yes tt
ground? L = yes tt
ground? (_ `‚Üí _) = no (Œª ())
ground? R[ _ ] = no (Œª ())
\end{code}

\subsection{Type syntax}

We represent the judgment $\KindJ \Gamma \tau \kappa$ intrinsically as the data type \verb!Type Œî Œ∫!. The data type \verb!Pred Type Œî R[ Œ∫ ]! represents well-kinded predicates indexed by \verb!Type Œî Œ∫!. The two are necessarily mutually inductive. Note that the syntax of predicates will be the same for both types and normalized types, and so the \verb!Pred! data type is indexed abstractly by type \verb!Ty!.

\begin{code}[hide]
infixr 2 _‚áí_
infixl 5 _¬∑_
infixr 5 _‚â≤_
\end{code}
\begin{code}
data Pred (Ty : KEnv ‚Üí Kind ‚Üí Set) Œî : Kind ‚Üí Set
data Type Œî : Kind ‚Üí Set 
\end{code} 

We must also define syntax for \emph{simple rows}, that is, row literals. For uniformity of kind indexing, we define a \verb!SimpleRow! by pattern matching on the syntax of kinds. Like with \verb!Pred!, simple rows are indexed by abstract type \verb!Ty! so that we may reuse the same pattern for normalized types.

\begin{code}
SimpleRow : (Ty : KEnv ‚Üí Kind ‚Üí Set) ‚Üí KEnv ‚Üí Kind ‚Üí Set 
SimpleRow Ty Œî R[ Œ∫ ]   = List (Label √ó Ty Œî Œ∫)
SimpleRow _ _ _ = ‚ä•
\end{code} 

A simple row is \emph{ordered} if it is of length $\leq 1$ or its corresponding labels are ordered according to some total order $<$. We will restrict the formation of row literals to just those that are ordered, which has two key consequences: first, it guarantees a normal form (later) for simple rows, and second, it enforces that labels be unique in each row. It is easy to show that the \verb!Ordered! predicate is decidable.

\begin{code} 
Ordered : SimpleRow Type Œî R[ Œ∫ ] ‚Üí Set 
ordered? : ‚àÄ (xs : SimpleRow Type Œî R[ Œ∫ ]) ‚Üí Dec (Ordered xs)
Ordered [] = ‚ä§
Ordered (x ‚à∑ []) = ‚ä§
Ordered ((l‚ÇÅ , _) ‚à∑ (l‚ÇÇ , œÑ) ‚à∑ xs) = l‚ÇÅ < l‚ÇÇ √ó Ordered ((l‚ÇÇ , œÑ) ‚à∑ xs)
\end{code}

The syntax of well-kinded predicates is exactly as expected.

\begin{code}
data Pred Ty Œî where
  _¬∑_~_ : (œÅ‚ÇÅ œÅ‚ÇÇ œÅ‚ÇÉ : Ty Œî R[ Œ∫ ]) ‚Üí Pred Ty Œî R[ Œ∫ ]
  _‚â≤_ : (œÅ‚ÇÅ œÅ‚ÇÇ : Ty Œî R[ Œ∫ ]) ‚Üí Pred Ty Œî R[ Œ∫ ]  
\end{code}

The syntax of kinding judgments is given below. The formation rules for $\lambda$-abstractions, applications, arrow types, and $\forall$ and $\mu$ types are standard and omitted.

\begin{code}
data Type Œî where
  ` : (Œ± : TVar Œî Œ∫) ‚Üí Type Œî Œ∫
\end{code}
\begin{code}[hide]
  `Œª : 
    (œÑ : Type (Œî ,, Œ∫‚ÇÅ) Œ∫‚ÇÇ) ‚Üí 
    Type Œî (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ)
  _¬∑_ : 
    (œÑ‚ÇÅ : Type Œî (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ)) ‚Üí 
    (œÑ‚ÇÇ : Type Œî Œ∫‚ÇÅ) ‚Üí 
    Type Œî Œ∫‚ÇÇ
  _`‚Üí_ : 
      (œÑ‚ÇÅ : Type Œî ‚òÖ) ‚Üí
      (œÑ‚ÇÇ : Type Œî ‚òÖ) ‚Üí 
      Type Œî ‚òÖ
  `‚àÄ    :
    {Œ∫ : Kind} ‚Üí (œÑ : Type (Œî ,, Œ∫) ‚òÖ) ‚Üí
    Type Œî ‚òÖ
  Œº     :
    (œÜ : Type Œî (‚òÖ `‚Üí ‚òÖ)) ‚Üí 
    Type Œî ‚òÖ
\end{code} 

\Ni The constructor \verb!_‚áí_! forms a qualified type given a well-kinded predicate \verb!œÄ! and a \verb!‚òÖ!-kinded body \verb!œÑ!.

\begin{code}
  _‚áí_ : (œÄ : Pred Type Œî R[ Œ∫‚ÇÅ ]) ‚Üí (œÑ : Type Œî ‚òÖ) ‚Üí Type Œî ‚òÖ       
\end{code}

\Ni Labels are formed from label literals and cast to kind $\star$ via the \verb!‚åä_‚åã! constructor.

\begin{code}
  lab : (l : Label) ‚Üí Type Œî L
  ‚åä_‚åã : (œÑ : Type Œî L) ‚Üí Type Œî ‚òÖ
\end{code}

\Ni We finally describe row formation. The constructor \verb!‚¶Ö_‚¶Ü! forms a row literal from a well-ordered simple row. We additionally allow the syntax \verb!_‚ñπ_! for constructing row singletons of (perhaps) variable label; this role can be performed by \verb!‚¶Ö_‚¶Ü! when the label is a literal. The \verb!_<$>_! constructor describes the map of a type operator over a row. \verb!Œ†! and \verb!Œ£! form records and variants from rows for which the \verb!NotLabel! predicate is satisfied. Finally, the \verb!_‚îÄ_! constructor forms the relative complement of two rows. The novelty in this report will come from showing how types of these forms reduce.

\begin{code} 
  ‚¶Ö_‚¶Ü : (xs : SimpleRow Type Œî R[ Œ∫ ]) (ordered : True (ordered? xs)) ‚Üí Type Œî R[ Œ∫ ]
  _‚ñπ_ : (l : Type Œî L) ‚Üí (œÑ : Type Œî Œ∫) ‚Üí Type Œî R[ Œ∫ ]
  _<$>_ : (œÜ : Type Œî (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ)) ‚Üí (œÑ : Type Œî R[ Œ∫‚ÇÅ ]) ‚Üí Type Œî R[ Œ∫‚ÇÇ ]
  Œ†     : {notLabel : True (notLabel? Œ∫)} ‚Üí Type Œî (R[ Œ∫ ] `‚Üí Œ∫)
  Œ£     : {notLabel : True (notLabel? Œ∫)} ‚Üí Type Œî (R[ Œ∫ ] `‚Üí Œ∫)
  _‚îÄ_ : Type Œî R[ Œ∫ ] ‚Üí Type Œî R[ Œ∫ ] ‚Üí Type Œî R[ Œ∫ ]
\end{code}

\subsubsection{The ordered predicate}~
\begin{code}[hide]
ordered? [] = yes tt
ordered? (x ‚à∑ []) = yes tt
ordered? ((l‚ÇÅ , _) ‚à∑ (l‚ÇÇ , _) ‚à∑ xs) with l‚ÇÅ <? l‚ÇÇ | ordered? ((l‚ÇÇ , _) ‚à∑ xs)
... | yes p | yes q  = yes (p , q)
... | yes p | no q  = no (Œª { (_ , oxs) ‚Üí q oxs })
... | no p  | yes q  = no (Œª { (x , _) ‚Üí p x})
... | no  p | no  q  = no (Œª { (x , _) ‚Üí p x})
\end{code} 
We impose on the \verb!‚¶Ö_‚¶Ü! constructor a witness of the form \verb!True! \verb!(ordered? xs)!, although it may seem more intuitive to have instead simply required a witness that \verb!Ordered xs!. The reason for this is that the \verb!True! predicate quotients each proof down to a single inhabitant \verb!tt!, which grants us proof irrelevance when comparing rows. This is desirable and yields congruence rules that would otherwise be blocked by two differing proofs of well-orderedness. The congruence rule below asserts that two simple rows are equivalent even with differing proofs. (This pattern is replicable for any decidable predicate.)
\begin{code}
cong-SimpleRow : {sr‚ÇÅ sr‚ÇÇ : SimpleRow Type Œî R[ Œ∫ ]}
                 {wf‚ÇÅ : True (ordered? sr‚ÇÅ)} {wf‚ÇÇ : True (ordered? sr‚ÇÇ)} ‚Üí 
                 sr‚ÇÅ ‚â° sr‚ÇÇ ‚Üí ‚¶Ö sr‚ÇÅ ‚¶Ü wf‚ÇÅ ‚â° ‚¶Ö sr‚ÇÇ ‚¶Ü wf‚ÇÇ
cong-SimpleRow {sr‚ÇÅ = sr‚ÇÅ} {_} {wf‚ÇÅ} {wf‚ÇÇ} refl 
  rewrite Dec‚ÜíIrrelevant (Ordered sr‚ÇÅ) (ordered? sr‚ÇÅ) wf‚ÇÅ wf‚ÇÇ = refl
\end{code} 

In the same fashion, we impose on \verb!Œ†! and \verb!Œ£! a similar restriction that their kinds satisfy the \verb!NotLabel! predicate, although our reason for this restriction is instead metatheoretic: without it, nonsensical labels could be formed such as \verb!Œ† (lab "a" ‚ñπ lab "b")! or \verb!Œ† Œµ!. Each of these types have kind \verb!L!, which violates a label canonicity theorem we later show that all label-kinded types in normal form are label literals or neutral.

\begin{code}[hide]
map-over·µ£ : ‚àÄ (œÅ : SimpleRow Type Œî‚ÇÅ R[ Œ∫‚ÇÅ ]) (f : Type Œî‚ÇÅ Œ∫‚ÇÅ ‚Üí Type Œî‚ÇÅ Œ∫‚ÇÇ) ‚Üí 
              Ordered œÅ ‚Üí Ordered (map (over·µ£ f) œÅ)
map-over·µ£ [] f oœÅ = tt
map-over·µ£ (x ‚à∑ []) f oœÅ = tt
map-over·µ£ ((l‚ÇÅ , _) ‚à∑ (l‚ÇÇ , _) ‚à∑ œÅ) f (l‚ÇÅ<l‚ÇÇ , oœÅ) = l‚ÇÅ<l‚ÇÇ , (map-over·µ£ ((l‚ÇÇ , _) ‚à∑ œÅ) f oœÅ)
\end{code}

\subsubsection{Flipped map operator}~

\Citet{HubersM23} had a left- and right-mapping operator, but only one is necessary. The flipped application (flap) operator is defined below. Its type reveals its purpose.

\begin{code}
flap : Type Œî (R[ Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ ] `‚Üí Œ∫‚ÇÅ `‚Üí R[ Œ∫‚ÇÇ ])
flap = `Œª (`Œª ((`Œª ((` Z) ¬∑ (` (S Z)))) <$> (` (S Z))))

_??_ : Type Œî (R[ Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ ]) ‚Üí Type Œî Œ∫‚ÇÅ ‚Üí Type Œî R[ Œ∫‚ÇÇ ]
f ?? a = flap ¬∑ f ¬∑ a
\end{code}

\subsubsection{The (syntactic) complement operator}~

It is necessary to give a syntactic account of the computation incurred by the complement of two row literals so that we can state this computation later in the type equivalence relation. First, define a relation \verb!‚Ñì ‚ààL œÅ! that is inhabited when the label literal $\ell$ occurs in the row $\rho$. This relation is decidable (\verb!_‚ààL?_!, definition omitted).

\begin{code}[hide]
infix 0 _‚ààL_
\end{code}
\begin{code}
data _‚ààL_ : (l : Label) ‚Üí SimpleRow Type Œî R[ Œ∫ ] ‚Üí Set where
  Here : ‚àÄ {œÑ : Type Œî Œ∫} {xs : SimpleRow Type Œî R[ Œ∫ ]} {l : Label} ‚Üí 
         l ‚ààL (l , œÑ) ‚à∑ xs
  There : ‚àÄ {œÑ : Type Œî Œ∫} {xs : SimpleRow Type Œî R[ Œ∫ ]} {l l' : Label} ‚Üí 
          l ‚ààL xs ‚Üí l ‚ààL (l' , œÑ) ‚à∑ xs 
_‚ààL?_ : ‚àÄ (l : Label) (xs : SimpleRow Type Œî R[ Œ∫ ]) ‚Üí Dec (l ‚ààL xs)
\end{code} 

\begin{code}[hide]
l ‚ààL? [] = no (Œª { () })
l ‚ààL? ((l' , _) ‚à∑ xs) with l ‚âü l' 
... | yes refl = yes Here
... | no  p with l ‚ààL? xs 
...         | yes p = yes (There p)
...         | no  q = no Œª { Here ‚Üí p refl ; (There x) ‚Üí q x }
\end{code}

We now define the syntactic \emph{row complement} effectively as a filter: when a label on the left is found in the row on the right, we exclude that labeled entry from the resulting row.

\begin{code}
_‚îÄs_ : ‚àÄ (xs ys : SimpleRow Type Œî R[ Œ∫ ]) ‚Üí SimpleRow Type Œî R[ Œ∫ ]
[] ‚îÄs ys = []
((l , œÑ) ‚à∑ xs) ‚îÄs ys with l ‚ààL? ys 
... | yes _ = xs ‚îÄs ys
... | no  _ = (l , œÑ) ‚à∑ (xs ‚îÄs ys)
\end{code}

\subsubsection{Type renaming and substitution}~ 

A type variable renaming is a map from type variables in environment \verb!Œî‚ÇÅ! to type variables in environment \verb!Œî‚ÇÇ!. 
\begin{code}
Renaming‚Çñ : KEnv ‚Üí KEnv ‚Üí Set
Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ = ‚àÄ {Œ∫} ‚Üí TVar Œî‚ÇÅ Œ∫ ‚Üí TVar Œî‚ÇÇ Œ∫
\end{code}

\Ni This definition and approach is standard for the intrinsic style (\cf{} \citet{plfa22, ChapmanKNW19}) and so definitions are omitted. The only deviation of interest is that we have an obligation to show that renaming preserves the well-orderedness of simple rows. Note that we use the suffix \verb!_‚Çñ! for common operations over the \verb!Type! and \verb!Pred! syntax; we will use the suffix \verb!_‚ÇñNF! for equivalent operations over the normal type syntax.

\begin{code}[hide]
lift‚Çñ : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí Renaming‚Çñ (Œî‚ÇÅ ,, Œ∫) (Œî‚ÇÇ ,, Œ∫)
ren‚Çñ : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí Type Œî‚ÇÅ Œ∫ ‚Üí Type Œî‚ÇÇ Œ∫
renPred‚Çñ : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí Pred Type Œî‚ÇÅ R[ Œ∫ ] ‚Üí Pred Type Œî‚ÇÇ R[ Œ∫ ]
renRow‚Çñ : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí SimpleRow Type Œî‚ÇÅ R[ Œ∫ ] ‚Üí SimpleRow Type Œî‚ÇÇ R[ Œ∫ ]
\end{code}
\begin{code}
orderedRenRow‚Çñ : (r : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) ‚Üí (xs : SimpleRow Type Œî‚ÇÅ R[ Œ∫ ]) ‚Üí Ordered xs ‚Üí 
                 Ordered (renRow‚Çñ r xs)
\end{code} 
\begin{code}[hide]
-- lifting over binders.
lift‚Çñ œÅ Z = Z
lift‚Çñ œÅ (S x) = S (œÅ x)

ren‚Çñ r (` x) = ` (r x)
ren‚Çñ r (`Œª œÑ) = `Œª (ren‚Çñ (lift‚Çñ r) œÑ)
ren‚Çñ r (œÑ‚ÇÅ ¬∑ œÑ‚ÇÇ) = (ren‚Çñ r œÑ‚ÇÅ) ¬∑ (ren‚Çñ r œÑ‚ÇÇ)
ren‚Çñ r (œÑ‚ÇÅ `‚Üí œÑ‚ÇÇ) = (ren‚Çñ r œÑ‚ÇÅ) `‚Üí (ren‚Çñ r œÑ‚ÇÇ)
ren‚Çñ r (œÄ ‚áí œÑ) = renPred‚Çñ r œÄ ‚áí ren‚Çñ r œÑ 
ren‚Çñ r (`‚àÄ œÑ) = `‚àÄ (ren‚Çñ (lift‚Çñ r) œÑ)
ren‚Çñ r (Œº F) = Œº (ren‚Çñ r F)
ren‚Çñ r (Œ† {notLabel = nl}) = Œ† {notLabel = nl}
ren‚Çñ r (Œ£ {notLabel = nl}) = Œ£ {notLabel = nl}
ren‚Çñ r (lab x) = lab x
ren‚Çñ r ‚åä ‚Ñì ‚åã = ‚åä (ren‚Çñ r ‚Ñì) ‚åã
ren‚Çñ r (f <$> m) = ren‚Çñ r f <$> ren‚Çñ r m
ren‚Çñ r (‚¶Ö xs ‚¶Ü oxs) = ‚¶Ö renRow‚Çñ r xs ‚¶Ü (fromWitness (orderedRenRow‚Çñ r xs (toWitness oxs)))
ren‚Çñ r (œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) = ren‚Çñ r œÅ‚ÇÇ ‚îÄ ren‚Çñ r œÅ‚ÇÅ
ren‚Çñ r (l ‚ñπ œÑ) = ren‚Çñ r l ‚ñπ ren‚Çñ r œÑ

renPred‚Çñ œÅ (œÅ‚ÇÅ ¬∑ œÅ‚ÇÇ ~ œÅ‚ÇÉ) = ren‚Çñ œÅ œÅ‚ÇÅ ¬∑ ren‚Çñ œÅ œÅ‚ÇÇ ~ ren‚Çñ œÅ œÅ‚ÇÉ
renPred‚Çñ œÅ (œÅ‚ÇÅ ‚â≤ œÅ‚ÇÇ) = (ren‚Çñ œÅ œÅ‚ÇÅ) ‚â≤ (ren‚Çñ œÅ œÅ‚ÇÇ) 

renRow‚Çñ r [] = [] 
renRow‚Çñ r ((l , œÑ) ‚à∑ xs) = (l , ren‚Çñ r œÑ) ‚à∑ renRow‚Çñ r xs

orderedRenRow‚Çñ r [] oxs = tt
orderedRenRow‚Çñ r ((l , œÑ) ‚à∑ []) oxs = tt
orderedRenRow‚Çñ r ((l‚ÇÅ , œÑ) ‚à∑ (l‚ÇÇ , œÖ) ‚à∑ xs) (l‚ÇÅ<l‚ÇÇ , oxs) = l‚ÇÅ<l‚ÇÇ , orderedRenRow‚Çñ r ((l‚ÇÇ , œÖ) ‚à∑ xs) oxs

weaken‚Çñ : Type Œî Œ∫‚ÇÇ ‚Üí Type (Œî ,, Œ∫‚ÇÅ) Œ∫‚ÇÇ
weaken‚Çñ = ren‚Çñ S

weakenPred‚Çñ : Pred Type Œî R[ Œ∫‚ÇÇ ] ‚Üí Pred Type (Œî ,, Œ∫‚ÇÅ) R[ Œ∫‚ÇÇ ]
weakenPred‚Çñ = renPred‚Çñ S
\end{code}

A substitution is a map from type variables to types.

\begin{code}
Substitution‚Çñ : KEnv ‚Üí KEnv ‚Üí Set
Substitution‚Çñ Œî‚ÇÅ Œî‚ÇÇ = ‚àÄ {Œ∫} ‚Üí TVar Œî‚ÇÅ Œ∫ ‚Üí Type Œî‚ÇÇ Œ∫
\end{code}

\Ni Parallel renaming and substitution is likewise standard for this approach, and so definitions are omitted. As will become a theme, we must show that substitution preserves row well-orderedness.

\begin{code}[hide]
lifts‚Çñ :  Substitution‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí Substitution‚Çñ(Œî‚ÇÅ ,, Œ∫) (Œî‚ÇÇ ,, Œ∫)
sub‚Çñ : Substitution‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí Type Œî‚ÇÅ Œ∫ ‚Üí Type Œî‚ÇÇ Œ∫
subPred‚Çñ : Substitution‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí Pred Type Œî‚ÇÅ Œ∫ ‚Üí Pred Type Œî‚ÇÇ Œ∫
subRow‚Çñ : Substitution‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí SimpleRow Type Œî‚ÇÅ R[ Œ∫ ] ‚Üí SimpleRow Type Œî‚ÇÇ R[ Œ∫ ]
\end{code}
\begin{code}
orderedSubRow‚Çñ : (œÉ : Substitution‚Çñ Œî‚ÇÅ Œî‚ÇÇ) ‚Üí (xs : SimpleRow Type Œî‚ÇÅ R[ Œ∫ ]) ‚Üí Ordered xs ‚Üí 
                 Ordered (subRow‚Çñ œÉ xs)
\end{code} 

\begin{code}[hide]
-- lifting a substitution over binders.
lifts‚Çñ œÉ Z = ` Z
lifts‚Çñ œÉ (S x) = weaken‚Çñ (œÉ x)

sub‚Çñ œÉ (` x) = œÉ x
sub‚Çñ œÉ (`Œª œÑ) = `Œª (sub‚Çñ (lifts‚Çñ œÉ) œÑ)
sub‚Çñ œÉ (œÑ‚ÇÅ ¬∑ œÑ‚ÇÇ) = (sub‚Çñ œÉ œÑ‚ÇÅ) ¬∑ (sub‚Çñ œÉ œÑ‚ÇÇ)
sub‚Çñ œÉ (œÑ‚ÇÅ `‚Üí œÑ‚ÇÇ) = (sub‚Çñ œÉ œÑ‚ÇÅ) `‚Üí (sub‚Çñ œÉ œÑ‚ÇÇ)
sub‚Çñ œÉ (œÄ ‚áí œÑ) = subPred‚Çñ œÉ œÄ ‚áí sub‚Çñ œÉ œÑ 
sub‚Çñ œÉ (`‚àÄ œÑ) = `‚àÄ (sub‚Çñ (lifts‚Çñ œÉ) œÑ)
sub‚Çñ œÉ (Œº F) = Œº (sub‚Çñ œÉ F)
sub‚Çñ œÉ (Œ† {notLabel = nl}) = Œ† {notLabel = nl}
sub‚Çñ œÉ (Œ£ {notLabel = nl}) = Œ£ {notLabel = nl}
sub‚Çñ œÉ (lab x) = lab x
sub‚Çñ œÉ ‚åä ‚Ñì ‚åã = ‚åä (sub‚Çñ œÉ ‚Ñì) ‚åã
sub‚Çñ œÉ (f <$> a) = sub‚Çñ œÉ f <$> sub‚Çñ œÉ a
sub‚Çñ œÉ (œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) = sub‚Çñ œÉ œÅ‚ÇÇ ‚îÄ sub‚Çñ œÉ œÅ‚ÇÅ
sub‚Çñ œÉ (‚¶Ö xs ‚¶Ü oxs) = ‚¶Ö subRow‚Çñ œÉ xs ‚¶Ü (fromWitness (orderedSubRow‚Çñ œÉ xs (toWitness oxs)))
sub‚Çñ œÉ (l ‚ñπ œÑ) = (sub‚Çñ œÉ l) ‚ñπ (sub‚Çñ œÉ œÑ)
subRow‚Çñ œÉ [] = [] 
subRow‚Çñ œÉ ((l , œÑ) ‚à∑ xs) = (l , sub‚Çñ œÉ œÑ) ‚à∑ subRow‚Çñ œÉ xs

orderedSubRow‚Çñ r [] oxs = tt
orderedSubRow‚Çñ r ((l , œÑ) ‚à∑ []) oxs = tt
orderedSubRow‚Çñ r ((l‚ÇÅ , œÑ) ‚à∑ (l‚ÇÇ , œÖ) ‚à∑ xs) (l‚ÇÅ<l‚ÇÇ , oxs) = l‚ÇÅ<l‚ÇÇ , orderedSubRow‚Çñ r ((l‚ÇÇ , œÖ) ‚à∑ xs) oxs

subRow‚Çñ-isMap : ‚àÄ (œÉ : Substitution‚Çñ Œî‚ÇÅ Œî‚ÇÇ) (xs : SimpleRow Type Œî‚ÇÅ R[ Œ∫ ]) ‚Üí 
                  subRow‚Çñ œÉ xs ‚â° map (over·µ£ (sub‚Çñ œÉ)) xs

subRow‚Çñ-isMap œÉ [] = refl
subRow‚Çñ-isMap œÉ (x ‚à∑ xs) = cong‚ÇÇ _‚à∑_ refl (subRow‚Çñ-isMap œÉ xs)

subPred‚Çñ œÉ (œÅ‚ÇÅ ¬∑ œÅ‚ÇÇ ~ œÅ‚ÇÉ) = sub‚Çñ œÉ œÅ‚ÇÅ ¬∑ sub‚Çñ œÉ œÅ‚ÇÇ ~ sub‚Çñ œÉ œÅ‚ÇÉ
subPred‚Çñ œÉ (œÅ‚ÇÅ ‚â≤ œÅ‚ÇÇ) = (sub‚Çñ œÉ œÅ‚ÇÅ) ‚â≤ (sub‚Çñ œÉ œÅ‚ÇÇ) 
\end{code} 

Two operations of note: extension of a substitution \verb!œÉ! appends a new type \verb!A! as the zero'th De Bruijn index. \verb!Œ≤!-substitution is a special case of substitution in which we only substitute the most recently freed variable.

\begin{code} 
extend‚Çñ : Substitution‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí (A : Type Œî‚ÇÇ Œ∫) ‚Üí Substitution‚Çñ (Œî‚ÇÅ ,, Œ∫) Œî‚ÇÇ
extend‚Çñ œÉ A Z = A
extend‚Çñ œÉ A (S x) = œÉ x

_Œ≤‚Çñ[_] : Type (Œî ,, Œ∫‚ÇÅ) Œ∫‚ÇÇ ‚Üí Type Œî Œ∫‚ÇÅ ‚Üí Type Œî Œ∫‚ÇÇ
B Œ≤‚Çñ[ A ] = sub‚Çñ (extend‚Çñ ` A) B
\end{code}

\subsection{Type equivalence}

We define reduction on types $\tau \RedT \tau'$ by directing the following type equivalence judgment $\TEqvJ \Delta \tau {\tau'} \kappa$ from left to right. We equate types under the relation \verb!_‚â°t_!, predicates under the relation \verb!_‚â°p_!, and row literals under the relation \verb!_‚â°r_!.

\begin{code}[hide]
infix 0 _‚â°t_
infix 0 _‚â°p_
\end{code}
\begin{code}
data _‚â°p_ : Pred Type Œî R[ Œ∫ ] ‚Üí Pred Type Œî R[ Œ∫ ] ‚Üí Set
data _‚â°t_ : Type Œî Œ∫ ‚Üí Type Œî Œ∫ ‚Üí Set 
data _‚â°r_ : SimpleRow Type Œî R[ Œ∫ ] ‚Üí SimpleRow Type Œî R[ Œ∫ ] ‚Üí Set
\end{code} 

Declare the following as generalized metavariables to reduce clutter. (N.b., generalized variables in Agda are not dependent upon eachother, e.g., it is not true that \verb!œÅ‚ÇÅ! and \verb!œÅ‚ÇÇ! must have equal kinds when \verb!œÅ‚ÇÅ! and \verb!œÅ‚ÇÇ! appear in the same type signature.)
\begin{code} 
private
    variable
        ‚Ñì ‚Ñì‚ÇÅ ‚Ñì‚ÇÇ ‚Ñì‚ÇÉ : Label
        l l‚ÇÅ l‚ÇÇ l‚ÇÉ : Type Œî L
        œÅ‚ÇÅ œÅ‚ÇÇ œÅ‚ÇÉ   : Type Œî R[ Œ∫ ]
        œÄ‚ÇÅ œÄ‚ÇÇ    : Pred Type Œî R[ Œ∫ ]
        œÑ œÑ‚ÇÅ œÑ‚ÇÇ œÑ‚ÇÉ œÖ œÖ‚ÇÅ œÖ‚ÇÇ œÖ‚ÇÉ : Type Œî Œ∫ 
\end{code}

\Ni Row literals and predicates are equated in an obvious fashion.

\begin{code}
data _‚â°r_ where 
  eq-[] : _‚â°r_  {Œî = Œî} {Œ∫ = Œ∫} [] []
  eq-cons : {xs ys : SimpleRow Type Œî R[ Œ∫ ]} ‚Üí 
    ‚Ñì‚ÇÅ ‚â° ‚Ñì‚ÇÇ ‚Üí œÑ‚ÇÅ ‚â°t œÑ‚ÇÇ ‚Üí xs ‚â°r ys ‚Üí 
    ((‚Ñì‚ÇÅ , œÑ‚ÇÅ) ‚à∑ xs) ‚â°r ((‚Ñì‚ÇÇ , œÑ‚ÇÇ) ‚à∑ ys)

data _‚â°p_ where
  _eq-‚â≤_ : œÑ‚ÇÅ ‚â°t œÖ‚ÇÅ ‚Üí œÑ‚ÇÇ ‚â°t œÖ‚ÇÇ ‚Üí œÑ‚ÇÅ ‚â≤ œÑ‚ÇÇ ‚â°p  œÖ‚ÇÅ ‚â≤ œÖ‚ÇÇ
  _eq-¬∑_~_ : œÑ‚ÇÅ ‚â°t œÖ‚ÇÅ ‚Üí œÑ‚ÇÇ ‚â°t œÖ‚ÇÇ ‚Üí œÑ‚ÇÉ ‚â°t œÖ‚ÇÉ ‚Üí 
             œÑ‚ÇÅ ¬∑ œÑ‚ÇÇ ~ œÑ‚ÇÉ ‚â°p  œÖ‚ÇÅ ¬∑ œÖ‚ÇÇ ~ œÖ‚ÇÉ
\end{code}

The first three type equivalence rules enforce that \verb!_‚â°t_! forms an equivalence relation.
\begin{code}
data _‚â°t_ where 
    eq-refl : œÑ ‚â°t œÑ 
    eq-sym : œÑ‚ÇÅ ‚â°t œÑ‚ÇÇ ‚Üí œÑ‚ÇÇ ‚â°t œÑ‚ÇÅ
    eq-trans : œÑ‚ÇÅ ‚â°t œÑ‚ÇÇ ‚Üí œÑ‚ÇÇ ‚â°t œÑ‚ÇÉ ‚Üí œÑ‚ÇÅ ‚â°t œÑ‚ÇÉ
\end{code} 

\Ni We next have a number of congruence rules. As this is type-level normalization, we equate under binders such as \verb!Œª! and \verb!‚àÄ!. The rule for congruence under \verb!Œª! bindings is below; the remaining congruence rules are omitted.
\begin{code}
    eq-Œª : ‚àÄ {œÑ œÖ : Type (Œî ,, Œ∫‚ÇÅ) Œ∫‚ÇÇ} ‚Üí œÑ ‚â°t œÖ ‚Üí `Œª œÑ ‚â°t `Œª œÖ
\end{code}
\begin{code}[hide]
    eq-‚Üí : 

        œÑ‚ÇÅ ‚â°t œÑ‚ÇÇ ‚Üí œÖ‚ÇÅ ‚â°t œÖ‚ÇÇ ‚Üí
        -----------------------
        œÑ‚ÇÅ `‚Üí œÖ‚ÇÅ ‚â°t œÑ‚ÇÇ `‚Üí œÖ‚ÇÇ

    eq-‚àÄ : 

        œÑ ‚â°t œÖ ‚Üí
        ----------------
        `‚àÄ œÑ ‚â°t `‚àÄ œÖ

    eq-Œº : 

        œÑ ‚â°t œÖ ‚Üí
        ----------------
        Œº œÑ ‚â°t Œº œÖ

    eq-¬∑ :

        œÑ‚ÇÅ ‚â°t œÖ‚ÇÅ ‚Üí œÑ‚ÇÇ ‚â°t œÖ‚ÇÇ ‚Üí
        ---------------------
        œÑ‚ÇÅ ¬∑ œÑ‚ÇÇ ‚â°t œÖ‚ÇÅ ¬∑ œÖ‚ÇÇ

    eq-<$> : ‚àÄ {œÑ‚ÇÅ œÖ‚ÇÅ : Type Œî (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ)} {œÑ‚ÇÇ œÖ‚ÇÇ : Type Œî R[ Œ∫‚ÇÅ ]} ‚Üí 

        œÑ‚ÇÅ ‚â°t œÖ‚ÇÅ ‚Üí œÑ‚ÇÇ ‚â°t œÖ‚ÇÇ ‚Üí
        ---------------------
        œÑ‚ÇÅ <$> œÑ‚ÇÇ ‚â°t œÖ‚ÇÅ <$> œÖ‚ÇÇ        

    eq-‚åä‚åã : 

        œÑ ‚â°t œÖ ‚Üí
        -------------
        ‚åä œÑ ‚åã ‚â°t ‚åä œÖ ‚åã

    eq-‚áí :

         œÄ‚ÇÅ ‚â°p œÄ‚ÇÇ ‚Üí œÑ‚ÇÅ ‚â°t œÑ‚ÇÇ ‚Üí
        ------------------------
        (œÄ‚ÇÅ ‚áí œÑ‚ÇÅ) ‚â°t (œÄ‚ÇÇ ‚áí œÑ‚ÇÇ)

    eq-lab : 
           
           ‚Ñì‚ÇÅ ‚â° ‚Ñì‚ÇÇ ‚Üí
           -------------
           lab {Œî = Œî} ‚Ñì‚ÇÅ ‚â°t lab ‚Ñì‚ÇÇ
    
    eq-row : 
        ‚àÄ {œÅ‚ÇÅ œÅ‚ÇÇ : SimpleRow Type Œî R[ Œ∫ ]} {oœÅ‚ÇÅ : True (ordered? œÅ‚ÇÅ)} 
          {oœÅ‚ÇÇ : True (ordered? œÅ‚ÇÇ)} ‚Üí 
  
        œÅ‚ÇÅ ‚â°r œÅ‚ÇÇ ‚Üí 
        -------------------------------------------
        ‚¶Ö œÅ‚ÇÅ ‚¶Ü oœÅ‚ÇÅ ‚â°t ‚¶Ö œÅ‚ÇÇ ‚¶Ü oœÅ‚ÇÇ

    eq-‚ñπ : ‚àÄ {l‚ÇÅ l‚ÇÇ : Type Œî L} {œÑ‚ÇÅ œÑ‚ÇÇ : Type Œî Œ∫} ‚Üí 
         
           l‚ÇÅ ‚â°t l‚ÇÇ   ‚Üí    œÑ‚ÇÅ ‚â°t œÑ‚ÇÇ ‚Üí 
           ------------------------------------
           (l‚ÇÅ ‚ñπ œÑ‚ÇÅ) ‚â°t (l‚ÇÇ ‚ñπ œÑ‚ÇÇ)

    eq-‚îÄ : ‚àÄ {œÅ‚ÇÇ œÅ‚ÇÅ œÖ‚ÇÇ œÖ‚ÇÅ : Type Œî R[ Œ∫ ]} ‚Üí 
         
           œÅ‚ÇÇ ‚â°t œÖ‚ÇÇ   ‚Üí    œÅ‚ÇÅ ‚â°t œÖ‚ÇÅ ‚Üí 
           ------------------------------------
           (œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) ‚â°t (œÖ‚ÇÇ ‚îÄ œÖ‚ÇÅ)
\end{code} 

We have two "expansion" rules and one composition rule. Firstly, arrow-kinded types are $\eta$-expanded to have an outermost lambda binding. This later ensures canonicity of arrow-kinded types. 

\begin{code}    
    eq-Œ∑ : ‚àÄ {f : Type Œî (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ)} ‚Üí f ‚â°t `Œª (weaken‚Çñ f ¬∑ (` Z))
\end{code}

\Ni Analogously, row-kinded variables left alone are expanded to a map by the identity function. Additionally, nested maps are composed together into one map. These rules together ensure canonical forms for row-kinded normal types. Observe that the last two rules are effectively functorial laws.

\begin{code}    
    eq-map-id : ‚àÄ {Œ∫} {œÑ : Type Œî R[ Œ∫ ]} ‚Üí œÑ ‚â°t (`Œª {Œ∫‚ÇÅ = Œ∫} (` Z)) <$> œÑ
    eq-map-‚àò : ‚àÄ {Œ∫‚ÇÉ} {f : Type Œî (Œ∫‚ÇÇ `‚Üí Œ∫‚ÇÉ)} {g : Type Œî (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ)} {œÑ : Type Œî R[ Œ∫‚ÇÅ ]} ‚Üí 
      (f <$> (g <$> œÑ))  ‚â°t (`Œª (weaken‚Çñ f ¬∑ (weaken‚Çñ g ¬∑ (` Z)))) <$> œÑ 
\end{code}

We now describe the computational rules that incur type reduction. Rule \verb!eq-Œ≤! is the usual $\beta$-reduction rule. Rule \verb!eq-labTy! asserts that the constructor \verb!_‚ñπ_! is indeed superfluous when describing singleton rows with a label literal; singleton rows of the form \verb!(‚Ñì ‚ñπ œÑ)! are normalized into row literals. 
\begin{code}
    eq-Œ≤ : ‚àÄ {œÑ‚ÇÅ : Type (Œî ,, Œ∫‚ÇÅ) Œ∫‚ÇÇ} {œÑ‚ÇÇ : Type Œî Œ∫‚ÇÅ} ‚Üí 
      ((`Œª œÑ‚ÇÅ) ¬∑ œÑ‚ÇÇ) ‚â°t (œÑ‚ÇÅ Œ≤‚Çñ[ œÑ‚ÇÇ ])
    eq-labTy : l ‚â°t lab ‚Ñì ‚Üí (l ‚ñπ œÑ) ‚â°t ‚¶Ö [ (‚Ñì  , œÑ) ] ‚¶Ü tt
\end{code} 

\Ni The rule \verb!eq-‚ñπ$! describes that mapping \verb!F! over a singleton row is simply application of \verb!F! over the row's contents. Rule \verb!eq-map! asserts exactly the same except for row literals; the function \verb!over·µ£! (definition omitted) is simply fmap over a pair's right component. Rule \verb!eq-<$>-‚îÄ! asserts that mapping \verb!F! over a row complement is distributive. 

\begin{code}
    eq-‚ñπ$ : ‚àÄ {l} {œÑ : Type Œî Œ∫‚ÇÅ} {F : Type Œî (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ)} ‚Üí 
      (F <$> (l ‚ñπ œÑ)) ‚â°t (l ‚ñπ (F ¬∑ œÑ))
    eq-map : ‚àÄ {F : Type Œî (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ)} {œÅ : SimpleRow Type Œî R[ Œ∫‚ÇÅ ]} {oœÅ : True (ordered? œÅ)} ‚Üí 
         F <$> (‚¶Ö œÅ ‚¶Ü oœÅ) ‚â°t ‚¶Ö map (over·µ£ (F ¬∑_)) œÅ ‚¶Ü (fromWitness (map-over·µ£ œÅ (F ¬∑_) (toWitness oœÅ)))      
    eq-<$>-‚îÄ : ‚àÄ {F : Type Œî (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ)} {œÅ‚ÇÇ œÅ‚ÇÅ : Type Œî R[ Œ∫‚ÇÅ ]} ‚Üí 
      F <$> (œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) ‚â°t (F <$> œÅ‚ÇÇ) ‚îÄ (F <$> œÅ‚ÇÅ)
\end{code} 

\Ni The rules \verb!eq-Œ†! and \verb!eq-Œ£! give the defining equations of \verb!Œ†! and \verb!Œ£! at nested row kind. This is to say, application of \verb!Œ†! to a nested row is equivalent to mapping \verb!Œ†! over the row.
\begin{code} 
    eq-Œ† : ‚àÄ {œÅ : Type Œî R[ R[ Œ∫ ] ]} {nl : True (notLabel? Œ∫)} ‚Üí 
         Œ† {notLabel = nl} ¬∑ œÅ ‚â°t Œ† {notLabel = nl} <$> œÅ
    eq-Œ£ : ‚àÄ {œÅ : Type Œî R[ R[ Œ∫ ] ]} {nl : True (notLabel? Œ∫)} ‚Üí 
         Œ£ {notLabel = nl} ¬∑ œÅ ‚â°t Œ£ {notLabel = nl} <$> œÅ
\end{code}

\Ni The next two rules assert that \verb!Œ†! and \verb!Œ£! can reassociate from left-to-right except with the new right-applicand "flapped".
\begin{code} 
    eq-Œ†-assoc : ‚àÄ {œÅ : Type Œî (R[ Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ ])} {œÑ : Type Œî Œ∫‚ÇÅ} {nl : True (notLabel? Œ∫‚ÇÇ)} ‚Üí 
        (Œ† {notLabel = nl} ¬∑ œÅ) ¬∑ œÑ ‚â°t Œ† {notLabel = nl} ¬∑ (œÅ ?? œÑ)
    eq-Œ£-assoc : ‚àÄ {œÅ : Type Œî (R[ Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ ])} {œÑ : Type Œî Œ∫‚ÇÅ} {nl : True (notLabel? Œ∫‚ÇÇ)} ‚Üí 
        (Œ£ {notLabel = nl} ¬∑ œÅ) ¬∑ œÑ ‚â°t Œ£ {notLabel = nl} ¬∑ (œÅ ?? œÑ)
\end{code}

\Ni Finally, the rule \verb!eq-compl! gives computational content to the relative row complement operator applied to row literals.

\begin{code} 
    eq-compl : ‚àÄ {xs ys : SimpleRow Type Œî R[ Œ∫ ]} 
      {oxs : True (ordered? xs)} {oys : True (ordered? ys)} {ozs : True (ordered? (xs ‚îÄs ys))} ‚Üí 
      (‚¶Ö xs ‚¶Ü oxs) ‚îÄ (‚¶Ö ys ‚¶Ü oys) ‚â°t ‚¶Ö (xs ‚îÄs ys) ‚¶Ü ozs
\end{code}

Before concluding, we share an auxiliary definition that reflects instances of propositional equality in Agda to proofs of type-equivalence. The same role could be performed via Agda's \verb!subst! but without the convenience.

\begin{code}
inst : ‚àÄ {œÑ‚ÇÅ œÑ‚ÇÇ : Type Œî Œ∫} ‚Üí œÑ‚ÇÅ ‚â° œÑ‚ÇÇ ‚Üí œÑ‚ÇÅ ‚â°t œÑ‚ÇÇ 
inst refl = eq-refl
\end{code}

\subsubsection{Some admissable rules} In early versions of this equivalence relation, we thought it would be necessary to impose the following two rules directly. However, we can confirm their admissability. The first rule states that $\Pi$ is mapped over nested rows, and the second (definition omitted) states that $\lambda$-bindings $\eta$-expand over $\Pi$. (These results hold identically for \verb!Œ£!.)

\begin{code}
eq-Œ†‚ñπ : ‚àÄ {l} {œÑ : Type Œî R[ Œ∫ ]}{nl : True (notLabel? Œ∫)} ‚Üí 
        (Œ† {notLabel = nl} ¬∑ (l ‚ñπ œÑ)) ‚â°t (l ‚ñπ (Œ† {notLabel = nl} ¬∑ œÑ))
eq-Œ†‚ñπ = eq-trans eq-Œ† eq-‚ñπ$

eq-Œ†Œª : ‚àÄ {l} {œÑ : Type (Œî ,, Œ∫‚ÇÅ) Œ∫‚ÇÇ} {nl : True (notLabel? Œ∫‚ÇÇ)} ‚Üí 
        Œ† {notLabel = nl} ¬∑ (l ‚ñπ `Œª œÑ) ‚â°t `Œª (Œ† {notLabel = nl} ¬∑ (weaken‚Çñ l ‚ñπ œÑ))
\end{code}
\begin{code}[hide]
eq-Œ†Œª = bot _
\end{code}


\section{Normal forms}

By directing the type equivalence relation we define computation on types. This serves as a sort of specification on the shape normal forms of types ought to have. Our grammar for normal types must be carefully crafted so as to be neither too "large" nor too "small". In particular, we wish our normalization algorithm to be \emph{stable}, which implies surjectivity. Hence if the normal syntax is too large---i.e., it produces junk types---then these junk types will have pre-images in the domain of normalization. Inversely, if the normal syntax is too small, then there will be types whose normal forms cannot be expressed. \Cref{fig:type-normalization} specifies the syntax and typing of normal types, given as reference. We describe the syntax in more depth by describing its intrinsic mechanization.

\begin{figure}[H]
\begin{gather*}
\begin{array}{r@{\hspace{7px}}l@{\qquad\qquad}r@{\hspace{7px}}l}
  \text{Type variables} & \alpha \in \mathcal A &
  \text{Labels} & \ell \in \mathcal L
\end{array} \\
\begin{doublesyntaxarray}
  \mcl{\text{Ground Kinds}}  & \gamma   & ::= & \TypeK \mid \LabK \\
  \mcl{\text{Kinds}}         & \kappa    & ::= & \gamma \mid \kappa \to \kappa \mid  \RowK \kappa \\
  \mcl{\text{Row Literals}}   & \NormalRows \ni \Normal \rho    & ::= & \RowIx i 0 m {\LabTy {\ell_i} {\Normal {\tau_i}}} \\
  \mcl{\text{Neutral Types}} & n    & ::= & \alpha \mid n \, {\Normal \tau}  \\
  \mcl{\text{Normal Types}}  & \NormalTypes \ni \Normal \tau, \Normal \phi & ::= & n \mid \Mapp {\hat{\phi}} {n} \mid \Normal{\rho} \mid \Normal{\pi} \then \Normal{\tau} \mid \forall \alpha\co\kappa. \Normal{\tau} \mid \lambda \alpha\co\kappa. \Normal{\tau} \\
                             &       &     & \mid & \LabTy n {\Normal \tau} \mid \ell \mid \Sing {\Normal \tau} \mid {\Normal \tau} \Compl {\Normal \tau} \mid \Pi \, {\Normal \tau} \mid \Sigma \, {\Normal \tau}  \\
\end{doublesyntaxarray}
\end{gather*}
\caption{Normal type forms}
\label{fig:type-normalization}
\end{figure}

\subsection{Mechanized syntax}

We define \verb!NormalType!s and \verb!NormalPred!s analogously to \verb!Type!s and \verb!Pred!s. Recall that \verb!Pred! and \verb!SimpleRow! are indexed by the type of their contents, so we can reuse some code.

\begin{code}
data NormalType (Œî : KEnv) : Kind ‚Üí Set
NormalPred : KEnv ‚Üí Kind ‚Üí Set 
NormalPred = Pred NormalType
\end{code}

We must declare an analogous orderedness predicate, this time for normal types. Its definition is nearly identical.

\begin{code}
NormalOrdered : SimpleRow NormalType Œî R[ Œ∫ ] ‚Üí Set 
normalOrdered? : ‚àÄ (xs : SimpleRow NormalType Œî R[ Œ∫ ]) ‚Üí Dec (NormalOrdered xs)
\end{code}

Further, we define the predicate \verb!NotSimpleRow œÅ! to be true precisely when \verb!œÅ! is not a simple row. This is necessary because the row complement \verb!œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ! should reduce when each $\rho_i$ is a row literal. So it is necessary when forming normal row-complements to specify that at least one of the complement operands is a non-literal. The predicate \verb!True (notSimpleRows? œÅ‚ÇÅ œÅ‚ÇÇ)! is satisfied precisely in this case.

\begin{code}
NotSimpleRow : NormalType Œî R[ Œ∫ ] ‚Üí Set 
notSimpleRows? : ‚àÄ (œÑ‚ÇÅ œÑ‚ÇÇ : NormalType Œî R[ Œ∫ ]) ‚Üí 
                 Dec (NotSimpleRow œÑ‚ÇÅ or NotSimpleRow œÑ‚ÇÇ)
\end{code}

Neutral types are type variables and applications with type variables in head position.

\begin{code}
data NeutralType Œî : Kind ‚Üí Set where
  ` : (Œ± : TVar Œî Œ∫) ‚Üí  NeutralType Œî Œ∫
  _¬∑_ : (f : NeutralType Œî (Œ∫‚ÇÅ `‚Üí Œ∫)) ‚Üí (œÑ : NormalType Œî Œ∫‚ÇÅ) ‚Üí 
        NeutralType Œî Œ∫
\end{code}

We define the normal type syntax firstly by restricting the promotion of neutral types to normal forms at only \emph{ground} kind.

\begin{code}
data NormalType Œî where
  ne : (x : NeutralType Œî Œ∫) ‚Üí {ground : True (ground? Œ∫)} ‚Üí NormalType Œî Œ∫
\end{code}

As discussed above, we restrict the formation of inert row complements to just those in which at least one operand is non-literal.

\begin{code}
  _‚îÄ_ : (œÅ‚ÇÇ œÅ‚ÇÅ : NormalType Œî R[ Œ∫ ]) ‚Üí {nsr : True (notSimpleRows? œÅ‚ÇÇ œÅ‚ÇÅ)} ‚Üí 
        NormalType Œî R[ Œ∫ ]
\end{code}

We define inert maps as part of the \verb!NormalType! syntax rather than the \verb!NeutralType! syntax. Observe that a consequence of this decision (as opposed to letting the form \verb!_<$>_! be neutral) is that all inert maps must have the mapped function composed into just one applicand. For example, the type \verb!œÜ‚ÇÇ <$> (œÜ‚ÇÅ n)! must recompose into \verb!(`Œª Œ±. (œÜ‚ÇÇ (œÜ‚ÇÅ Œ±)) <$> n! to be in normal form.
 
\begin{code}
  _<$>_ : (œÜ : NormalType Œî (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ)) ‚Üí NeutralType Œî R[ Œ∫‚ÇÅ ] ‚Üí NormalType Œî R[ Œ∫‚ÇÇ ]
\end{code}

\Ni we need only permit the formation of records and variants at kind \verb!‚òÖ!, and we restrict the formation of neutral-labeled rows to just the singleton constructor \verb!_‚ñπ‚Çô_!.

\begin{code}
  Œ†  : (œÅ : NormalType Œî R[ ‚òÖ ]) ‚Üí NormalType Œî ‚òÖ
  Œ£  : (œÅ : NormalType Œî R[ ‚òÖ ]) ‚Üí NormalType Œî ‚òÖ
  _‚ñπ‚Çô_ : (l : NeutralType Œî L) (œÑ : NormalType Œî Œ∫) ‚Üí NormalType Œî R[ Œ∫ ]
\end{code}

The remaining cases are identical to the regular \verb!Type! syntax and omitted.

\begin{code}[hide]
  `Œª :

      (œÑ : NormalType (Œî ,, Œ∫‚ÇÅ) Œ∫‚ÇÇ) ‚Üí 
      --------------------------
      NormalType Œî (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ)

  _`‚Üí_ : 

      (œÑ‚ÇÅ œÑ‚ÇÇ : NormalType Œî ‚òÖ) ‚Üí
      -----------------
      NormalType Œî ‚òÖ

  `‚àÄ    :
      
      (œÑ : NormalType (Œî ,, Œ∫) ‚òÖ) ‚Üí
      --------------------------------------
      NormalType Œî ‚òÖ

  Œº     :
      
      (œÜ : NormalType Œî (‚òÖ `‚Üí ‚òÖ)) ‚Üí
      -------------------------
      NormalType Œî ‚òÖ

  ------------------------------------------------------------------
  -- Qualified types

  _‚áí_ : 

         (œÄ : NormalPred Œî R[ Œ∫‚ÇÅ ]) ‚Üí (œÑ : NormalType Œî ‚òÖ) ‚Üí 
         ---------------------
         NormalType Œî ‚òÖ       

  ------------------------------------------------------------------
  -- Rœâ business


  ‚¶Ö_‚¶Ü : (œÅ : SimpleRow NormalType Œî R[ Œ∫ ]) ‚Üí (oœÅ : True (normalOrdered? œÅ)) ‚Üí
        ----------------------
       NormalType Œî R[ Œ∫ ]

--   -- labels
  lab :
    
      (l : Label) ‚Üí 
      --------
      NormalType Œî L

  -- label constant formation
  ‚åä_‚åã :
      (l : NormalType Œî L) ‚Üí
      -----------------
      NormalType Œî ‚òÖ
\end{code}

\begin{code}[hide]
open IsStrictPartialOrder (SPO) renaming (trans to <-trans)

NormalOrdered [] = ‚ä§
NormalOrdered ((l , _) ‚à∑ []) = ‚ä§
NormalOrdered ((l‚ÇÅ , _) ‚à∑ (l‚ÇÇ , œÑ) ‚à∑ xs) = l‚ÇÅ < l‚ÇÇ √ó NormalOrdered ((l‚ÇÇ , œÑ) ‚à∑ xs)

normalOrdered? [] = yes tt
normalOrdered? ((l , œÑ) ‚à∑ []) = yes tt
normalOrdered? ((l‚ÇÅ , _) ‚à∑ (l‚ÇÇ , _) ‚à∑ xs) with l‚ÇÅ <? l‚ÇÇ | normalOrdered? ((l‚ÇÇ , _) ‚à∑ xs)
... | yes p | yes q  = yes (p , q)
... | yes p | no q  = no (Œª { (_ , oxs) ‚Üí q oxs })
... | no p  | yes q  = no (Œª { (x , _) ‚Üí p x})
... | no  p | no  q  = no (Œª { (x , _) ‚Üí p x})
\end{code}

\begin{code}[hide]
NormalIrrelevantOrdered : ‚àÄ (œÅ : SimpleRow NormalType Œî R[ Œ∫ ]) ‚Üí Irrelevant (True (normalOrdered? œÅ))
NormalIrrelevantOrdered œÅ = Dec‚ÜíIrrelevant (NormalOrdered œÅ) (normalOrdered? œÅ)

cong-‚¶Ö‚¶Ü : {sr‚ÇÅ sr‚ÇÇ : SimpleRow NormalType Œî R[ Œ∫ ]} {wf‚ÇÅ : True (normalOrdered? sr‚ÇÅ)} {wf‚ÇÇ : True (normalOrdered? sr‚ÇÇ)} ‚Üí 
                 sr‚ÇÅ ‚â° sr‚ÇÇ ‚Üí 
                _‚â°_ {A = NormalType Œî R[ Œ∫ ]} (‚¶Ö sr‚ÇÅ ‚¶Ü wf‚ÇÅ) (‚¶Ö sr‚ÇÇ ‚¶Ü wf‚ÇÇ)
cong-‚¶Ö‚¶Ü {sr‚ÇÅ = sr‚ÇÅ} {_} {wf‚ÇÅ} {wf‚ÇÇ} refl rewrite NormalIrrelevantOrdered sr‚ÇÅ wf‚ÇÅ wf‚ÇÇ = refl


inj-‚¶Ö‚¶Ü : {sr‚ÇÅ sr‚ÇÇ : SimpleRow NormalType Œî R[ Œ∫ ]} 
         {wf‚ÇÅ : True (normalOrdered? sr‚ÇÅ)} 
         {wf‚ÇÇ : True (normalOrdered? sr‚ÇÇ)} ‚Üí 
         _‚â°_ {A = NormalType Œî R[ Œ∫ ]} (‚¶Ö sr‚ÇÅ ‚¶Ü wf‚ÇÅ) (‚¶Ö sr‚ÇÇ ‚¶Ü wf‚ÇÇ) ‚Üí 
         sr‚ÇÅ ‚â° sr‚ÇÇ
inj-‚¶Ö‚¶Ü {sr‚ÇÅ = sr‚ÇÅ} {_} {wf‚ÇÅ} {wf‚ÇÇ} refl rewrite NormalIrrelevantOrdered sr‚ÇÅ wf‚ÇÅ wf‚ÇÇ = refl
                

--------------------------------------------------------------------------------
-- Ordered lists yield ordered tails

normalOrdered-tail : ‚àÄ (x : Label √ó NormalType Œî Œ∫) (œÅ : SimpleRow NormalType Œî R[ Œ∫ ]) ‚Üí 
               NormalOrdered (x ‚à∑ œÅ) ‚Üí 
               NormalOrdered œÅ 
normalOrdered-tail x [] oxœÅ = tt
normalOrdered-tail (l , snd‚ÇÅ) ((l‚ÇÅ , snd‚ÇÇ) ‚à∑ œÅ) (_ , oxœÅ) = oxœÅ 

--------------------------------------------------------------------------------
-- Mapping over preserves ordering

normal-map-over·µ£ : ‚àÄ (œÅ : SimpleRow NormalType Œî‚ÇÅ R[ Œ∫‚ÇÅ ]) (f : NormalType Œî‚ÇÅ Œ∫‚ÇÅ ‚Üí NormalType Œî‚ÇÅ Œ∫‚ÇÇ) ‚Üí 
                   NormalOrdered œÅ ‚Üí NormalOrdered (map (over·µ£ f) œÅ)
normal-map-over·µ£ [] f oœÅ = tt
normal-map-over·µ£ (x ‚à∑ []) f oœÅ = tt
normal-map-over·µ£ ((l‚ÇÅ , _) ‚à∑ (l‚ÇÇ , _) ‚à∑ œÅ) f (l‚ÇÅ<l‚ÇÇ , oœÅ) = l‚ÇÅ<l‚ÇÇ , (normal-map-over·µ£ ((l‚ÇÇ , _) ‚à∑ œÅ) f oœÅ)
\end{code}

\begin{code}[hide]
NotSimpleRow (ne x) = ‚ä§
NotSimpleRow ((œÜ <$> œÑ)) = ‚ä§
NotSimpleRow (‚¶Ö œÅ ‚¶Ü oœÅ) = ‚ä•
NotSimpleRow (œÑ ‚îÄ œÑ‚ÇÅ) = ‚ä§
NotSimpleRow (x ‚ñπ‚Çô œÑ) = ‚ä§
\end{code}

\begin{code}[hide]
notSimpleRows? (ne x) _ = yes (left tt)
notSimpleRows? ((œÑ‚ÇÅ <$> œÅ)) _ = yes (left tt)
notSimpleRows? (‚¶Ö œÅ ‚¶Ü oœÅ) (ne x) = yes (right tt)
notSimpleRows? (‚¶Ö œÅ ‚¶Ü oœÅ) (‚¶Ö œÅ‚ÇÅ ‚¶Ü oœÅ‚ÇÅ) = no Œª { (left ()) ; (right ()) }
notSimpleRows? (‚¶Ö œÅ ‚¶Ü oœÅ) (œÅ‚ÇÅ ‚îÄ œÅ‚ÇÇ) = yes (right tt)
notSimpleRows? (‚¶Ö œÅ ‚¶Ü oœÅ) (x ‚ñπ‚Çô œÅ‚ÇÅ) = yes (right tt)
notSimpleRows? (‚¶Ö œÅ ‚¶Ü oœÅ) ((œÜ <$> _)) = yes (right tt)
notSimpleRows? (œÅ‚ÇÇ ‚îÄ œÅ‚ÇÉ) _ = yes (left tt)
notSimpleRows? (x ‚ñπ‚Çô œÅ‚ÇÇ) _ = yes (left tt)
\end{code}

\subsection{Canonicity of normal types}

The syntax of normal types is defined precisely so as to enjoy canonical forms based on kind. We first demonstrate that neutral types and inert complements cannot occur in empty contexts.

\begin{code}
noNeutrals : NeutralType ‚àÖ Œ∫ ‚Üí ‚ä•

noNeutrals (n ¬∑ œÑ) = noNeutrals n 

noComplements : ‚àÄ {œÅ‚ÇÅ œÅ‚ÇÇ œÅ‚ÇÉ : NormalType ‚àÖ R[ Œ∫ ]}
                  (nsr : True (notSimpleRows? œÅ‚ÇÉ œÅ‚ÇÇ)) ‚Üí 
                  œÅ‚ÇÅ ‚â° (œÅ‚ÇÉ ‚îÄ œÅ‚ÇÇ) {nsr} ‚Üí 
                  ‚ä•
\end{code}
\begin{code}[hide]
noComplements {œÅ‚ÇÅ = ne x‚ÇÅ ‚îÄ _} {_} {_} nsr refl = ‚ä•-elim (noNeutrals x‚ÇÅ)
noComplements {œÅ‚ÇÅ = ‚¶Ö œÅ ‚¶Ü oœÅ ‚îÄ ne x‚ÇÅ} {_} {_} nsr refl = ‚ä•-elim (noNeutrals x‚ÇÅ)
noComplements {œÅ‚ÇÅ = ‚¶Ö œÅ ‚¶Ü oœÅ ‚îÄ ((œÅ‚ÇÇ ‚îÄ œÅ‚ÇÉ) {nsr'})} {_} {_} nsr refl = noComplements {œÅ‚ÇÇ = œÅ‚ÇÉ} {œÅ‚ÇÇ} nsr' refl
noComplements {œÅ‚ÇÅ = ‚¶Ö œÅ ‚¶Ü oœÅ ‚îÄ (l ‚ñπ‚Çô œÅ‚ÇÇ)} {_} {_} nsr refl = ‚ä•-elim (noNeutrals l)
noComplements {œÅ‚ÇÅ = ‚¶Ö œÅ ‚¶Ü oœÅ ‚îÄ ((œÜ <$> œÑ))} {_} {_} nsr refl = ‚ä•-elim (noNeutrals œÑ)
noComplements {œÅ‚ÇÅ = ((œÅ‚ÇÉ ‚îÄ œÅ‚ÇÇ) {nsr'}) ‚îÄ _} {_} {_} nsr refl = noComplements {œÅ‚ÇÇ = œÅ‚ÇÇ} {œÅ‚ÇÉ} nsr' refl
noComplements {œÅ‚ÇÅ = (l ‚ñπ‚Çô œÅ‚ÇÉ) ‚îÄ _} {_} {_} nsr refl = ‚ä•-elim (noNeutrals l)
noComplements {œÅ‚ÇÅ = ((œÜ <$> œÑ)) ‚îÄ _} nsr refl = ‚ä•-elim (noNeutrals œÑ)
\end{code}

Now, in any context an arrow-kinded type is canonically $\lambda$-bound:

\begin{code}
arrow-canonicity : (f : NormalType Œî (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ)) ‚Üí ‚àÉ[ œÑ ] (f ‚â° `Œª œÑ)
arrow-canonicity (`Œª f) = f , refl
\end{code}

\Ni A row in an empty context is necessarily a row literal:

\begin{code}
row-canonicity-‚àÖ : (œÅ : NormalType ‚àÖ R[ Œ∫ ]) ‚Üí 
                    ‚àÉ[ xs ] Œ£[ oxs ‚àà True (normalOrdered? xs) ] 
                    (œÅ ‚â° ‚¶Ö xs ‚¶Ü oxs)
row-canonicity-‚àÖ (‚¶Ö œÅ ‚¶Ü oœÅ) = œÅ , oœÅ , refl
row-canonicity-‚àÖ (ne x) = ‚ä•-elim (noNeutrals x)
row-canonicity-‚àÖ ((œÅ ‚îÄ œÅ‚ÇÅ) {nsr}) = ‚ä•-elim (noComplements nsr refl)
row-canonicity-‚àÖ (l ‚ñπ‚Çô œÅ) = ‚ä•-elim (noNeutrals l)
row-canonicity-‚àÖ ((œÜ <$> œÅ)) = ‚ä•-elim (noNeutrals œÅ)
\end{code}

\Ni And a label-kinded type is necessarily a label literal:

\begin{code}
label-canonicity-‚àÖ : ‚àÄ (l : NormalType ‚àÖ L) ‚Üí ‚àÉ[ s ] (l ‚â° lab s)
label-canonicity-‚àÖ (ne x) = ‚ä•-elim (noNeutrals x)
label-canonicity-‚àÖ (lab s) = s , refl
\end{code}

\subsection{Renaming}

Renaming over normal types is defined in an entirely straightforward manner. Types and definitions are omitted.

\begin{code}[hide]
ren‚ÇñNE   : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí NeutralType Œî‚ÇÅ Œ∫ ‚Üí NeutralType Œî‚ÇÇ Œ∫
ren‚ÇñNF     : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí NormalType Œî‚ÇÅ Œ∫ ‚Üí NormalType Œî‚ÇÇ Œ∫
renRow‚ÇñNF : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí SimpleRow NormalType Œî‚ÇÅ R[ Œ∫ ] ‚Üí SimpleRow NormalType Œî‚ÇÇ R[ Œ∫ ]
renPred‚ÇñNF : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí NormalPred Œî‚ÇÅ R[ Œ∫ ] ‚Üí NormalPred Œî‚ÇÇ R[ Œ∫ ]
orderedRenRow‚ÇñNF : (r : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) ‚Üí (xs : SimpleRow NormalType Œî‚ÇÅ R[ Œ∫ ]) ‚Üí NormalOrdered xs ‚Üí 
                 NormalOrdered (renRow‚ÇñNF r xs)

nsrRen‚ÇñNF : ‚àÄ (r : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) (œÅ‚ÇÅ œÅ‚ÇÇ : NormalType Œî‚ÇÅ R[ Œ∫ ]) ‚Üí NotSimpleRow œÅ‚ÇÇ or NotSimpleRow œÅ‚ÇÅ ‚Üí 
              NotSimpleRow (ren‚ÇñNF r œÅ‚ÇÇ) or NotSimpleRow (ren‚ÇñNF r œÅ‚ÇÅ)
nsrRen‚ÇñNF' : ‚àÄ (r : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) (œÅ : NormalType Œî‚ÇÅ R[ Œ∫ ]) ‚Üí NotSimpleRow œÅ ‚Üí 
              NotSimpleRow (ren‚ÇñNF r œÅ)
\end{code}

\begin{code}[hide]
ren‚ÇñNE r (` x) = ` (r x)
ren‚ÇñNE œÅ (œÑ‚ÇÅ ¬∑ œÑ‚ÇÇ) = ren‚ÇñNE œÅ œÑ‚ÇÅ ¬∑ ren‚ÇñNF œÅ œÑ‚ÇÇ

ren‚ÇñNF œÅ (ne œÑ {g}) = ne (ren‚ÇñNE œÅ œÑ) {g}
ren‚ÇñNF œÅ (`Œª œÑ) = `Œª (ren‚ÇñNF (lift‚Çñ œÅ) œÑ)
ren‚ÇñNF œÅ (œÑ‚ÇÅ `‚Üí œÑ‚ÇÇ) = (ren‚ÇñNF œÅ œÑ‚ÇÅ) `‚Üí (ren‚ÇñNF œÅ œÑ‚ÇÇ)
ren‚ÇñNF œÅ (œÄ ‚áí œÑ) = renPred‚ÇñNF œÅ œÄ ‚áí ren‚ÇñNF œÅ œÑ
ren‚ÇñNF œÅ (`‚àÄ œÑ) = `‚àÄ (ren‚ÇñNF (lift‚Çñ œÅ) œÑ)
ren‚ÇñNF œÅ (Œº œÑ) = Œº (ren‚ÇñNF œÅ œÑ)
ren‚ÇñNF œÅ (lab x) = lab x
ren‚ÇñNF œÅ ‚åä ‚Ñì ‚åã = ‚åä (ren‚ÇñNF œÅ ‚Ñì) ‚åã
ren‚ÇñNF œÅ (Œ† œÑ) = Œ† (ren‚ÇñNF œÅ œÑ)
ren‚ÇñNF œÅ (Œ£ œÑ) = Œ£ (ren‚ÇñNF œÅ œÑ)
ren‚ÇñNF r (‚¶Ö œÅ ‚¶Ü oœÅ) = ‚¶Ö renRow‚ÇñNF r œÅ ‚¶Ü (fromWitness (orderedRenRow‚ÇñNF r œÅ (toWitness oœÅ)))
ren‚ÇñNF œÅ (l ‚ñπ‚Çô œÑ) = ren‚ÇñNE œÅ l ‚ñπ‚Çô (ren‚ÇñNF œÅ œÑ)
ren‚ÇñNF r ((œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) {nsr}) = (ren‚ÇñNF r œÅ‚ÇÇ ‚îÄ ren‚ÇñNF r œÅ‚ÇÅ) {nsr = fromWitness (nsrRen‚ÇñNF r œÅ‚ÇÅ œÅ‚ÇÇ (toWitness nsr))}
ren‚ÇñNF œÅ ((œÜ <$> x)) = (ren‚ÇñNF œÅ œÜ <$> ren‚ÇñNE œÅ x) 

renPred‚ÇñNF œÅ (œÅ‚ÇÅ ¬∑ œÅ‚ÇÇ ~ œÅ‚ÇÉ) = (ren‚ÇñNF œÅ œÅ‚ÇÅ) ¬∑ (ren‚ÇñNF œÅ œÅ‚ÇÇ) ~ (ren‚ÇñNF œÅ œÅ‚ÇÉ)
renPred‚ÇñNF œÅ (œÅ‚ÇÅ ‚â≤ œÅ‚ÇÇ) = (ren‚ÇñNF œÅ œÅ‚ÇÅ) ‚â≤ (ren‚ÇñNF œÅ œÅ‚ÇÇ)

renRow‚ÇñNF _ [] = []
renRow‚ÇñNF r ((l , œÑ) ‚à∑ œÅ) = (l , ren‚ÇñNF r œÑ) ‚à∑ renRow‚ÇñNF r œÅ

nsrRen‚ÇñNF' r (ne x) nsr = tt
nsrRen‚ÇñNF' r (œÅ ‚îÄ œÅ‚ÇÅ) nsr = tt
nsrRen‚ÇñNF' r (x ‚ñπ‚Çô œÅ) nsr = tt
nsrRen‚ÇñNF' r ((œÜ <$> œÅ)) nsr = tt

nsrRen‚ÇñNF r œÅ‚ÇÅ œÅ‚ÇÇ (left x) = left (nsrRen‚ÇñNF' r œÅ‚ÇÇ x)
nsrRen‚ÇñNF r œÅ‚ÇÅ œÅ‚ÇÇ (right y) = right (nsrRen‚ÇñNF' r œÅ‚ÇÅ y) 

orderedRenRow‚ÇñNF r [] oxs = tt
orderedRenRow‚ÇñNF r ((l , œÑ) ‚à∑ []) oxs = tt
orderedRenRow‚ÇñNF r ((l‚ÇÅ , œÑ) ‚à∑ (l‚ÇÇ , œÖ) ‚à∑ xs) (l‚ÇÅ<l‚ÇÇ , oxs) = l‚ÇÅ<l‚ÇÇ , orderedRenRow‚ÇñNF r ((l‚ÇÇ , œÖ) ‚à∑ xs) oxs

renRow‚ÇñNF-isMap : ‚àÄ (r : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) (xs : SimpleRow NormalType Œî‚ÇÅ R[ Œ∫ ]) ‚Üí 
                  renRow‚ÇñNF r xs ‚â° map (over·µ£ (ren‚ÇñNF r)) xs 
renRow‚ÇñNF-isMap r [] = refl
renRow‚ÇñNF-isMap r (x ‚à∑ xs) = cong‚ÇÇ _‚à∑_ refl (renRow‚ÇñNF-isMap r xs)

weaken‚ÇñNF : NormalType Œî Œ∫‚ÇÇ ‚Üí NormalType (Œî ,, Œ∫‚ÇÅ) Œ∫‚ÇÇ
weaken‚ÇñNF = ren‚ÇñNF S
weaken‚ÇñNE : NeutralType Œî Œ∫‚ÇÇ ‚Üí NeutralType (Œî ,, Œ∫‚ÇÅ) Œ∫‚ÇÇ
weaken‚ÇñNE = ren‚ÇñNE S 
weakenPred‚ÇñNF : NormalPred Œî R[ Œ∫‚ÇÇ ] ‚Üí NormalPred (Œî ,, Œ∫‚ÇÅ) R[ Œ∫‚ÇÇ ]
weakenPred‚ÇñNF = renPred‚ÇñNF S
\end{code}

\subsection{Embedding}

The goal is to normalize a given \verb!œÑ : Type Œî Œ∫! to a normal form at type \verb!NormalType Œî Œ∫!. It is of course much easier to first describe the inverse embedding, which recasts a normal form back to its original type. Definitions are expected and omitted. 

\begin{code}
‚áë : NormalType Œî Œ∫ ‚Üí Type Œî Œ∫
‚áëRow : SimpleRow NormalType Œî R[ Œ∫ ] ‚Üí SimpleRow Type Œî R[ Œ∫ ]
‚áëNE : NeutralType Œî Œ∫ ‚Üí Type Œî Œ∫
‚áëPred : NormalPred Œî R[ Œ∫ ] ‚Üí Pred Type Œî R[ Œ∫ ] 
\end{code}

Note that it is precisely in "embedding" the \verb!NormalOrdered! predicate that we establish half of the requisite isomorphism between a normal row being normal-ordered and its embedding being ordered. We will have to show the other half (that is, that ordered rows have normal-ordered evaluations) during normalization.

\begin{code}
Ordered‚áë : ‚àÄ (œÅ : SimpleRow NormalType Œî R[ Œ∫ ]) ‚Üí NormalOrdered œÅ ‚Üí 
             Ordered (‚áëRow œÅ)
\end{code}

\begin{code}[hide]
‚áë (ne x) = ‚áëNE x
‚áë (`Œª œÑ) = `Œª (‚áë œÑ)
‚áë (œÑ‚ÇÅ `‚Üí œÑ‚ÇÇ) = ‚áë œÑ‚ÇÅ `‚Üí ‚áë œÑ‚ÇÇ
‚áë (`‚àÄ œÑ) = `‚àÄ (‚áë œÑ)
‚áë (Œº œÑ) = Œº (‚áë œÑ)
‚áë (lab l) = lab l
‚áë ‚åä œÑ ‚åã = ‚åä ‚áë œÑ ‚åã
‚áë (Œ† x) = Œ† ¬∑ ‚áë x
‚áë (Œ£ x) = Œ£ ¬∑ ‚áë x
‚áë (œÄ ‚áí œÑ) = (‚áëPred œÄ) ‚áí (‚áë œÑ)
‚áë (‚¶Ö œÅ ‚¶Ü oœÅ) = ‚¶Ö ‚áëRow œÅ ‚¶Ü (fromWitness (Ordered‚áë œÅ (toWitness oœÅ)))
‚áë (œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) = ‚áë œÅ‚ÇÇ ‚îÄ ‚áë œÅ‚ÇÅ
‚áë (l ‚ñπ‚Çô œÑ) = (‚áëNE l) ‚ñπ (‚áë œÑ)
‚áë ((F <$> œÑ)) = (‚áë F) <$> (‚áëNE œÑ) 

‚áëRow [] = []
‚áëRow ((l , œÑ) ‚à∑ œÅ) = ((l , ‚áë œÑ) ‚à∑ ‚áëRow œÅ)

Ordered‚áë [] oœÅ = tt
Ordered‚áë (x ‚à∑ []) oœÅ = tt
Ordered‚áë ((l‚ÇÅ , _) ‚à∑ (l‚ÇÇ , _) ‚à∑ œÅ) (l‚ÇÅ<l‚ÇÇ , oœÅ) = l‚ÇÅ<l‚ÇÇ , Ordered‚áë ((l‚ÇÇ , _) ‚à∑ œÅ) oœÅ

‚áëRow-isMap : ‚àÄ (xs : SimpleRow NormalType Œî‚ÇÅ R[ Œ∫ ]) ‚Üí 
               ‚áëRow xs ‚â° map (Œª { (l , œÑ) ‚Üí l , ‚áë œÑ }) xs
‚áëRow-isMap [] = refl
‚áëRow-isMap (x ‚à∑ xs) = cong‚ÇÇ _‚à∑_ refl (‚áëRow-isMap xs)

‚áëNE (` x) = ` x
‚áëNE (œÑ‚ÇÅ ¬∑ œÑ‚ÇÇ) = (‚áëNE œÑ‚ÇÅ) ¬∑ (‚áë œÑ‚ÇÇ)

‚áëPred (œÅ‚ÇÅ ¬∑ œÅ‚ÇÇ ~ œÅ‚ÇÉ) = (‚áë œÅ‚ÇÅ) ¬∑ (‚áë œÅ‚ÇÇ) ~ (‚áë œÅ‚ÇÉ)
‚áëPred (œÅ‚ÇÅ ‚â≤ œÅ‚ÇÇ) = (‚áë œÅ‚ÇÅ) ‚â≤ (‚áë œÅ‚ÇÇ)
\end{code}


\section{Semantic types}

We have finally set the stage to discuss the process of normalizing types by evaluation. We first must define a semantic image of \verb!Type!s into which we will evaluate. Crucially, neutral types must \emph{reflect} into this domain, and elements of this domain must \emph{reify} to normal forms.

Let us first define the image of row literals to be \verb!Fin!-indexed maps.

\begin{code}
Row : Set ‚Üí Set 
Row A = ‚àÉ[ n ](Fin n ‚Üí Label √ó A)
\end{code}

\Ni Naturally, we required a predicate on such rows to indicate that they are well-ordered.
\begin{code}
OrderedRow' : ‚àÄ {A : Set} ‚Üí (n : ‚Ñï) ‚Üí (Fin n ‚Üí Label √ó A) ‚Üí Set
OrderedRow' zero P = ‚ä§
OrderedRow' (suc zero) P = ‚ä§
OrderedRow' (suc (suc n)) P = (P fzero .fst < P (fsuc fzero) .fst)  √ó OrderedRow' (suc n) (P ‚àò fsuc)

OrderedRow : ‚àÄ {A} ‚Üí Row A ‚Üí Set
OrderedRow (n , P) = OrderedRow' n P
\end{code}

\Ni We may now define the totality of forms a row-kinded type might take in the semantic domain (the \verb!RowType! data type). We evaluate row literals into \verb!Row!s via the \verb!row! constructor; note that the argument \verb!ùíØ! maps kinding environments to types. In practice, this is how we specify that a \verb!row! contains types in environment \verb!Œî!. 

\begin{code}
data RowType (Œî : KEnv) (ùíØ : KEnv ‚Üí Set) : Kind ‚Üí Set 
NotRow : ‚àÄ {Œî : KEnv} {ùíØ : KEnv ‚Üí Set} ‚Üí RowType Œî ùíØ R[ Œ∫ ] ‚Üí Set 

data RowType Œî ùíØ where
  row : (œÅ : Row (ùíØ Œî)) ‚Üí OrderedRow œÅ ‚Üí RowType Œî ùíØ R[ Œ∫ ]
\end{code}

Neutral-labeled singleton rows are evaluated into the \verb!_‚ñπ_! constructor; inert complements are evaluated into the \verb!_‚îÄ_! constructor. Just as \verb!OrderedRow! is the semantic version of row well-orderedness, the predicate \verb!NotRow! asserts that a given \verb!RowType! is not a row literal (constructed by \verb!row!). This ensures that complements constructed by \verb!_‚îÄ_! are indeed inert.

\begin{code}
  _‚ñπ_ : NeutralType Œî L ‚Üí ùíØ Œî ‚Üí RowType Œî ùíØ R[ Œ∫ ]
  _‚îÄ_ : (œÅ‚ÇÇ œÅ‚ÇÅ : RowType Œî ùíØ R[ Œ∫ ]) ‚Üí {nr : NotRow œÅ‚ÇÇ or NotRow œÅ‚ÇÅ} ‚Üí
        RowType Œî ùíØ R[ Œ∫ ]
\end{code}

\Ni We would like to compose nested maps. Borrowing from \citet{AllaisBM13}, we thus interpret the left applicand of a map as a Kripke function space mapping neutral types in environment \verb!Œî'! to the type \verb!ùíØ Œî'!, which we will later specify to be that of semantic types in environment \verb!Œî'! at kind \verb!Œ∫!. To avoid running afoul of Agda's positivity checker, we let the domain type of this Kripke function be \emph{neutral types}, which may always be reflected into semantic types. We define semantic types (\verb!SemType!) below, but replacing \verb!NeutralType Œî' Œ∫‚ÇÅ! with \verb!SemType Œî' Œ∫‚ÇÅ! would not be strictly positive. 

\begin{code}
  _<$>_ : (œÜ : ‚àÄ {Œî'} ‚Üí Renaming‚Çñ Œî Œî' ‚Üí NeutralType Œî' Œ∫‚ÇÅ ‚Üí ùíØ Œî') ‚Üí 
          NeutralType Œî R[ Œ∫‚ÇÅ ] ‚Üí 
          RowType Œî ùíØ R[ Œ∫‚ÇÇ ]
\end{code}
\begin{code}[hide]
NotRow (x ‚ñπ x‚ÇÅ) = ‚ä§
NotRow (row œÅ x) = ‚ä•
NotRow (œÅ ‚îÄ œÅ‚ÇÅ) = ‚ä§
NotRow (œÜ <$> œÅ) = ‚ä§
\end{code}

We finally define the semantic domain by induction on the kind \verb!Œ∫!. Types with \verb!‚òÖ! and label kind are simply \verb!NormalType!s. 

\begin{code}
SemType : KEnv ‚Üí Kind ‚Üí Set
SemType Œî ‚òÖ = NormalType Œî ‚òÖ
SemType Œî L = NormalType Œî L
\end{code}

\Ni We interpret functions into \emph{Kripke function spaces}---that is, functions that operate over \verb!SemType! inputs at any possible environment \verb!Œî‚ÇÇ!, provided a renaming into \verb!Œî‚ÇÇ!.

\begin{code}
SemType Œî‚ÇÅ (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ) = (‚àÄ {Œî‚ÇÇ} ‚Üí (r : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) 
                        (v : SemType Œî‚ÇÇ Œ∫‚ÇÅ) ‚Üí SemType Œî‚ÇÇ Œ∫‚ÇÇ)
\end{code}

We interpret row-kinded types into the \verb!RowType! type, defined above. Note some more trickery which we have borrowed from \citet{AllaisBM13}: we cannot pass \verb!SemType! itself as an argument to \verb!RowType! (which would violate termination checking), but we can instead pass to \verb!RowType! the function \verb!(Œª Œî' ‚Üí SemType Œî' Œ∫)!, which enforces a strictly smaller recursive call on the kind \verb!Œ∫!. Observe too that abstraction over the kinding environment \verb!Œî'! is necessary because our representation of inert maps \verb!_<$>_! interprets the mapped applicand as a Kripke function space over neutral type domain.

\begin{code}
SemType Œî R[ Œ∫ ] =  RowType Œî (Œª Œî' ‚Üí SemType Œî' Œ∫) R[ Œ∫ ]  
\end{code}

For abbreviation later, we alias our two types of Kripke function spaces as so:

\begin{code}
KripkeFunction : KEnv ‚Üí Kind ‚Üí Kind ‚Üí Set
KripkeFunctionNE : KEnv ‚Üí Kind ‚Üí Kind ‚Üí Set
KripkeFunction Œî‚ÇÅ Œ∫‚ÇÅ Œ∫‚ÇÇ =  (‚àÄ {Œî‚ÇÇ} ‚Üí Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí 
  SemType Œî‚ÇÇ Œ∫‚ÇÅ ‚Üí SemType Œî‚ÇÇ Œ∫‚ÇÇ)
KripkeFunctionNE Œî‚ÇÅ Œ∫‚ÇÅ Œ∫‚ÇÇ =  (‚àÄ {Œî‚ÇÇ} ‚Üí Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí 
  NeutralType Œî‚ÇÇ Œ∫‚ÇÅ ‚Üí SemType Œî‚ÇÇ Œ∫‚ÇÇ)
\end{code}
\begin{code}[hide]
--------------------------------------------------------------------------------
-- Truncating a row preserves ordering

ordered-cut : ‚àÄ {n : ‚Ñï} ‚Üí {P : Fin (suc n) ‚Üí Label √ó SemType Œî Œ∫} ‚Üí 
              OrderedRow (suc n , P) ‚Üí OrderedRow (n , P ‚àò fsuc)
ordered-cut {n = zero} oœÅ = tt
ordered-cut {n = suc n} oœÅ = oœÅ .snd


--------------------------------------------------------------------------------
-- Ordering is preserved by mapping

orderedOver·µ£ : ‚àÄ {n} {P : Fin n ‚Üí Label √ó SemType Œî Œ∫‚ÇÅ} ‚Üí 
               (f : SemType Œî Œ∫‚ÇÅ ‚Üí SemType Œî Œ∫‚ÇÇ) ‚Üí 
               OrderedRow (n , P) ‚Üí OrderedRow (n , over·µ£ f ‚àò P)
orderedOver·µ£ {n = zero} {P} f oœÅ = tt
orderedOver·µ£ {n = suc zero} {P} f oœÅ = tt
orderedOver·µ£ {n = suc (suc n)} {P} f oœÅ = (oœÅ .fst) , (orderedOver·µ£ f (oœÅ .snd))

--------------------------------------------------------------------------------
-- Semantic row operators

_‚®æ‚®æ_ :  Label √ó SemType Œî Œ∫ ‚Üí Row (SemType Œî Œ∫) ‚Üí Row (SemType Œî Œ∫)

œÑ ‚®æ‚®æ (n , P) =  suc n , Œª { fzero    ‚Üí œÑ 
                          ; (fsuc x) ‚Üí P x }
-- the empty row                                  
ŒµV : Row (SemType Œî Œ∫)
ŒµV = 0 , Œª ()
\end{code}


\subsection{Renaming}

Renaming over normal types is defined in a straightforward manner. Observe that renaming a Kripke function is nothing more than providing the appropriate renaming to the function.

\begin{code}
renKripke : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí KripkeFunction Œî‚ÇÅ Œ∫‚ÇÅ Œ∫‚ÇÇ ‚Üí KripkeFunction Œî‚ÇÇ Œ∫‚ÇÅ Œ∫‚ÇÇ
renKripke {Œî‚ÇÅ} œÅ F {Œî‚ÇÇ} = Œª œÅ' ‚Üí F (œÅ' ‚àò œÅ) 
\end{code}

We will make some reference to semantic renaming, so we give it the name \verb!renSem! here. Its definition is expected.

\begin{code}
renSem : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí SemType Œî‚ÇÅ Œ∫ ‚Üí SemType Œî‚ÇÇ Œ∫
\end{code}
\begin{code}[hide]
renRow : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí 
         Row (SemType Œî‚ÇÅ Œ∫) ‚Üí 
         Row (SemType Œî‚ÇÇ Œ∫)

orderedRenRow : ‚àÄ {n} {P : Fin n ‚Üí Label √ó SemType Œî‚ÇÅ Œ∫} ‚Üí (r : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) ‚Üí 
                OrderedRow' n P ‚Üí OrderedRow' n (Œª i ‚Üí (P i .fst) , renSem r (P i .snd))

nrRenSem :  ‚àÄ (r : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) ‚Üí (œÅ : RowType Œî‚ÇÅ (Œª Œî' ‚Üí SemType Œî' Œ∫) R[ Œ∫ ]) ‚Üí 
             NotRow œÅ ‚Üí NotRow (renSem r œÅ)
nrRenSem' : ‚àÄ (r : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) ‚Üí (œÅ‚ÇÇ œÅ‚ÇÅ : RowType Œî‚ÇÅ (Œª Œî' ‚Üí SemType Œî' Œ∫) R[ Œ∫ ]) ‚Üí 
             NotRow œÅ‚ÇÇ or NotRow œÅ‚ÇÅ ‚Üí NotRow (renSem r œÅ‚ÇÇ) or NotRow (renSem r œÅ‚ÇÅ)

renSem {Œ∫ = ‚òÖ} r œÑ = ren‚ÇñNF r œÑ
renSem {Œ∫ = L} r œÑ = ren‚ÇñNF r œÑ
renSem {Œ∫ = Œ∫ `‚Üí Œ∫‚ÇÅ} r F = renKripke r F
renSem {Œ∫ = R[ Œ∫ ]} r (œÜ <$> x) = (Œª r' ‚Üí œÜ (r' ‚àò r)) <$> (ren‚ÇñNE r x)
renSem {Œ∫ = R[ Œ∫ ]} r (l ‚ñπ œÑ) = (ren‚ÇñNE r l) ‚ñπ renSem r œÑ
renSem {Œ∫ = R[ Œ∫ ]} r (row (n , P) q) = row (n , ( over·µ£ (renSem r) ‚àò P)) (orderedRenRow r q)
renSem {Œ∫ = R[ Œ∫ ]} r ((œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) {nr}) = (renSem r œÅ‚ÇÇ ‚îÄ renSem r œÅ‚ÇÅ) {nr = nrRenSem' r œÅ‚ÇÇ œÅ‚ÇÅ nr}

nrRenSem' r œÅ‚ÇÇ œÅ‚ÇÅ (left x) = left (nrRenSem r œÅ‚ÇÇ x)
nrRenSem' r œÅ‚ÇÇ œÅ‚ÇÅ (right y) = right (nrRenSem r œÅ‚ÇÅ y)

nrRenSem r (x ‚ñπ x‚ÇÅ) nr = tt
nrRenSem r (œÅ ‚îÄ œÅ‚ÇÅ) nr = tt
nrRenSem r (œÜ <$> œÅ) nr = tt

orderedRenRow {n = zero} {P} r o = tt
orderedRenRow {n = suc zero} {P} r o = tt
orderedRenRow {n = suc (suc n)} {P} r (l‚ÇÅ<l‚ÇÇ , o) =  l‚ÇÅ<l‚ÇÇ  , (orderedRenRow {n = suc n} {P ‚àò fsuc} r o)

renRow œÜ (n , P) = n , over·µ£ (renSem œÜ) ‚àò P 

weakenSem : SemType Œî Œ∫‚ÇÅ ‚Üí SemType (Œî ,, Œ∫‚ÇÇ) Œ∫‚ÇÅ
weakenSem {Œî} {Œ∫‚ÇÅ} œÑ = renSem {Œî‚ÇÅ = Œî} {Œ∫ = Œ∫‚ÇÅ} S œÑ
\end{code}

\section{Normalization by Evaluation}

\begin{code}
reflect : ‚àÄ {Œ∫} ‚Üí NeutralType Œî Œ∫ ‚Üí SemType Œî Œ∫
reify : ‚àÄ {Œ∫} ‚Üí SemType Œî Œ∫ ‚Üí NormalType Œî Œ∫

reflect {Œ∫ = ‚òÖ} œÑ            = ne œÑ
reflect {Œ∫ = L} œÑ            = ne œÑ
reflect {Œ∫ = R[ Œ∫ ]} œÅ       = (Œª r n ‚Üí reflect n) <$> œÅ 
reflect {Œ∫ = Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ} œÑ = Œª œÅ v ‚Üí reflect (ren‚ÇñNE œÅ œÑ ¬∑ reify v)

reifyKripke : KripkeFunction Œî Œ∫‚ÇÅ Œ∫‚ÇÇ ‚Üí NormalType Œî (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ)
reifyKripkeNE : KripkeFunctionNE Œî Œ∫‚ÇÅ Œ∫‚ÇÇ ‚Üí NormalType Œî (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ)
reifyKripke {Œ∫‚ÇÅ = Œ∫‚ÇÅ} F = `Œª (reify (F S (reflect {Œ∫ = Œ∫‚ÇÅ} ((` Z)))))
reifyKripkeNE F = `Œª (reify (F S (` Z)))

reifyRow' : (n : ‚Ñï) ‚Üí (Fin n ‚Üí Label √ó SemType Œî Œ∫) ‚Üí SimpleRow NormalType Œî R[ Œ∫ ]
reifyRow' zero P    = []
reifyRow' (suc n) P with P fzero
... | (l , œÑ) = (l , reify œÑ) ‚à∑ reifyRow' n (P ‚àò fsuc)

reifyRow : Row (SemType Œî Œ∫) ‚Üí SimpleRow NormalType Œî R[ Œ∫ ]
reifyRow (n , P) = reifyRow' n P

reifyRowOrdered : ‚àÄ (œÅ : Row (SemType Œî Œ∫)) ‚Üí OrderedRow œÅ ‚Üí  NormalOrdered (reifyRow œÅ)
reifyRowOrdered' : ‚àÄ  (n : ‚Ñï) ‚Üí (P : Fin n ‚Üí Label √ó SemType Œî Œ∫) ‚Üí 
                      OrderedRow (n , P) ‚Üí  NormalOrdered (reifyRow (n , P))

reifyRowOrdered' zero P oœÅ = tt
reifyRowOrdered' (suc zero) P oœÅ = tt
reifyRowOrdered' (suc (suc n)) P (l‚ÇÅ<l‚ÇÇ , ih) = l‚ÇÅ<l‚ÇÇ , (reifyRowOrdered' (suc n) (P ‚àò fsuc) ih)

reifyRowOrdered (n , P) oœÅ = reifyRowOrdered' n P oœÅ

reifyPreservesNR : ‚àÄ (œÅ‚ÇÅ œÅ‚ÇÇ : RowType Œî (Œª Œî' ‚Üí SemType Œî' Œ∫) R[ Œ∫ ]) ‚Üí 
                     (nr : NotRow œÅ‚ÇÅ or NotRow œÅ‚ÇÇ) ‚Üí NotSimpleRow (reify œÅ‚ÇÅ) or NotSimpleRow (reify œÅ‚ÇÇ)

reifyPreservesNR' : ‚àÄ (œÅ‚ÇÅ œÅ‚ÇÇ : RowType Œî (Œª Œî' ‚Üí SemType Œî' Œ∫) R[ Œ∫ ]) ‚Üí 
                     (nr : NotRow œÅ‚ÇÅ or NotRow œÅ‚ÇÇ) ‚Üí NotSimpleRow (reify ((œÅ‚ÇÅ ‚îÄ œÅ‚ÇÇ) {nr}))

reify {Œ∫ = ‚òÖ} œÑ = œÑ
reify {Œ∫ = L} œÑ = œÑ
reify {Œ∫ = Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ} F = reifyKripke F
reify {Œ∫ = R[ Œ∫ ]} (l ‚ñπ œÑ) = (l ‚ñπ‚Çô (reify œÑ))
reify {Œ∫ = R[ Œ∫ ]} (row œÅ q) = ‚¶Ö reifyRow œÅ ‚¶Ü (fromWitness (reifyRowOrdered œÅ q))
reify {Œ∫ = R[ Œ∫ ]} ((œÜ <$> œÑ)) =  (reifyKripkeNE œÜ <$> œÑ)
reify {Œ∫ = R[ Œ∫ ]} ((œÜ <$> œÑ) ‚îÄ œÅ‚ÇÇ) = (reify (œÜ <$> œÑ) ‚îÄ reify œÅ‚ÇÇ) {nsr = tt}
reify {Œ∫ = R[ Œ∫ ]} ((l ‚ñπ œÑ) ‚îÄ œÅ) = (reify (l ‚ñπ œÑ) ‚îÄ (reify œÅ)) {nsr = tt}
reify {Œ∫ = R[ Œ∫ ]} (row œÅ x ‚îÄ œÅ'@(x‚ÇÅ ‚ñπ x‚ÇÇ)) = (reify (row œÅ x) ‚îÄ reify œÅ') {nsr = tt}
reify {Œ∫ = R[ Œ∫ ]} ((row œÅ x ‚îÄ row œÅ‚ÇÅ x‚ÇÅ) {left ()})
reify {Œ∫ = R[ Œ∫ ]} ((row œÅ x ‚îÄ row œÅ‚ÇÅ x‚ÇÅ) {right ()})
reify {Œ∫ = R[ Œ∫ ]} (row œÅ x ‚îÄ (œÜ <$> œÑ)) = (reify (row œÅ x) ‚îÄ reify (œÜ <$> œÑ)) {nsr = tt} 
reify {Œ∫ = R[ Œ∫ ]} ((row œÅ x ‚îÄ œÅ'@((œÅ‚ÇÅ ‚îÄ œÅ‚ÇÇ) {nr'})) {nr}) = ((reify (row œÅ x)) ‚îÄ (reify ((œÅ‚ÇÅ ‚îÄ œÅ‚ÇÇ) {nr'}))) {nsr = fromWitness (reifyPreservesNR (row œÅ x) œÅ' (right tt))}
reify {Œ∫ = R[ Œ∫ ]} ((((œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) {nr'}) ‚îÄ œÅ) {nr}) = ((reify ((œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) {nr'})) ‚îÄ reify œÅ) {fromWitness (reifyPreservesNR ((œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) {nr'}) œÅ (left tt))}


reifyPreservesNR (x‚ÇÅ ‚ñπ x‚ÇÇ) œÅ‚ÇÇ (left x) = left tt
reifyPreservesNR ((œÅ‚ÇÅ ‚îÄ œÅ‚ÇÉ) {nr}) œÅ‚ÇÇ (left x) = left (reifyPreservesNR' œÅ‚ÇÅ œÅ‚ÇÉ nr)
reifyPreservesNR (œÜ <$> œÅ) œÅ‚ÇÇ (left x) = left tt
reifyPreservesNR œÅ‚ÇÅ (x ‚ñπ x‚ÇÅ) (right y) = right tt
reifyPreservesNR œÅ‚ÇÅ ((œÅ‚ÇÇ ‚îÄ œÅ‚ÇÉ) {nr}) (right y) = right (reifyPreservesNR' œÅ‚ÇÇ œÅ‚ÇÉ nr)
reifyPreservesNR œÅ‚ÇÅ ((œÜ <$> œÅ‚ÇÇ)) (right y) = right tt

reifyPreservesNR' (x‚ÇÅ ‚ñπ x‚ÇÇ) œÅ‚ÇÇ (left x) = tt
reifyPreservesNR' (œÅ‚ÇÅ ‚îÄ œÅ‚ÇÉ) œÅ‚ÇÇ (left x) = tt
reifyPreservesNR' (œÜ <$> n) œÅ‚ÇÇ (left x) = tt
reifyPreservesNR' (œÜ <$> n) œÅ‚ÇÇ (right y) = tt
reifyPreservesNR' (x ‚ñπ x‚ÇÅ) œÅ‚ÇÇ (right y) = tt
reifyPreservesNR' (row œÅ x) (x‚ÇÅ ‚ñπ x‚ÇÇ) (right y) = tt
reifyPreservesNR' (row œÅ x) (œÅ‚ÇÇ ‚îÄ œÅ‚ÇÉ) (right y) = tt
reifyPreservesNR' (row œÅ x) (œÜ <$> n) (right y) = tt
reifyPreservesNR' (œÅ‚ÇÅ ‚îÄ œÅ‚ÇÉ) œÅ‚ÇÇ (right y) = tt

--------------------------------------------------------------------------------
-- Œ∑ normalization of neutral types

Œ∑-norm : NeutralType Œî Œ∫ ‚Üí NormalType Œî Œ∫ 
Œ∑-norm = reify ‚àò reflect

-- --------------------------------------------------------------------------------
-- -- Semantic environments

Env : KEnv ‚Üí KEnv ‚Üí Set
Env Œî‚ÇÅ Œî‚ÇÇ = ‚àÄ {Œ∫} ‚Üí TVar Œî‚ÇÅ Œ∫ ‚Üí SemType Œî‚ÇÇ Œ∫

idEnv : Env Œî Œî
idEnv = reflect ‚àò `

extende : (Œ∑ : Env Œî‚ÇÅ Œî‚ÇÇ) ‚Üí (V : SemType Œî‚ÇÇ Œ∫) ‚Üí Env (Œî‚ÇÅ ,, Œ∫) Œî‚ÇÇ
extende Œ∑ V Z     = V
extende Œ∑ V (S x) = Œ∑ x

lifte : Env Œî‚ÇÅ Œî‚ÇÇ ‚Üí Env (Œî‚ÇÅ ,, Œ∫) (Œî‚ÇÇ ,, Œ∫)
lifte {Œî‚ÇÅ} {Œî‚ÇÇ} {Œ∫} Œ∑  = extende (weakenSem ‚àò Œ∑) (idEnv Z)
\end{code}


\subsection{Helping evaluation}

\begin{code}
-----------------------
-- Semantic application

_¬∑V_ : SemType Œî (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ) ‚Üí SemType Œî Œ∫‚ÇÅ ‚Üí SemType Œî Œ∫‚ÇÇ
F ¬∑V V = F id V

----------------------
-- Semantic complement

_‚ààRow_ : ‚àÄ {m} ‚Üí (l : Label) ‚Üí 
         (Q : Fin m ‚Üí Label √ó SemType Œî Œ∫) ‚Üí 
         Set 
_‚ààRow_ {m = m} l Q = Œ£[ i ‚àà Fin m ] (l ‚â° Q i .fst)

_‚ààRow?_ : ‚àÄ {m} ‚Üí (l : Label) ‚Üí 
         (Q : Fin m ‚Üí Label √ó SemType Œî Œ∫) ‚Üí 
         Dec (l ‚ààRow Q)
_‚ààRow?_ {m = zero} l Q = no Œª { () }
_‚ààRow?_ {m = suc m} l Q with l ‚âü Q fzero .fst
... | yes p = yes (fzero , p)
... | no  p with l ‚ààRow? (Q ‚àò fsuc)
...        | yes (n , q) = yes ((fsuc n) , q) 
...        | no  q = no Œª { (fzero , q') ‚Üí p q' ; (fsuc n , q') ‚Üí q (n , q') }

compl : ‚àÄ {n m} ‚Üí 
        (P : Fin n ‚Üí Label √ó SemType Œî Œ∫) 
        (Q : Fin m ‚Üí Label √ó SemType Œî Œ∫) ‚Üí 
        Row (SemType Œî Œ∫)
compl {n = zero} {m} P Q = ŒµV
compl {n = suc n} {m} P Q with P fzero .fst ‚ààRow? Q 
... | yes _ = compl (P ‚àò fsuc) Q 
... | no _ = (P fzero) ‚®æ‚®æ (compl (P ‚àò fsuc) Q)

-- --------------------------------------------------------------------------------
-- -- Semantic complement preserves well-ordering
lemma : ‚àÄ {n m q} ‚Üí 
          (P : Fin (suc n) ‚Üí Label √ó SemType Œî Œ∫)
          (Q : Fin m ‚Üí Label √ó SemType Œî Œ∫) ‚Üí 
          (R : Fin (suc q) ‚Üí Label √ó SemType Œî Œ∫) ‚Üí 
             OrderedRow (suc n , P) ‚Üí
             compl (P ‚àò fsuc) Q ‚â° (suc q , R) ‚Üí 
          P fzero .fst < R fzero .fst
lemma {n = suc n} {q = q} P Q R oP eq‚ÇÅ with P (fsuc fzero) .fst ‚ààRow? Q 
lemma {Œ∫ = _} {suc n} {q = q} P Q R oP refl | no _ = oP .fst
... | yes _ = <-trans {i = P fzero .fst} {j = P (fsuc fzero) .fst} {k = R fzero .fst} (oP .fst) (lemma {n = n} (P ‚àò fsuc) Q R (oP .snd) eq‚ÇÅ)

ordered-‚®æ‚®æ : ‚àÄ {n m} ‚Üí 
                 (P : Fin (suc n) ‚Üí Label √ó SemType Œî Œ∫) 
                 (Q : Fin m ‚Üí Label √ó SemType Œî Œ∫) ‚Üí 
                 OrderedRow (suc n , P) ‚Üí 
                 OrderedRow (compl (P ‚àò fsuc) Q) ‚Üí OrderedRow (P fzero ‚®æ‚®æ compl (P ‚àò fsuc) Q)
ordered-‚®æ‚®æ {n = n} P Q oP oC with compl (P ‚àò fsuc) Q | inspect (compl (P ‚àò fsuc)) Q
... | zero , R  | _        = tt
... | suc n , R | [[ eq ]] = lemma P Q R oP eq  , oC

ordered-compl :  ‚àÄ {n m} ‚Üí 
                 (P : Fin n ‚Üí Label √ó SemType Œî Œ∫) 
                 (Q : Fin m ‚Üí Label √ó SemType Œî Œ∫) ‚Üí 
                 OrderedRow (n , P) ‚Üí OrderedRow (m , Q) ‚Üí OrderedRow (compl P Q)
ordered-compl {n = zero} P Q oœÅ‚ÇÅ oœÅ‚ÇÇ = tt
ordered-compl {n = suc n} P Q oœÅ‚ÇÅ oœÅ‚ÇÇ with P fzero .fst ‚ààRow? Q
... | yes _ = ordered-compl (P ‚àò fsuc) Q (ordered-cut oœÅ‚ÇÅ) oœÅ‚ÇÇ
... | no _ = ordered-‚®æ‚®æ P Q oœÅ‚ÇÅ (ordered-compl (P ‚àò fsuc) Q (ordered-cut oœÅ‚ÇÅ) oœÅ‚ÇÇ)

--------------------------------------------------------------------------------
-- Semantic complement on Rows
                
_‚îÄv_ : Row (SemType Œî Œ∫) ‚Üí Row (SemType Œî Œ∫) ‚Üí Row (SemType Œî Œ∫)
(n , P) ‚îÄv (m , Q) = compl P Q

ordered‚îÄv : ‚àÄ (œÅ‚ÇÇ œÅ‚ÇÅ : Row (SemType Œî Œ∫)) ‚Üí OrderedRow œÅ‚ÇÇ ‚Üí OrderedRow œÅ‚ÇÅ ‚Üí OrderedRow (œÅ‚ÇÇ ‚îÄv œÅ‚ÇÅ)
ordered‚îÄv (n , P) (m , Q) oœÅ‚ÇÇ oœÅ‚ÇÅ = ordered-compl P Q oœÅ‚ÇÇ oœÅ‚ÇÅ

-- -- -- --------------------------------------------------------------------------------
-- -- -- -- Semantic lifting

_<$>V_ : SemType Œî (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ) ‚Üí SemType Œî R[ Œ∫‚ÇÅ ] ‚Üí SemType Œî R[ Œ∫‚ÇÇ ]
NotRow<$> : ‚àÄ {F : SemType Œî (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ)} {œÅ‚ÇÇ œÅ‚ÇÅ : RowType Œî (Œª Œî' ‚Üí SemType Œî' Œ∫‚ÇÅ) R[ Œ∫‚ÇÅ ]} ‚Üí 
              NotRow œÅ‚ÇÇ or NotRow œÅ‚ÇÅ ‚Üí NotRow (F <$>V œÅ‚ÇÇ) or NotRow (F <$>V œÅ‚ÇÅ)

F <$>V (l ‚ñπ œÑ) = l ‚ñπ (F ¬∑V œÑ)
F <$>V row (n , P) q = row (n , over·µ£ (F id) ‚àò P) (orderedOver·µ£ (F id) q)
F <$>V ((œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) {nr}) = ((F <$>V œÅ‚ÇÇ) ‚îÄ (F <$>V œÅ‚ÇÅ)) {NotRow<$> nr}
F <$>V (G <$> n) = (Œª {Œî'} r ‚Üí F r ‚àò G r) <$> n

NotRow<$> {F = F} {x‚ÇÅ ‚ñπ x‚ÇÇ} {œÅ‚ÇÅ} (left x) = left tt
NotRow<$> {F = F} {œÅ‚ÇÇ ‚îÄ œÅ‚ÇÉ} {œÅ‚ÇÅ} (left x) = left tt
NotRow<$> {F = F} {œÜ <$> n} {œÅ‚ÇÅ} (left x) = left tt

NotRow<$> {F = F} {œÅ‚ÇÇ} {x ‚ñπ x‚ÇÅ} (right y) = right tt
NotRow<$> {F = F} {œÅ‚ÇÇ} {œÅ‚ÇÅ ‚îÄ œÅ‚ÇÉ} (right y) = right tt
NotRow<$> {F = F} {œÅ‚ÇÇ} {œÜ <$> n} (right y) = right tt


-- -- -- --------------------------------------------------------------------------------
-- -- -- -- Semantic complement on SemTypes

_‚îÄV_ : SemType Œî R[ Œ∫ ] ‚Üí SemType Œî R[ Œ∫ ] ‚Üí SemType Œî R[ Œ∫ ]
row œÅ‚ÇÇ oœÅ‚ÇÇ ‚îÄV row œÅ‚ÇÅ oœÅ‚ÇÅ = row (œÅ‚ÇÇ ‚îÄv œÅ‚ÇÅ) (ordered‚îÄv œÅ‚ÇÇ œÅ‚ÇÅ oœÅ‚ÇÇ oœÅ‚ÇÅ)
œÅ‚ÇÇ@(x ‚ñπ x‚ÇÅ) ‚îÄV œÅ‚ÇÅ = (œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) {nr = left tt}
œÅ‚ÇÇ@(row œÅ x) ‚îÄV œÅ‚ÇÅ@(x‚ÇÅ ‚ñπ x‚ÇÇ) = (œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) {nr = right tt}
œÅ‚ÇÇ@(row œÅ x) ‚îÄV œÅ‚ÇÅ@(_ ‚îÄ _) = (œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) {nr = right tt}
œÅ‚ÇÇ@(row œÅ x) ‚îÄV œÅ‚ÇÅ@(_ <$> _) = (œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) {nr = right tt}
œÅ@(œÅ‚ÇÇ ‚îÄ œÅ‚ÇÉ) ‚îÄV œÅ' = (œÅ ‚îÄ œÅ') {nr = left tt}
œÅ@(œÜ <$> n) ‚îÄV œÅ' = (œÅ ‚îÄ œÅ') {nr = left tt}

-- --------------------------------------------------------------------------------
-- -- Semantic flap

apply : SemType Œî Œ∫‚ÇÅ ‚Üí SemType Œî ((Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ) `‚Üí Œ∫‚ÇÇ)
apply a = Œª œÅ F ‚Üí F ¬∑V (renSem œÅ a)

infixr 0 _<?>V_
_<?>V_ : SemType Œî R[ Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ ] ‚Üí SemType Œî Œ∫‚ÇÅ ‚Üí SemType Œî R[ Œ∫‚ÇÇ ]
f <?>V a = apply a <$>V f
\end{code}

\subsection{$\Pi$ and $\Sigma$ as operators}

\begin{code}
record Xi : Set where 
  field
    Œû‚òÖ : ‚àÄ {Œî} ‚Üí NormalType  Œî R[ ‚òÖ ] ‚Üí NormalType Œî ‚òÖ
    ren-‚òÖ : ‚àÄ (œÅ : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) ‚Üí (œÑ : NormalType Œî‚ÇÅ R[ ‚òÖ ]) ‚Üí ren‚ÇñNF œÅ (Œû‚òÖ œÑ) ‚â°  Œû‚òÖ (ren‚ÇñNF œÅ œÑ)

open Xi
Œæ : ‚àÄ {Œî} ‚Üí Xi ‚Üí SemType Œî R[ Œ∫ ] ‚Üí SemType Œî Œ∫ 
Œæ {Œ∫ = ‚òÖ} Œû x = Œû .Œû‚òÖ (reify x)
Œæ {Œ∫ = L} Œû x = lab "impossible"
Œæ {Œ∫ = Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ} Œû F = Œª œÅ v ‚Üí Œæ Œû (renSem œÅ F <?>V v)
Œæ {Œ∫ = R[ Œ∫ ]} Œû x = (Œª œÅ v ‚Üí Œæ Œû v) <$>V x

Œ†-rec Œ£-rec : Xi 
Œ†-rec = record
  {  Œû‚òÖ = Œ† ; ren-‚òÖ = Œª œÅ œÑ ‚Üí refl }
Œ£-rec = 
  record
  { Œû‚òÖ = Œ£ ; ren-‚òÖ = Œª œÅ œÑ ‚Üí refl  }

Œ†V Œ£V : ‚àÄ {Œî} ‚Üí SemType Œî R[ Œ∫ ] ‚Üí SemType Œî Œ∫
Œ†V = Œæ Œ†-rec
Œ£V = Œæ Œ£-rec

Œæ-Kripke : Xi ‚Üí KripkeFunction Œî R[ Œ∫ ] Œ∫
Œæ-Kripke Œû œÅ v = Œæ Œû v

Œ†-Kripke Œ£-Kripke : KripkeFunction Œî R[ Œ∫ ] Œ∫
Œ†-Kripke = Œæ-Kripke Œ†-rec
Œ£-Kripke = Œæ-Kripke Œ£-rec
\end{code}

\subsection{Evaluation}
\begin{code}
eval : Type Œî‚ÇÅ Œ∫ ‚Üí Env Œî‚ÇÅ Œî‚ÇÇ ‚Üí SemType Œî‚ÇÇ Œ∫
evalPred : Pred Type Œî‚ÇÅ R[ Œ∫ ] ‚Üí Env Œî‚ÇÅ Œî‚ÇÇ ‚Üí NormalPred Œî‚ÇÇ R[ Œ∫ ]

evalRow        : (œÅ : SimpleRow Type Œî‚ÇÅ R[ Œ∫ ]) ‚Üí Env Œî‚ÇÅ Œî‚ÇÇ ‚Üí Row (SemType Œî‚ÇÇ Œ∫)
evalRowOrdered : (œÅ : SimpleRow Type Œî‚ÇÅ R[ Œ∫ ]) ‚Üí (Œ∑ : Env Œî‚ÇÅ Œî‚ÇÇ) ‚Üí Ordered œÅ ‚Üí OrderedRow (evalRow œÅ Œ∑)

evalRow [] Œ∑ = ŒµV 
evalRow ((l , œÑ) ‚à∑ œÅ) Œ∑ = (l , (eval œÑ Œ∑)) ‚®æ‚®æ evalRow œÅ Œ∑ 

‚áìRow-isMap : ‚àÄ (Œ∑ : Env Œî‚ÇÅ Œî‚ÇÇ) ‚Üí (xs : SimpleRow Type Œî‚ÇÅ R[ Œ∫ ])  ‚Üí 
                      reifyRow (evalRow xs Œ∑) ‚â° map (Œª { (l , œÑ) ‚Üí l , (reify (eval œÑ Œ∑)) }) xs
‚áìRow-isMap Œ∑ [] = refl
‚áìRow-isMap Œ∑ (x ‚à∑ xs) = cong‚ÇÇ _‚à∑_ refl (‚áìRow-isMap Œ∑ xs)

evalPred (œÅ‚ÇÅ ¬∑ œÅ‚ÇÇ ~ œÅ‚ÇÉ) Œ∑ = reify (eval œÅ‚ÇÅ Œ∑) ¬∑ reify (eval œÅ‚ÇÇ Œ∑) ~ reify (eval œÅ‚ÇÉ Œ∑)
evalPred (œÅ‚ÇÅ ‚â≤ œÅ‚ÇÇ) Œ∑ = reify (eval œÅ‚ÇÅ Œ∑) ‚â≤ reify (eval œÅ‚ÇÇ Œ∑)

eval {Œ∫ = Œ∫} (` x) Œ∑ = Œ∑ x
eval {Œ∫ = Œ∫} (œÑ‚ÇÅ ¬∑ œÑ‚ÇÇ) Œ∑ = (eval œÑ‚ÇÅ Œ∑) ¬∑V (eval œÑ‚ÇÇ Œ∑)
eval {Œ∫ = Œ∫} (œÑ‚ÇÅ `‚Üí œÑ‚ÇÇ) Œ∑ = (eval œÑ‚ÇÅ Œ∑) `‚Üí (eval œÑ‚ÇÇ Œ∑)

eval {Œ∫ = ‚òÖ} (œÄ ‚áí œÑ) Œ∑ = evalPred œÄ Œ∑ ‚áí eval œÑ Œ∑
eval {Œî‚ÇÅ} {Œ∫ = ‚òÖ} (`‚àÄ œÑ) Œ∑ = `‚àÄ (eval œÑ (lifte Œ∑)) 
eval {Œ∫ = ‚òÖ} (Œº œÑ) Œ∑ = Œº (reify (eval œÑ Œ∑))
eval {Œ∫ = ‚òÖ} ‚åä œÑ ‚åã Œ∑ = ‚åä reify (eval œÑ Œ∑) ‚åã
eval (œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) Œ∑ = eval œÅ‚ÇÇ Œ∑ ‚îÄV eval œÅ‚ÇÅ Œ∑
eval {Œ∫ = L} (lab l) Œ∑ = lab l
eval {Œ∫ = Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ} (`Œª œÑ) Œ∑ = Œª œÅ v ‚Üí eval œÑ (extende (Œª {Œ∫} v' ‚Üí renSem {Œ∫ = Œ∫} œÅ (Œ∑ v')) v)
eval {Œ∫ = R[ Œ∫ ] `‚Üí Œ∫} Œ† Œ∑ = Œ†-Kripke
eval {Œ∫ = R[ Œ∫ ] `‚Üí Œ∫} Œ£ Œ∑ = Œ£-Kripke
eval {Œ∫ = R[ Œ∫ ]} (f <$> a) Œ∑ = (eval f Œ∑) <$>V (eval a Œ∑)
eval (‚¶Ö œÅ ‚¶Ü oœÅ) Œ∑ = row (evalRow œÅ Œ∑) (evalRowOrdered œÅ Œ∑ (toWitness oœÅ))
eval (l ‚ñπ œÑ) Œ∑ with eval l Œ∑ 
... | ne x = (x ‚ñπ eval œÑ Œ∑)
... | lab l‚ÇÅ = row (1 , Œª { fzero ‚Üí (l‚ÇÅ , eval œÑ Œ∑) }) tt
evalRowOrdered [] Œ∑ oœÅ = tt
evalRowOrdered (x‚ÇÅ ‚à∑ []) Œ∑ oœÅ = tt
evalRowOrdered ((l‚ÇÅ , œÑ‚ÇÅ) ‚à∑ (l‚ÇÇ , œÑ‚ÇÇ) ‚à∑ œÅ) Œ∑ (l‚ÇÅ<l‚ÇÇ , oœÅ) with 
  evalRow œÅ Œ∑ | evalRowOrdered ((l‚ÇÇ , œÑ‚ÇÇ) ‚à∑ œÅ) Œ∑ oœÅ
... | zero , P | ih = l‚ÇÅ<l‚ÇÇ , tt
... | suc n , P | ih‚ÇÅ , ih‚ÇÇ =  l‚ÇÅ<l‚ÇÇ , ih‚ÇÅ , ih‚ÇÇ
\end{code}

\subsection{Normalization}
\begin{code}
‚áì : ‚àÄ {Œî} ‚Üí Type Œî Œ∫ ‚Üí NormalType Œî Œ∫
‚áì œÑ = reify (eval œÑ idEnv)

‚áìPred : ‚àÄ {Œî} ‚Üí Pred Type Œî R[ Œ∫ ] ‚Üí Pred NormalType Œî R[ Œ∫ ] 
‚áìPred œÄ = evalPred œÄ idEnv

‚áìRow : ‚àÄ {Œî} ‚Üí SimpleRow Type Œî R[ Œ∫ ] ‚Üí SimpleRow NormalType Œî R[ Œ∫ ] 
‚áìRow œÅ = reifyRow (evalRow œÅ idEnv)

‚áìNE : ‚àÄ {Œî} ‚Üí NeutralType Œî Œ∫ ‚Üí NormalType Œî Œ∫
‚áìNE œÑ = reify (eval (‚áëNE œÑ) idEnv)
\end{code}

\section{Metatheory}

\subsection{Stability}

\begin{code}
stability   : ‚àÄ (œÑ : NormalType Œî Œ∫) ‚Üí ‚áì (‚áë œÑ) ‚â° œÑ
stabilityNE : ‚àÄ (œÑ : NeutralType Œî Œ∫) ‚Üí eval (‚áëNE œÑ) (idEnv {Œî}) ‚â° reflect œÑ
stabilityPred : ‚àÄ (œÄ : NormalPred Œî R[ Œ∫ ]) ‚Üí evalPred (‚áëPred œÄ) idEnv ‚â° œÄ
stabilityRow : ‚àÄ (œÅ : SimpleRow NormalType Œî R[ Œ∫ ]) ‚Üí reifyRow (evalRow (‚áëRow œÅ) idEnv) ‚â° œÅ
\end{code}
\begin{code}[hide]
stability     = bot _
stabilityNE   = bot _
stabilityPred = bot _
stabilityRow = bot _
\end{code}

Stability implies surjectivity and idempotency.

\begin{code}
idempotency : ‚àÄ (œÑ : Type Œî Œ∫) ‚Üí (‚áë ‚àò ‚áì ‚àò ‚áë ‚àò ‚áì) œÑ ‚â°  (‚áë ‚àò ‚áì)  œÑ
idempotency œÑ rewrite stability (‚áì œÑ) = refl

surjectivity : ‚àÄ (œÑ : NormalType Œî Œ∫) ‚Üí ‚àÉ[ œÖ ] (‚áì œÖ ‚â° œÑ)
surjectivity œÑ = ( ‚áë œÑ , stability œÑ ) 
\end{code}

Dual to surjectivity, stability also implies that embedding is injective.
 
\begin{code}
‚áë-inj : ‚àÄ (œÑ‚ÇÅ œÑ‚ÇÇ : NormalType Œî Œ∫) ‚Üí ‚áë œÑ‚ÇÅ ‚â° ‚áë œÑ‚ÇÇ ‚Üí œÑ‚ÇÅ ‚â° œÑ‚ÇÇ                   
‚áë-inj œÑ‚ÇÅ œÑ‚ÇÇ eq = trans (sym (stability œÑ‚ÇÅ)) (trans (cong ‚áì eq) (stability œÑ‚ÇÇ))
\end{code}

\subsection{A logical relation for completeness}

\begin{code}
subst-Row : ‚àÄ {A : Set} {n m : ‚Ñï} ‚Üí (n ‚â° m) ‚Üí (f : Fin n ‚Üí A) ‚Üí Fin m ‚Üí A 
subst-Row refl f = f

-- Completeness relation on semantic types
_‚âã_ : SemType Œî Œ∫ ‚Üí SemType Œî Œ∫ ‚Üí Set
_‚âã‚ÇÇ_ : ‚àÄ {A} ‚Üí (x y : A √ó SemType Œî Œ∫) ‚Üí Set
(l‚ÇÅ , œÑ‚ÇÅ) ‚âã‚ÇÇ (l‚ÇÇ , œÑ‚ÇÇ) = l‚ÇÅ ‚â° l‚ÇÇ √ó œÑ‚ÇÅ ‚âã œÑ‚ÇÇ
_‚âãR_ : (œÅ‚ÇÅ œÅ‚ÇÇ : Row (SemType Œî Œ∫)) ‚Üí Set 
(n , P) ‚âãR (m , Q) = Œ£[ pf ‚àà (n ‚â° m) ] (‚àÄ (i : Fin m) ‚Üí  (subst-Row pf P) i ‚âã‚ÇÇ Q i)

PointEqual-‚âã : ‚àÄ {Œî‚ÇÅ} {Œ∫‚ÇÅ} {Œ∫‚ÇÇ} (F G : KripkeFunction Œî‚ÇÅ Œ∫‚ÇÅ Œ∫‚ÇÇ) ‚Üí Set
PointEqualNE-‚âã : ‚àÄ {Œî‚ÇÅ} {Œ∫‚ÇÅ} {Œ∫‚ÇÇ} (F G : KripkeFunctionNE Œî‚ÇÅ Œ∫‚ÇÅ Œ∫‚ÇÇ) ‚Üí Set
Uniform :  ‚àÄ {Œî} {Œ∫‚ÇÅ} {Œ∫‚ÇÇ} ‚Üí KripkeFunction Œî Œ∫‚ÇÅ Œ∫‚ÇÇ ‚Üí Set
UniformNE :  ‚àÄ {Œî} {Œ∫‚ÇÅ} {Œ∫‚ÇÇ} ‚Üí KripkeFunctionNE Œî Œ∫‚ÇÅ Œ∫‚ÇÇ ‚Üí Set

convNE : Œ∫‚ÇÅ ‚â° Œ∫‚ÇÇ ‚Üí NeutralType Œî R[ Œ∫‚ÇÅ ] ‚Üí NeutralType Œî R[ Œ∫‚ÇÇ ]
convNE refl n = n 

convKripkeNE‚ÇÅ : ‚àÄ {Œ∫‚ÇÅ'} ‚Üí Œ∫‚ÇÅ ‚â° Œ∫‚ÇÅ' ‚Üí KripkeFunctionNE Œî Œ∫‚ÇÅ Œ∫‚ÇÇ ‚Üí KripkeFunctionNE Œî Œ∫‚ÇÅ' Œ∫‚ÇÇ
convKripkeNE‚ÇÅ refl f = f

_‚âã_ {Œ∫ = ‚òÖ} œÑ‚ÇÅ œÑ‚ÇÇ = œÑ‚ÇÅ ‚â° œÑ‚ÇÇ
_‚âã_ {Œ∫ = L} œÑ‚ÇÅ œÑ‚ÇÇ = œÑ‚ÇÅ ‚â° œÑ‚ÇÇ
_‚âã_ {Œî‚ÇÅ} {Œ∫ = Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ} F G = 
  Uniform F √ó Uniform G √ó PointEqual-‚âã {Œî‚ÇÅ} F G 
_‚âã_ {Œî‚ÇÅ} {R[ Œ∫‚ÇÇ ]} (_<$>_ {Œ∫‚ÇÅ} œÜ‚ÇÅ n‚ÇÅ) (_<$>_ {Œ∫‚ÇÅ'} œÜ‚ÇÇ n‚ÇÇ) = 
  Œ£[ pf ‚àà (Œ∫‚ÇÅ ‚â° Œ∫‚ÇÅ') ]  
    UniformNE œÜ‚ÇÅ
  √ó UniformNE œÜ‚ÇÇ
  √ó (PointEqualNE-‚âã (convKripkeNE‚ÇÅ pf œÜ‚ÇÅ) œÜ‚ÇÇ
  √ó convNE pf n‚ÇÅ ‚â° n‚ÇÇ)
_‚âã_ {Œî‚ÇÅ} {R[ Œ∫‚ÇÇ ]} (œÜ‚ÇÅ <$> n‚ÇÅ) _ = ‚ä•
_‚âã_ {Œî‚ÇÅ} {R[ Œ∫‚ÇÇ ]} _ (œÜ‚ÇÅ <$> n‚ÇÅ) = ‚ä•
_‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (l‚ÇÅ ‚ñπ œÑ‚ÇÅ) (l‚ÇÇ ‚ñπ œÑ‚ÇÇ) = l‚ÇÅ ‚â° l‚ÇÇ √ó œÑ‚ÇÅ ‚âã œÑ‚ÇÇ
_‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (x‚ÇÅ ‚ñπ x‚ÇÇ) (row œÅ x‚ÇÉ) = ‚ä•
_‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (x‚ÇÅ ‚ñπ x‚ÇÇ) (œÅ‚ÇÇ ‚îÄ œÅ‚ÇÉ) = ‚ä•
_‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (row œÅ x‚ÇÅ) (x‚ÇÇ ‚ñπ x‚ÇÉ) = ‚ä•
_‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (row (n , P) x‚ÇÅ) (row (m , Q) x‚ÇÇ) = (n , P) ‚âãR (m , Q)
_‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (row œÅ x‚ÇÅ) (œÅ‚ÇÇ ‚îÄ œÅ‚ÇÉ) = ‚ä•
_‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (œÅ‚ÇÅ ‚îÄ œÅ‚ÇÇ) (x‚ÇÅ ‚ñπ x‚ÇÇ) = ‚ä•
_‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (œÅ‚ÇÅ ‚îÄ œÅ‚ÇÇ) (row œÅ x‚ÇÅ) = ‚ä•
_‚âã_ {Œî‚ÇÅ} {R[ Œ∫ ]} (œÅ‚ÇÅ ‚îÄ œÅ‚ÇÇ) (œÅ‚ÇÉ ‚îÄ œÅ‚ÇÑ) = œÅ‚ÇÅ ‚âã œÅ‚ÇÉ √ó œÅ‚ÇÇ ‚âã œÅ‚ÇÑ

PointEqual-‚âã {Œî‚ÇÅ} {Œ∫‚ÇÅ} {Œ∫‚ÇÇ} F G = 
  ‚àÄ {Œî‚ÇÇ} (œÅ : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) {V‚ÇÅ V‚ÇÇ : SemType Œî‚ÇÇ Œ∫‚ÇÅ} ‚Üí 
  V‚ÇÅ ‚âã V‚ÇÇ ‚Üí F œÅ V‚ÇÅ ‚âã G œÅ V‚ÇÇ

PointEqualNE-‚âã {Œî‚ÇÅ} {Œ∫‚ÇÅ} {Œ∫‚ÇÇ} F G = 
  ‚àÄ {Œî‚ÇÇ} (œÅ : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) (V : NeutralType Œî‚ÇÇ Œ∫‚ÇÅ) ‚Üí 
  F œÅ V ‚âã G œÅ V

Uniform {Œî‚ÇÅ} {Œ∫‚ÇÅ} {Œ∫‚ÇÇ} F = 
  ‚àÄ {Œî‚ÇÇ Œî‚ÇÉ} (œÅ‚ÇÅ : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) (œÅ‚ÇÇ : Renaming‚Çñ Œî‚ÇÇ Œî‚ÇÉ) (V‚ÇÅ V‚ÇÇ : SemType Œî‚ÇÇ Œ∫‚ÇÅ) ‚Üí
  V‚ÇÅ ‚âã V‚ÇÇ ‚Üí (renSem œÅ‚ÇÇ (F œÅ‚ÇÅ V‚ÇÅ)) ‚âã (renKripke œÅ‚ÇÅ F œÅ‚ÇÇ (renSem œÅ‚ÇÇ V‚ÇÇ))

UniformNE {Œî‚ÇÅ} {Œ∫‚ÇÅ} {Œ∫‚ÇÇ} F = 
  ‚àÄ {Œî‚ÇÇ Œî‚ÇÉ} (œÅ‚ÇÅ : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) (œÅ‚ÇÇ : Renaming‚Çñ Œî‚ÇÇ Œî‚ÇÉ) (V : NeutralType Œî‚ÇÇ Œ∫‚ÇÅ) ‚Üí
  (renSem œÅ‚ÇÇ (F œÅ‚ÇÅ V)) ‚âã F (œÅ‚ÇÇ ‚àò œÅ‚ÇÅ) (ren‚ÇñNE œÅ‚ÇÇ V)

Env-‚âã : (Œ∑‚ÇÅ Œ∑‚ÇÇ : Env Œî‚ÇÅ Œî‚ÇÇ) ‚Üí Set
Env-‚âã Œ∑‚ÇÅ Œ∑‚ÇÇ = ‚àÄ {Œ∫} (x : TVar _ Œ∫) ‚Üí (Œ∑‚ÇÅ x) ‚âã (Œ∑‚ÇÇ x)

-- extension
extend-‚âã : ‚àÄ {Œ∑‚ÇÅ Œ∑‚ÇÇ : Env Œî‚ÇÅ Œî‚ÇÇ} ‚Üí Env-‚âã Œ∑‚ÇÅ Œ∑‚ÇÇ ‚Üí 
            {V‚ÇÅ V‚ÇÇ : SemType Œî‚ÇÇ Œ∫} ‚Üí 
            V‚ÇÅ ‚âã V‚ÇÇ ‚Üí 
            Env-‚âã (extende Œ∑‚ÇÅ V‚ÇÅ) (extende Œ∑‚ÇÇ V‚ÇÇ)
extend-‚âã p q Z = q
extend-‚âã p q (S v) = p v
\end{code}
\begin{code}[hide]

refl-‚âã‚Çó : ‚àÄ {V‚ÇÅ V‚ÇÇ : SemType Œî Œ∫}     ‚Üí V‚ÇÅ ‚âã V‚ÇÇ ‚Üí V‚ÇÅ ‚âã V‚ÇÅ
refl-‚âã·µ£ : ‚àÄ {V‚ÇÅ V‚ÇÇ : SemType Œî Œ∫}     ‚Üí V‚ÇÅ ‚âã V‚ÇÇ ‚Üí V‚ÇÇ ‚âã V‚ÇÇ
sym-‚âã : ‚àÄ {œÑ‚ÇÅ œÑ‚ÇÇ : SemType Œî Œ∫}      ‚Üí œÑ‚ÇÅ ‚âã œÑ‚ÇÇ ‚Üí œÑ‚ÇÇ ‚âã œÑ‚ÇÅ
trans-‚âã : ‚àÄ {œÑ‚ÇÅ œÑ‚ÇÇ œÑ‚ÇÉ : SemType Œî Œ∫} ‚Üí œÑ‚ÇÅ ‚âã œÑ‚ÇÇ ‚Üí œÑ‚ÇÇ ‚âã œÑ‚ÇÉ ‚Üí œÑ‚ÇÅ ‚âã œÑ‚ÇÉ
trans-‚âã·µ£ : ‚àÄ {œÑ‚ÇÅ œÑ‚ÇÇ œÑ‚ÇÉ : Row (SemType Œî Œ∫)} ‚Üí œÑ‚ÇÅ ‚âãR œÑ‚ÇÇ ‚Üí œÑ‚ÇÇ ‚âãR œÑ‚ÇÉ ‚Üí œÑ‚ÇÅ ‚âãR œÑ‚ÇÉ

sym-‚âã {Œ∫ = ‚òÖ}  refl = refl
sym-‚âã {Œ∫ = L}  refl = refl
sym-‚âã {Œ∫ = Œ∫ `‚Üí Œ∫‚ÇÅ} 
  {F} {G} 
  (Unif-F , (Unif-G , Ext)) = 
     Unif-G ,  Unif-F , (Œª {Œî‚ÇÇ} œÅ {V‚ÇÅ} {V‚ÇÇ} z ‚Üí sym-‚âã (Ext œÅ (sym-‚âã z)))
sym-‚âã {Œ∫ = R[ Œ∫ ]} {l‚ÇÅ ‚ñπ œÑ‚ÇÅ} {l‚ÇÇ ‚ñπ œÑ‚ÇÇ} (eq , rel) = sym eq  , sym-‚âã rel
sym-‚âã {Œ∫ = R[ Œ∫ ]} {row (n , P) _} {row (m , Q) _} (refl , eq-œÅ) =
  refl , 
  (Œª i ‚Üí (sym (eq-œÅ i .fst)) , (sym-‚âã (eq-œÅ i .snd)))
sym-‚âã {Œ∫ = R[ Œ∫ ]} {œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ} {œÅ‚ÇÑ ‚îÄ œÅ‚ÇÉ} (rel‚ÇÅ , rel‚ÇÇ) = (sym-‚âã rel‚ÇÅ) , (sym-‚âã rel‚ÇÇ)
sym-‚âã {Œ∫ = R[ Œ∫ ]} {œÜ‚ÇÅ <$> n‚ÇÅ} {œÜ‚ÇÇ <$> n‚ÇÇ} (refl , Unif-œÜ‚ÇÅ , Unif-œÜ‚ÇÇ , Ext , refl) = refl  , Unif-œÜ‚ÇÇ , Unif-œÜ‚ÇÅ , (Œª r v ‚Üí sym-‚âã (Ext r v) ) , refl
refl-‚âã‚Çó q = trans-‚âã q (sym-‚âã q)
refl-‚âã·µ£ q = refl-‚âã‚Çó (sym-‚âã q)

trans-‚âã {Œ∫ = ‚òÖ} q‚ÇÅ q‚ÇÇ = trans q‚ÇÅ q‚ÇÇ
trans-‚âã {Œ∫ = L} q‚ÇÅ q‚ÇÇ = trans q‚ÇÅ q‚ÇÇ
trans-‚âã {Œ∫ = Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ} {F} {G} {H} 
  (unif-F , unif-G , Ext-F-G) (unif-G' , unif-H , Ext-G-H) = 
    unif-F , 
    unif-H , 
    Œª œÅ q ‚Üí trans-‚âã (Ext-F-G œÅ q) (Ext-G-H œÅ (refl-‚âã‚Çó (sym-‚âã q)))
trans-‚âã {Œ∫ = R[ Œ∫ ]} {l‚ÇÅ ‚ñπ œÑ‚ÇÅ} {l‚ÇÇ ‚ñπ œÑ‚ÇÇ} {l‚ÇÉ ‚ñπ œÑ‚ÇÉ} (eq-l‚ÇÅ , rel-œÑ‚ÇÅ) (eq-l‚ÇÇ , rel-œÑ‚ÇÇ) = trans eq-l‚ÇÅ eq-l‚ÇÇ  , trans-‚âã rel-œÑ‚ÇÅ rel-œÑ‚ÇÇ
trans-‚âã {Œ∫ = R[ Œ∫ ]} {row (n , P) _} {row (m , Q) _} {row (o , R) _} (refl , rel‚ÇÅ) (refl , rel‚ÇÇ) = 
  refl , Œª { i ‚Üí trans (rel‚ÇÅ i .fst) (rel‚ÇÇ i .fst) , trans-‚âã (rel‚ÇÅ i .snd) (rel‚ÇÇ i .snd) }
trans-‚âã {Œ∫ = R[ Œ∫ ]} {œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ} {œÅ‚ÇÑ ‚îÄ œÅ‚ÇÉ} {œÅ‚ÇÜ ‚îÄ œÅ‚ÇÖ} (rel‚ÇÅ , rel‚ÇÇ) (rel‚ÇÉ , rel‚ÇÑ) = (trans-‚âã rel‚ÇÅ rel‚ÇÉ) , (trans-‚âã rel‚ÇÇ rel‚ÇÑ)
trans-‚âã {Œ∫ = R[ Œ∫ ]} {œÜ‚ÇÅ <$> n‚ÇÅ} {œÜ‚ÇÇ <$> n‚ÇÇ} {œÜ‚ÇÉ <$> n‚ÇÉ} (refl , Unif-œÜ‚ÇÅ , Unif-œÜ‚ÇÇ , Ext‚ÇÅ , refl) (refl , _ , Unif-œÜ‚ÇÉ , Ext‚ÇÇ , refl) = refl , Unif-œÜ‚ÇÅ , Unif-œÜ‚ÇÉ , (Œª r v ‚Üí trans-‚âã (Ext‚ÇÅ r v) (Ext‚ÇÇ r v) ) , refl

trans-‚âã·µ£ {œÑ‚ÇÅ = (n , P)} {œÑ‚ÇÇ = (m , Q)} {œÑ‚ÇÉ = (j , K)} (refl , rel‚ÇÅ) (refl , rel‚ÇÇ) = refl , (Œª { i ‚Üí trans (rel‚ÇÅ i .fst) (rel‚ÇÇ i .fst)  , trans-‚âã (rel‚ÇÅ i .snd) (rel‚ÇÇ i .snd) })

refl-Ext‚Çó : ‚àÄ {F G : KripkeFunction Œî‚ÇÅ Œ∫‚ÇÅ Œ∫‚ÇÇ} ‚Üí PointEqual-‚âã F G ‚Üí PointEqual-‚âã F F
refl-Ext‚Çó Ext œÅ q = trans-‚âã (Ext œÅ q) (sym-‚âã (Ext œÅ (refl-‚âã‚Çó (sym-‚âã q))))

sym-Ext : ‚àÄ {F G : KripkeFunction Œî‚ÇÅ Œ∫‚ÇÅ Œ∫‚ÇÇ} ‚Üí PointEqual-‚âã F G ‚Üí PointEqual-‚âã G F
sym-Ext Ext œÅ q = trans-‚âã (refl-‚âã‚Çó (sym-‚âã (Ext œÅ (sym-‚âã q)))) (sym-‚âã (Ext œÅ (sym-‚âã q)))

refl-Ext·µ£ : ‚àÄ {F G : KripkeFunction Œî‚ÇÅ Œ∫‚ÇÅ Œ∫‚ÇÇ} ‚Üí PointEqual-‚âã F G ‚Üí PointEqual-‚âã G G
refl-Ext·µ£ Ext œÅ q = refl-Ext‚Çó (sym-Ext Ext) œÅ q

trans-Ext : ‚àÄ {F G H : KripkeFunction Œî‚ÇÅ Œ∫‚ÇÅ Œ∫‚ÇÇ} ‚Üí PointEqual-‚âã F G ‚Üí PointEqual-‚âã G H ‚Üí PointEqual-‚âã F H
trans-Ext Ext-FG Ext-GH œÅ q = trans-‚âã (Ext-FG œÅ q) (trans-‚âã (Ext-GH œÅ (sym-‚âã q)) (refl-Ext·µ£ Ext-GH œÅ q))
\end{code}

\subsubsection{Properties}~

\begin{code}
reflect-‚âã  : ‚àÄ {œÑ‚ÇÅ œÑ‚ÇÇ : NeutralType Œî Œ∫} ‚Üí œÑ‚ÇÅ ‚â° œÑ‚ÇÇ ‚Üí reflect œÑ‚ÇÅ ‚âã reflect œÑ‚ÇÇ
reify-‚âã    : ‚àÄ {V‚ÇÅ V‚ÇÇ : SemType Œî Œ∫}     ‚Üí V‚ÇÅ ‚âã V‚ÇÇ ‚Üí reify V‚ÇÅ   ‚â° reify V‚ÇÇ 
reifyRow-‚âã : ‚àÄ {n} (P Q : Fin n ‚Üí Label √ó SemType Œî Œ∫) ‚Üí  
               (‚àÄ (i : Fin n) ‚Üí P i ‚âã‚ÇÇ Q i) ‚Üí 
               reifyRow (n , P) ‚â° reifyRow (n , Q)
\end{code}
\begin{code}
\end{code}
\begin{code}[hide]
reflect-‚âã  = bot _ 
reify-‚âã    = bot _ 
reifyRow-‚âã = bot _ 
\end{code}

\subsection{The fundamental theorem and completeness}

\begin{code}
fundC : ‚àÄ {œÑ‚ÇÅ œÑ‚ÇÇ : Type Œî‚ÇÅ Œ∫} {Œ∑‚ÇÅ Œ∑‚ÇÇ : Env Œî‚ÇÅ Œî‚ÇÇ} ‚Üí 
       Env-‚âã Œ∑‚ÇÅ Œ∑‚ÇÇ ‚Üí œÑ‚ÇÅ ‚â°t œÑ‚ÇÇ ‚Üí eval œÑ‚ÇÅ Œ∑‚ÇÅ ‚âã eval œÑ‚ÇÇ Œ∑‚ÇÇ
fundC-pred : ‚àÄ {œÄ‚ÇÅ œÄ‚ÇÇ : Pred Type Œî‚ÇÅ R[ Œ∫ ]} {Œ∑‚ÇÅ Œ∑‚ÇÇ : Env Œî‚ÇÅ Œî‚ÇÇ} ‚Üí 
            Env-‚âã Œ∑‚ÇÅ Œ∑‚ÇÇ ‚Üí œÄ‚ÇÅ ‚â°p œÄ‚ÇÇ ‚Üí evalPred œÄ‚ÇÅ Œ∑‚ÇÅ ‚â° evalPred œÄ‚ÇÇ Œ∑‚ÇÇ
fundC-Row : ‚àÄ {œÅ‚ÇÅ œÅ‚ÇÇ : SimpleRow Type Œî‚ÇÅ R[ Œ∫ ]} {Œ∑‚ÇÅ Œ∑‚ÇÇ : Env Œî‚ÇÅ Œî‚ÇÇ} ‚Üí 
            Env-‚âã Œ∑‚ÇÅ Œ∑‚ÇÇ ‚Üí œÅ‚ÇÅ ‚â°r œÅ‚ÇÇ ‚Üí evalRow œÅ‚ÇÅ Œ∑‚ÇÅ ‚âãR evalRow œÅ‚ÇÇ Œ∑‚ÇÇ
\end{code}
\begin{code}[hide]
fundC = bot _
fundC-pred = bot _
fundC-Row = bot _
\end{code}

\begin{code}
idEnv-‚âã : ‚àÄ {Œî} ‚Üí Env-‚âã (idEnv {Œî}) (idEnv {Œî})
idEnv-‚âã x = reflect-‚âã refl

completeness : ‚àÄ {œÑ‚ÇÅ œÑ‚ÇÇ : Type Œî Œ∫} ‚Üí œÑ‚ÇÅ ‚â°t œÑ‚ÇÇ ‚Üí ‚áì œÑ‚ÇÅ ‚â° ‚áì œÑ‚ÇÇ
completeness eq = reify-‚âã (fundC idEnv-‚âã eq)  

completeness-row : ‚àÄ {œÅ‚ÇÅ œÅ‚ÇÇ : SimpleRow Type Œî R[ Œ∫ ]} ‚Üí œÅ‚ÇÅ ‚â°r œÅ‚ÇÇ ‚Üí ‚áìRow œÅ‚ÇÅ ‚â° ‚áìRow œÅ‚ÇÇ
\end{code}
\begin{code}[hide]
completeness-row = bot _
\end{code}

\subsection{A logical relation for soundness}
\begin{code}
infix 0 ‚ü¶_‚üß‚âã_
‚ü¶_‚üß‚âã_ : ‚àÄ {Œ∫} ‚Üí Type Œî Œ∫ ‚Üí SemType Œî Œ∫ ‚Üí Set
‚ü¶_‚üß‚âãne_ : ‚àÄ {Œ∫} ‚Üí Type Œî Œ∫ ‚Üí NeutralType Œî Œ∫ ‚Üí Set

‚ü¶_‚üßr‚âã_ : ‚àÄ {Œ∫} ‚Üí SimpleRow Type Œî R[ Œ∫ ] ‚Üí Row (SemType Œî Œ∫) ‚Üí Set
‚ü¶_‚üß‚âã‚ÇÇ_ : ‚àÄ {Œ∫} ‚Üí Label √ó Type Œî Œ∫ ‚Üí Label √ó SemType Œî Œ∫ ‚Üí Set
‚ü¶ (l‚ÇÅ , œÑ) ‚üß‚âã‚ÇÇ (l‚ÇÇ , V) = (l‚ÇÅ ‚â° l‚ÇÇ) √ó (‚ü¶ œÑ ‚üß‚âã V)

SoundKripke : Type Œî‚ÇÅ (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ) ‚Üí KripkeFunction Œî‚ÇÅ Œ∫‚ÇÅ Œ∫‚ÇÇ ‚Üí Set
SoundKripkeNE : Type Œî‚ÇÅ (Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ) ‚Üí KripkeFunctionNE Œî‚ÇÅ Œ∫‚ÇÅ Œ∫‚ÇÇ ‚Üí Set

-- œÑ is equivalent to neutral `n` if it's equivalent 
-- to the Œ∑ and map-id expansion of n
‚ü¶_‚üß‚âãne_ œÑ n = œÑ ‚â°t ‚áë (Œ∑-norm n)

‚ü¶_‚üß‚âã_ {Œ∫ = ‚òÖ} œÑ‚ÇÅ œÑ‚ÇÇ = œÑ‚ÇÅ ‚â°t ‚áë œÑ‚ÇÇ
‚ü¶_‚üß‚âã_ {Œ∫ = L} œÑ‚ÇÅ œÑ‚ÇÇ = œÑ‚ÇÅ ‚â°t ‚áë œÑ‚ÇÇ
‚ü¶_‚üß‚âã_ {Œî‚ÇÅ} {Œ∫ = Œ∫‚ÇÅ `‚Üí Œ∫‚ÇÇ} f F = SoundKripke f F
‚ü¶_‚üß‚âã_ {Œî} {Œ∫ = R[ Œ∫ ]} œÑ (row (n , P)  oœÅ) =
    let xs = ‚áëRow (reifyRow (n , P)) in 
    (œÑ ‚â°t ‚¶Ö xs ‚¶Ü (fromWitness (Ordered‚áë (reifyRow (n , P)) (reifyRowOrdered' n P oœÅ)))) √ó 
    (‚ü¶ xs ‚üßr‚âã (n , P))
‚ü¶_‚üß‚âã_ {Œî} {Œ∫ = R[ Œ∫ ]} œÑ (l ‚ñπ V) = (œÑ ‚â°t (‚áëNE l ‚ñπ ‚áë (reify V))) √ó (‚ü¶ ‚áë (reify V) ‚üß‚âã V)
‚ü¶_‚üß‚âã_ {Œî} {Œ∫ = R[ Œ∫ ]} œÑ ((œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) {nr}) = (œÑ ‚â°t (‚áë (reify ((œÅ‚ÇÇ ‚îÄ œÅ‚ÇÅ) {nr})))) √ó (‚ü¶ ‚áë (reify œÅ‚ÇÇ) ‚üß‚âã œÅ‚ÇÇ) √ó (‚ü¶ ‚áë (reify œÅ‚ÇÅ) ‚üß‚âã œÅ‚ÇÅ)
‚ü¶_‚üß‚âã_ {Œî} {Œ∫ = R[ Œ∫ ]} œÑ (œÜ <$> n) = 
  ‚àÉ[ f ] ((œÑ ‚â°t (f <$> ‚áëNE n)) √ó (SoundKripkeNE f œÜ))
‚ü¶ [] ‚üßr‚âã (zero , P) = ‚ä§
‚ü¶ [] ‚üßr‚âã (suc n , P) = ‚ä•
‚ü¶ x ‚à∑ œÅ ‚üßr‚âã (zero , P) = ‚ä•
‚ü¶ x ‚à∑ œÅ ‚üßr‚âã (suc n , P) =  (‚ü¶ x ‚üß‚âã‚ÇÇ (P fzero)) √ó ‚ü¶ œÅ ‚üßr‚âã (n , P ‚àò fsuc)

SoundKripke {Œî‚ÇÅ = Œî‚ÇÅ} {Œ∫‚ÇÅ = Œ∫‚ÇÅ} {Œ∫‚ÇÇ = Œ∫‚ÇÇ} f F =     
    ‚àÄ {Œî‚ÇÇ} (œÅ : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) {v V} ‚Üí 
      ‚ü¶ v ‚üß‚âã V ‚Üí 
      ‚ü¶ (ren‚Çñ œÅ f ¬∑ v) ‚üß‚âã (renKripke œÅ F ¬∑V V)

SoundKripkeNE {Œî‚ÇÅ = Œî‚ÇÅ} {Œ∫‚ÇÅ = Œ∫‚ÇÅ} {Œ∫‚ÇÇ = Œ∫‚ÇÇ} f F =     
    ‚àÄ {Œî‚ÇÇ} (r : Renaming‚Çñ Œî‚ÇÅ Œî‚ÇÇ) {v V} ‚Üí 
      ‚ü¶ v ‚üß‚âãne  V ‚Üí 
      ‚ü¶ (ren‚Çñ r f ¬∑ v) ‚üß‚âã (F r V)
\end{code}

\subsubsection{Properties}~
\begin{code}
reflect-‚ü¶‚üß‚âã : ‚àÄ {œÑ : Type Œî Œ∫} {œÖ :  NeutralType Œî Œ∫} ‚Üí 
             œÑ ‚â°t ‚áëNE œÖ ‚Üí ‚ü¶ œÑ ‚üß‚âã (reflect œÖ)
reify-‚ü¶‚üß‚âã : ‚àÄ {œÑ : Type Œî Œ∫} {V :  SemType Œî Œ∫} ‚Üí 
               ‚ü¶ œÑ ‚üß‚âã V ‚Üí œÑ ‚â°t ‚áë (reify V)
Œ∑-norm-‚â°t : ‚àÄ (œÑ : NeutralType Œî Œ∫) ‚Üí ‚áë (Œ∑-norm œÑ) ‚â°t ‚áëNE œÑ 
subst-‚ü¶‚üß‚âã : ‚àÄ {œÑ‚ÇÅ œÑ‚ÇÇ : Type Œî Œ∫} ‚Üí 
  œÑ‚ÇÅ ‚â°t œÑ‚ÇÇ ‚Üí {V : SemType Œî Œ∫} ‚Üí ‚ü¶ œÑ‚ÇÅ ‚üß‚âã V ‚Üí ‚ü¶ œÑ‚ÇÇ ‚üß‚âã V 
\end{code}

\subsubsection{Logical environments}~
\begin{code}
‚ü¶_‚üß‚âãe_ : ‚àÄ {Œî‚ÇÅ Œî‚ÇÇ} ‚Üí Substitution‚Çñ Œî‚ÇÅ Œî‚ÇÇ ‚Üí Env Œî‚ÇÅ Œî‚ÇÇ ‚Üí Set  
‚ü¶_‚üß‚âãe_ {Œî‚ÇÅ} œÉ Œ∑ = ‚àÄ {Œ∫} (Œ± : TVar Œî‚ÇÅ Œ∫) ‚Üí ‚ü¶ (œÉ Œ±) ‚üß‚âã (Œ∑ Œ±)

-- Identity relation
idSR : ‚àÄ {Œî‚ÇÅ} ‚Üí  ‚ü¶ ` ‚üß‚âãe (idEnv {Œî‚ÇÅ})
idSR Œ± = reflect-‚ü¶‚üß‚âã eq-refl
\end{code}
\begin{code}[hide]
reflect-‚ü¶‚üß‚âã = bot _
reify-‚ü¶‚üß‚âã = bot _
Œ∑-norm-‚â°t = bot _
subst-‚ü¶‚üß‚âã = bot _
\end{code}
\subsection{The fundamental theorem and soundness}
\begin{code}
fundS : ‚àÄ {Œî‚ÇÅ Œî‚ÇÇ Œ∫}(œÑ : Type Œî‚ÇÅ Œ∫){œÉ : Substitution‚Çñ Œî‚ÇÅ Œî‚ÇÇ}{Œ∑ : Env Œî‚ÇÅ Œî‚ÇÇ} ‚Üí 
          ‚ü¶ œÉ ‚üß‚âãe Œ∑  ‚Üí ‚ü¶ sub‚Çñ œÉ œÑ ‚üß‚âã (eval œÑ Œ∑)
fundSRow : ‚àÄ {Œî‚ÇÅ Œî‚ÇÇ Œ∫}(xs : SimpleRow Type Œî‚ÇÅ R[ Œ∫ ]){œÉ : Substitution‚Çñ Œî‚ÇÅ Œî‚ÇÇ}{Œ∑ : Env Œî‚ÇÅ Œî‚ÇÇ} ‚Üí 
          ‚ü¶ œÉ ‚üß‚âãe Œ∑  ‚Üí ‚ü¶ subRow‚Çñ œÉ xs ‚üßr‚âã (evalRow xs Œ∑)
fundSPred : ‚àÄ {Œî‚ÇÅ Œ∫}(œÄ : Pred Type Œî‚ÇÅ R[ Œ∫ ]){œÉ : Substitution‚Çñ Œî‚ÇÅ Œî‚ÇÇ}{Œ∑ : Env Œî‚ÇÅ Œî‚ÇÇ} ‚Üí 
          ‚ü¶ œÉ ‚üß‚âãe Œ∑ ‚Üí (subPred‚Çñ œÉ œÄ) ‚â°p ‚áëPred (evalPred œÄ Œ∑) 
\end{code}

\begin{code}[hide]
fundS = bot _
fundSRow = bot _
fundSPred = bot _
\end{code}

\begin{code}
--------------------------------------------------------------------------------
-- Fundamental theorem when substitution is the identity
sub‚Çñ-id : ‚àÄ (œÑ : Type Œî Œ∫) ‚Üí sub‚Çñ ` œÑ ‚â° œÑ 

‚ä¢‚ü¶_‚üß‚âã : ‚àÄ (œÑ : Type Œî Œ∫) ‚Üí ‚ü¶ œÑ ‚üß‚âã eval œÑ idEnv
‚ä¢‚ü¶ œÑ ‚üß‚âã = subst-‚ü¶‚üß‚âã (inst (sub‚Çñ-id œÑ)) (fundS œÑ idSR)
\end{code}
\begin{code}[hide]
sub‚Çñ-id œÑ = bot _
\end{code}

\begin{code}
--------------------------------------------------------------------------------
-- Soundness claim  

soundness :  ‚àÄ {Œî‚ÇÅ Œ∫} ‚Üí (œÑ : Type Œî‚ÇÅ Œ∫) ‚Üí œÑ ‚â°t ‚áë (‚áì œÑ) 
soundness œÑ = reify-‚ü¶‚üß‚âã (‚ä¢‚ü¶ œÑ ‚üß‚âã)

 --------------------------------------------------------------------------------
-- If œÑ‚ÇÅ normalizes to ‚áì œÑ‚ÇÇ then the embedding of œÑ‚ÇÅ is equivalent to œÑ‚ÇÇ

embed-‚â°t : ‚àÄ {œÑ‚ÇÅ : NormalType Œî Œ∫} {œÑ‚ÇÇ : Type Œî Œ∫}  ‚Üí œÑ‚ÇÅ ‚â° (‚áì œÑ‚ÇÇ) ‚Üí ‚áë œÑ‚ÇÅ ‚â°t œÑ‚ÇÇ
embed-‚â°t {œÑ‚ÇÅ = œÑ‚ÇÅ} {œÑ‚ÇÇ} refl = eq-sym (soundness œÑ‚ÇÇ) 

--------------------------------------------------------------------------------
-- Soundness implies the converse of completeness, as desired

Completeness‚Åª¬π : ‚àÄ {Œî Œ∫} ‚Üí (œÑ‚ÇÅ œÑ‚ÇÇ : Type Œî Œ∫) ‚Üí ‚áì œÑ‚ÇÅ ‚â° ‚áì œÑ‚ÇÇ ‚Üí œÑ‚ÇÅ ‚â°t œÑ‚ÇÇ
Completeness‚Åª¬π œÑ‚ÇÅ œÑ‚ÇÇ eq = eq-trans (soundness œÑ‚ÇÅ) (embed-‚â°t eq)
\end{code}

\section{The rest of the picture}

In the remainder of the development, we intrinsically represent terms as typing judgments indexed by normal types. We then give a typed reduction relation on terms and show progress.

\section{Most closely related work}
\subsubsection{\citet{ChapmanKNW19}}
\subsubsection{\citet{AllaisBM13}}


\bibliographystyle{plainnat}
\bibliography{NBE}
\end{document}
%%% Local Variables: 
%%% TeX-command-extra-options: "-shell-escape"
%%% End:
%  LocalWords:  denotational Agda Wadler dPoint sqrt subtyping coercions Intr
%  LocalWords:  RowTypes Bool eval GHC reified HillerstromL Leijen LindleyM RO
%  LocalWords:  ChapmanKNW Aydemir AbelAHPMSS AbelC AbelOV plfa HubersIMM STLC
%  LocalWords:  MorrisM denotationally DenotationalSoundness RowTheories Suc de
%  LocalWords:  ReifyingVariants RowTheory BerthomieuM CardelliMMS HarperP NatF
%  LocalWords:  XueOX GasterJ Sipser SaffrichTM Env Expr Agda's Leivant ChanW
%  LocalWords:  ThiemannW ImpredicativeSet ImpredicativeSetSucks AbelP chapman
%  LocalWords:  AltenkirchK KaposiKK Gaster XieOBS BiXOS Chlipala objTypes Bahr
%  LocalWords:  Garrigue KEnv PEnv
