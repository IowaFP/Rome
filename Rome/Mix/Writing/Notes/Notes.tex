\documentclass[12pt]{article}
\usepackage[margin=1.5in]{geometry}

\usepackage{
  % AH> I don't know how much of these are used, and for what.
  %     (needs untangling.) 
  enumitem,
  xspace,
  mathtools,
  multicol,
  tikz-cd,
  parskip,
  mathrsfs,
  stmaryrd,
  tikz,
  float,
  titlecaps,
  soul,
  upgreek,
  caption,
  graphicx,
  array,
  subcaption,
  amsmath,
  amsthm,
  amssymb,
  bibentry,
  bibunits,
  ../sty/mathwidth,
  ../sty/sectsty,
  ../sty/commands,
  ../sty/infer,
  ../sty/commands,
  ../sty/higher
}

\usepackage{natbib}

% tikz
\usepackage{tikz}
\usepackage{tikz-cd}

\newcommand\secfig[2]{Figure \ref{fig:#2}, \S\ref{sec:#1}}
\newcommand\Nat{\mathrm{Nat}}
\newcommand\Zero{\mathrm{Zero}}
\newcommand\Suc{\mathrm{Suc}}
\newcommand\Fin{\mathrm{Fin}}
\newcommand\Ix[1]{\mathrm{Ix} \, #1}
\newcommand\MuIx{\ensuremath{\mu}Ix}
\renewcommand\Type{\mathrm{Type}}
\newcommand\FormJ[2]{\ensuremath{#1 \vdash #2 \, \Type}}

\title{The Recursive Index Calculus and Its Translation From \RO}

\author{AH \& JGM}


\begin{document}

\maketitle

\section{Example translations of \RO terms and types}

\paragraph{Record selection.}
In \RO,

\[
\forall \rho : \RowK \star, \, \ell : \LabK, \, \tau : \TypeK. \Leqp {\Row {\LabTy \ell \tau}} {\rho} \then {\Sing \ell} \to {\Pi \rho} \to \tau
\]

translates to

\[
\Pi (\rho : \mathrm{Row }\, \star). \Pi (\ell : \top). \Pi (\tau : \star). \Ixed{\Leqp {\Row {\LabTy \ell \tau}} {\rho}}. \Pi (\_ : \top). \Pi (i : \Ix {\rho.1}). \, \rho.2 \, i 
\]

where

\begin{align*}
\mathrm{Row } \kappa :&= \Sigma (n : \Nat). \Pi (i : \Ix n). \kappa \\
\Ixed{\Leqp {\Row {\LabTy \ell \tau}} {\rho}} &= \Pi (i : \Ix \Ixed{\Row {\LabTy \ell \tau}}.1). \Sigma (j : \Ix {\rho.1}). \Ixed{\Row {\LabTy \ell \tau}}.1 \; i \equiv {\rho}.2 \; j \\
\Ixed{\Row {\LabTy \ell \tau}} &= (\Suc \, \Zero : \Nat, \lambda (i : \Ix {(\Suc \, \Zero)}). \Ixed{\tau})
\end{align*}

Putting this all together:

\begin{align*}
&\Pi (\rho : (\Sigma (n : \Nat). \Pi (i : \Ix n). \star)).\\ 
&\Pi (\ell : \top). \\
&\Pi (\tau : \star). \\
&\Pi (P :      \\
&\quad \Pi (i : \Ix (\Suc \, \Zero : \Nat, \lambda (i : \Ix {(\Suc \, \Zero)}). \Ixed{\tau}).1). \\
&\quad      \Sigma (j : \Ix {\rho.1}).  \\
&\quad      (\Suc \, \Zero : \Nat, \lambda (i : \Ix {(\Suc \, \Zero)}). \Ixed{\tau}).2 \; i \equiv {\rho}.2 \; j) \\
&\Pi (\_ : \top). \\
&\Pi (i : \Ix {\rho.1}). \, \rho.2 \, i 
\end{align*}

which should normalize to

\begin{align*}
&\Pi (\rho : (\Sigma (n : \Nat). \Pi (i : \Ix n). \star)).\\ 
&\Pi (\ell : \top). \\
&\Pi (\tau : \star). \\
&\Pi (P :      \\
&\quad \Pi (i : \Ix 1). \\
&\quad      \Sigma (j : \Ix {\rho.1}).  \\
&\quad       \Ixed{\tau} \equiv {\rho}.2 \; j). \\
&\Pi (\_ : \top). \\
&\Pi (i : \Ix {\rho.1}). \, \rho.2 \, i 
\end{align*}

\section{Design considerations of the formal index calculus}

\subsection{The necessity of Set-in-Set}

Denote the translation of \RO type $\tau$ to the index calculus as $\Sem{\tau}$. The big stars of systems $R$\&c. are record and variants. Consider how we might translate the former. We first establish the translation of kinds so that we may assert that translated types are in the meaning of their translated kinds. (This is a sensible verification.) The following seems reasonable.

\begin{align*}
  \Sem{\TypeK}_\kappa &= \TypeK \\
  \Sem{\LabK}_\kappa &= \top \\
  \Sem{\kappa_1 \to \kappa_2}_\kappa &= \Sem{\kappa_1} \to \Sem{\kappa_2} \\
  \Sem{\RowK \kappa}_\kappa &= \exists i \co Nat. (\Fin \, i \to \Sem{\kappa}) \\
\end{align*}

(Nevermind, for now, the complexity of existentially quantifying Nats within kinds.) Recall that records (in \RO) live in kind $\TypeK$ but, as shown in our Agda denotation, should translate to functions which map finite indices to types. Below is a sensible type and translation for such an idea. (As $\Sem{\rho}$ is a dependent product, let its first and second projections be defined as usual.)

\begin{align*}
  \Sem{\Pi \, \rho} &= \forall i \co \Nat. \Fin \, \Sem{\rho}.1 \to \Sem{\rho}.2 \, i
\end{align*}

Yet, as $\Pi \, \rho : \TypeK$ (in \RO), we must conclude that the type $\forall i \co \Nat. \Fin \, \Sem{\rho}.1 \to \Sem{\rho}.2 \, i$ has kind $\TypeK$ in \MuIx. I don't see a way around this. Further, it implies to me that we would like to flatten types and kinds and let types quantify over types. That is to say, we want a two-level stratification of terms and types only, omitting kinds. The next two subsections argue for this change.

\subsection{Flattening kinds and types}

Revisit now the translation of rows.

\[
  \Sem{\RowK \kappa}_\kappa = \exists i \co \Nat. (\Fin \, i \to \Sem{\kappa})
\]

The existential quantification of $i \co \Nat$ is ambiguous. We seem to need to either (i) permit the dependent, existential quantification over \emph{type} $\Nat$, or (ii) lift Nat indices to kinds and permit the existential quantification of indices in kinds. In the latter case, we would further need to represent the \emph{application} of $\Fin$ to \emph{index variable} $i$---and also, of course, need to represent existential quantification in kinds (and represent Fin!). This becomes cumbersome quickly, enough to beg the question: why distinguish types from kinds at all?

\subsubsection{The inadequacy of \citet{XiP99}}

Described above by (i) is the approach advocated by \citet{XiP99}. \citet{XiP99} only permits types to be indexed by a declared set of index objects, each with index sort---for example, vectors are indexed by index objects with index sort Nat. The syntax of (some simple) indices is given below.

\begin{smalle}
\begin{gather*}
\begin{doublesyntaxarray}
  \mcl{\text{Index Sorts}} & \gamma & ::= & \Nat \mid \top \mid ... \\
  \mcl{\text{Index Objects}} & \iota & ::= & i \mid ()  \mid ...
\end{doublesyntaxarray}
\end{gather*}
\end{smalle}

Rather than types we have \emph{families of types}, each indexed by \emph{index objects}. For example, an $intlist$ might be a family type family indexed by $\Nat$, representing its length. Consider the typing of vector concatenation.

\[
\Tt{concat} : \Pi m: \Nat. \Pi n : \Nat. intlist \, m \to intlist \, n \to intlist\, (m + n)
\]

This machinery is not sufficient to type many \RO terms. To illustrate, presume a base set of index sorts $\gamma$ and index objects $\iota$ to be as defined below. (For convenience, let  the index objects of $\iota$ inhabit both Nat and $\Fin \, \iota$.)


\begin{smalle}
\begin{gather*}
\begin{doublesyntaxarray}
   & \gamma & ::= & \Nat \mid \Fin \, \iota \\
   & \iota & ::= & i \mid 0 \mid \Suc\, \iota
\end{doublesyntaxarray}
\end{gather*}
\end{smalle}

Now consider an example translation of record concatenation from \RO to \MuIx. In \RO, we have:

\begin{align*}
  \Tt{concat} : \forall (z_1 z_2 z_3 \co \RowK \TypeK). {z_1} \cdot {z_2} \sim {z_3} \then \Pi \, z_1 \to \Pi \, z_2 \to \Pi \, z_3
\end{align*}

This (hypothetically) translates to (the sketch I have in my head of) the \MuIx\, type:

\begin{align*}
  \Tt{concat} : &\forall^i m n l \co Nat. \\
               &\forall (z_1 \co \Fin\, m \to \TypeK) (z_2 \co \Fin\, n \to \TypeK) (z_3 \co \Fin\, l \to \TypeK). \\
             &\Sem{z_1 \cdot z_2 ~ z_3} \to \\
             &(\forall (i : \Fin \, m) \to z_1\, i)\\
             &(\forall (i : \Fin \, n) \to z_2\, i) \\
             &\forall (i : \Fin \, l).   z_3\, i
\end{align*}

Let $\forall^{i}$ denote the quantification of indices in types and $\Sem{z_{1} \cdot z_{2} \sim z_{3}}$ denote the (yet-undefined) translation of $\RO$ predicates to \MuIx{} types. The glaring incompatibility of \cite{XiP99} is that \RO is higher-order. So, it is not clear what the quantification of $z_1$ over $(\Fin\, m \to \TypeK)$ means. Is $(\Fin\, m \to \TypeK)$ a kind? \cite{XiP99} permits only the quantification over indices, and the use of those indices in types. The authors do not permit $F\omega$ (or just System F)-style quantification over type variables. And it is not clear how to lift their calculus to higher-order; I suspect, also, nontrivial.

A lot of our problems go away when committing to an impredicative, dependent, term-and-type-stratified type theory. So, this is what I suggest we do. Firstly, the higher-order nature of $F\omega$ is given for free, as there are no more kinds and thus all type-level quantification is over types. W.r.t. mechanizational ease, we substantially reduce the overlap in ASTs. 

What we are left with is more less MLTT with (built-in) finite naturals. Call it $\lambda^{\Pi,\Sigma}$ for now.

\subsection{Consistency in impredicative MLTT}

Martin L\:{o}f Type Theory is well known to be inconsistent without a predicative universe hierarchy \citet{Hurkens95, MonnierN19, Coquand92}. The calculus of constructions, however, has two sorts---$P$, that of (impredicative) predicates, and $T$ the type of $P$. This turns out to be consistent. It should be known why, but I do not know now.

\end{document}

