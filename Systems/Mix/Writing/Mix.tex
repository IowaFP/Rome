\documentclass[authoryear,acmsmall,screen]{acmart}
\citestyle{acmauthoryear}

\overfullrule=1mm

\usepackage{
  % AH> I don't know how much of these are used, and for what.
  %     (needs untangling.) 
  relsize,
  enumitem,
  xspace,
  mathtools,
  multicol,
  tikz-cd,
  parskip,
  mathrsfs,
  stmaryrd,
  tikz,
  float,
  titlecaps,
  soul,
  upgreek,
  caption,
  graphicx,
  array,
  subcaption,
  % amsmath,
  % amsthm,
  % amssymb,
  bibentry,
  bibunits,
  ./sty/mathwidth,
%  ../sty/sectsty,
  ./sty/commands,
  ./sty/infer,
  ./sty/commands,
  ./sty/higher,
  ./sty/mymath
}

\usepackage{natbib}

% tikz
\usepackage{tikz}
\usepackage{tikz-cd}

\title{Recursive Rows in Rome}

\author{AH \& JGM}

\newcommand\Lift[1]{\ensuremath{\lceil #1 \rceil}}
\newcommand\Fst{\mathrm{fst}}
\newcommand\Snd{\mathrm{snd}}
\newcommand\U{\mathcal{U}}
\newcommand\Pointed[1]{\ensuremath{#1_{\bot}}}
\newcommand\PointedT{\Pointed{\star}}
\newcommand\PointedU{\Pointed{\U}}
\newcommand\J[4]{\mathcal{J} \, #1 \, #2 \, #3 \, #4}
\newcommand\Refl{\mathrm{refl}}
\renewcommand\left{\mathrm{left}}
\renewcommand\right{\mathrm{right}}
\renewcommand\Case{\mathrm{case}}
\newcommand\CaseN[4]{\ensuremath{\Case_{\mathbb{N}} \, #1 \, \mathrm{of} \{ \Zero \mapsto #2; \Suc\, #3 \mapsto #4 \}}}
\newcommand\CaseF[4]{\ensuremath{\Case_{\mathrm{Fin}} \, #1 \, \mathrm{of} \{ \FZero \mapsto #2; \FSuc\, #3 \mapsto #4 \}}}
\newcommand\CaseP[3]{\ensuremath{\Case_{\mathrm{\exists}} \, #1 \, \mathrm{of} \{ (#1, #2) \mapsto #3 \} }}
\newcommand\CaseS[5]{\ensuremath{\Case_{\mathrm{+}} \, #1 \, \mathrm{of} \, \{ \left \, #2 \mapsto #3 ; \right \, #4 \mapsto #5 \} }}
\newcommand\Rule[1]{(\textsc{#1})}
\newcommand\Safe[1]{\ensuremath{#1 \; \mathrm{Safe}}}
\newcommand\SafeJ[2]{\ensuremath{#1 \vdash #2 \; \mathrm{Safe}}}
\newcommand\Felim[1]{\{\!\!\{#1\}\!\!\}}

\newcommand\New[1]{{\color{blue}#1}}

\begin{document}

\maketitle

\section{\IX: The Index Calculus}

\subsection{Syntax}

Let $0,1,2,...$ denote object-level natural numbers in the intuitive fashion and let $i_{n}$ be the finite natural obtained by $n$ applications of $\FSuc$ to $\FZero$.

\begin{figure}[H]
\begin{smalle}
\begin{gather*}
\begin{array}{r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l}
%  \text{Term variables} & x \; \alpha % & \text{sort variables} & \alpha %% & & \text{Labels} & \ell & \text{Directions} & d \in \Set {\Left, \Right}
\end{array}
\\[5px]
\begin{doublesyntaxarray}
  \mcl{\text{Sorts}} & \sigma & ::= & \star \mid \U \\
  \mcl{\text{Terms}} & A, B, M, N, T & ::= & \star \mid x \mid \\
  & & & & \Nat \mid \Zero \mid \Suc \, M \mid \\
  & & & & \CaseN M {N_1} x {N_2} \mid \\
  & & & & \Ix{M} \mid \FZero \mid \FSuc \; M \mid \\
  & & & & \CaseF M {N_1} x {N_2} \mid \\
  & & & & \Felim {M_1,...,M_n} \mid \\
  & & & &  \top \mid \tt \mid \\
  & & & &  \forall \alpha \co T. N \mid \lambda x \co T. N \mid M \, N \mid \\
  & & & &  \exists \alpha \co T. M \mid (\alpha \co T , M) \mid \\
  & & & &  M + N \mid \left\, M \mid \right\, M \mid \\
  & & & & \CaseS {M} x {N_1} y {N_2} \mid \\
  & & & &  M \equiv N \mid \Refl \, T \, M \, N \mid \\
  \mcl{\text{Environments}} & \Gamma & ::= & \varepsilon \mid \Gamma, \alpha : T
\end{doublesyntaxarray}
\end{gather*}
\end{smalle}
\caption{Syntax}
\label{fig:syntax}
\end{figure}

The syntax $\Felim {M_1,...,M_n}$ is syntactic sugar for the large elimination of finite naturals on a known number of cases, defined recursively: (fix this later... multiple routes. Technically the absurd pattern has in its context an absurd assumption (that 1 == 2).) But maybe can just fix this with typing rules.

Actually it will be better to just introduce a singleton elimination form.

\begin{align*}
  \Felim {M} = \lambda x : \Ix 1. \CaseF x M \bot \bot
\end{align*}
\[
\Felim {M_1,...,M_n} =_{def} \lambda (x : \Ix n). \CaseF x {M_{1}} x {\CaseF x {M_{2}} butts}
\]

\subsection{Typing}


\begin{figure}[H]
\small
\begin{gather*}
\fbox{$\EnvJ \Gamma$}
\\
\ib{\irule[\Rule{emp}]{ };{\EnvJ \varepsilon}}
\rsp
\ib{\irule[\Rule{var}]
          {\EnvJ \Gamma}
          {\SortJ \Gamma M \sigma};
          {\EnvJ {\Gamma, x : M}}}
\end{gather*}

\begin{gather*}
\fbox{$\TypeJ \Gamma M \sigma$} 
\\
\ib{\irule[\Rule{$\star$}] ; {\TypeJ \Gamma \star \U}} 
\rsp
\ib{\irule[\Rule{$\top$}] {} ; {\SortJ \Gamma \top \sigma}}
\rsp
\ib{\irule[\Rule{Nat}] {} ; {\SortJ \Gamma \Nat \star}}
\rsp
\ib{\irule[\Rule{Ix}] {\SortJ \Gamma n \Nat} ; {\SortJ \Gamma {\Ix n} \star}} \\
\ib{\irule[\Rule{$\forall$}]{\SortJ \Gamma M \sigma_1} {\SortJ {\Gamma, \alpha \co M}{N}{\sigma_2}};{\SortJ \Gamma {\forall \alpha \co M. N} \sigma_2}}
\rsp
\ib{\irule[\Rule{$\exists$}]{\SortJ \Gamma M \sigma_1} {\SortJ {\Gamma, \alpha \co M}{N}{\sigma_2}};{\SortJ \Gamma {\exists \alpha \co M. N} \sigma_2}} \\
\ib{\irule[\Rule{$+$}]{\SortJ \Gamma M \sigma}{\SortJ \Gamma N \sigma};{\SortJ \Gamma {M + N} {\sigma}}}
\rsp
\ib{
  \irule[\Rule{$\equiv$}]
  {\SortJ \Gamma {M} {\sigma}}
  {\SortJ \Gamma {N} {\sigma}};
  {\SortJ \Gamma {{M} \equiv {N}} {\sigma}}}
\end{gather*}
\caption{Context and type formation rules}
\label{fig:formation}
\end{figure}

\begin{figure}[H]
\small
% \ib{\irule{};{}}
\begin{gather*}
\fbox{$\TypeJ \Gamma M N$} \\
\ib{\irule[\Rule{Var}]{x \co M \in \Gamma} ; {\TypeJ \Gamma x M}} 
\rsp
\ib{\irule[\Rule{$\tt$}]{};{\TypeJ \Gamma {\tt} \top}} 
\\
\ib{\irule[\Rule{$\Zero$}]{};{\TypeJ \Gamma \Zero \Nat}} 
\rsp
\ib{\irule[\Rule{$\Suc{}$}]{\TypeJ \Gamma n \Nat};{\TypeJ \Gamma {\Suc \, n} \Nat}} 
\rsp
\\
\ib{\irule[\Rule{$\FZero$}]{{\TypeJ \Gamma n \Nat}};{\TypeJ \Gamma \FZero {\Ix (\Suc \, n)}}} 
\rsp
\ib{\irule[\Rule{$\FSuc{}$}]{\TypeJ \Gamma n \Nat}{\TypeJ \Gamma i {\Ix n}};{\TypeJ \Gamma {\FSuc \, i} {\Ix {(\Suc \, n)}}}} 
\\
\ib{\irule[\Rule{$\I\forall$}]
  {\SortJ \Gamma T \star}
  {\TypeJ {\Gamma , x \co T} {M} {N}};
  {\TypeJ \Gamma {\lambda x \co T. M} {\forall (x \co T). N}}}
\rsp
\ib{\irule[\Rule{$\E\forall$}]
    {\TypeJ \Gamma M {\forall(x \co T_1). T_2}} {\TypeJ \Gamma N {T_1}};
    {\TypeJ \Gamma {M \, N} T_2[N/x]}}
\\
 \ib{\irule[\Rule{$\I\exists$}]
      {\TypeJ {\Gamma}{M}{T_1}}
      {\TypeJ {\Gamma} {N} {T_2[M/x]}};
      {\TypeJ \Gamma {(M \co T_1, N)} {\exists (x \co T_1). T_2}}}
\rsp
 \ib{\irule [\Rule{$\E\exists_{1}$}]
     {\TypeJ \Gamma M {\Sigma (x \co T_1). T_2}}; 
     {\TypeJ \Gamma {\Fst \, M} T_1}}
\rsp
 \ib{\irule [\Rule{$\E\exists_{2}$}]
     {\TypeJ \Gamma M {\Sigma (x \co T_1). T_2}}; 
     {\TypeJ \Gamma {\Snd \, M} T_1[\Fst \, M/x]}}
\\
\ib{
  \irule [\Rule{$\I\equiv$}]
  {\TypeJ \Gamma M \sigma};
  {\TypeJ \Gamma {\Refl} {M \equiv M}}}
\rsp
\ib{
  \irule [\Rule{conv}]
  {\TypeJ \Gamma M T_1}
  {\TypeJ \Gamma {T_1 = T_2} {\sigma}}
  {\Safe \sigma};
  {\TypeJ \Gamma M T_2}}
\\
\ib{
  \irule [\Rule{$\E\equiv$}]
      {\mathlarger{\mathlarger{\mathlarger{\substack{ 
        {\TypeJ \Gamma {P} {T_1 \equiv T_2}} \\
        {\Gamma \vdash M : T_1} \\
        {\Gamma \vdash N : T_1} \\
        {\TypeJ {\Gamma, x \co T_1, y \co T_1, p \co x \equiv y} {T} {\star}} \\
        {\TypeJ {\Gamma , z \co T_1} H {T[z/x, z/y, \Refl/p]} }}}}}}
  ;
  {\TypeJ \Gamma {\J H M N P} {T[M/x,N/y,P/p]}}}
\end{gather*}
\caption{Typing rules. \Todo{Missing nat, fin, and sum elimination. Fin elimination should have special case for $\Ix 1$.}}
\label{fig:IxRules}
\end{figure}

\begin{figure}[H]
\small
\begin{gather*}
\fbox{$\TypeJ \Gamma {M = N} \sigma$} \\
\ib{
  \irule[\erule{refl}]
  {\TypeJ \Gamma M \sigma} 
  ;
  {\TypeJ \Gamma {M = M} \sigma}}
\rsp
\ib{
  \irule[\erule{sym}]
  {\TypeJ \Gamma {N = M} \sigma} 
  ;
  {\TypeJ \Gamma {M = N} \sigma}}
\rsp
\ib{
  \irule[\erule{trans}]
  {\TypeJ \Gamma {M = P} \sigma} {{\TypeJ \Gamma {P = N} \sigma}}
  ;
  {\TypeJ \Gamma {M = N} \sigma}}
\end{gather*}
\begin{gather*}
\fbox{$\TypeJ \Gamma {M = N} T$} \\
\ib{
  \irule[\crule{refl}]
  {\TypeJ \Gamma M T} 
  ;
  {\TypeJ \Gamma {M = M} T}}
\rsp
\ib{
  \irule[\crule{sym}]
  {\TypeJ \Gamma {N = M} T} 
  ;
  {\TypeJ \Gamma {M = N} T}}
\rsp
\ib{
  \irule[\crule{trans}]
  {\TypeJ \Gamma {M = P} T} {{\TypeJ \Gamma {P = N} T}}
  ;
  {\TypeJ \Gamma {M = N} T}}
\end{gather*}
\caption{Definitional equality \& computational laws}
\label{fig:IxDefnEq}
\end{figure}

\subsection{A Comparison to $\lambda^{\Pi\mathcal{U}\mathbb{N}}$ \cite{AbelOV18}}


\section{Translation From \RO}

\subsection{Untyped Translation}

We follow the approach of \cite{MorrisM19} and give both typed and untyped translations of \RO types. \cref{fig:translation} describe the untyped translation, which is used to show translational soundness of the typed translation (\cref{fig:translation}).


\begin{figure}[H]
\begin{gather*}
\fbox{$\Ixed{\kappa}$} \\
\begin{align*}
\vspace{5em}
\Ixed{\TypeK} &= \TypeK \\
\Ixed{\LabK} &= \top \\
\Ixed{\kappa_1 \to \kappa_2} &= \forall (\alpha : \Ixed{\kappa_1}). \Ixed{\kappa_2} \\
\Ixed{\RowK \kappa} &= \exists(n : \Nat). \forall (j : \Ix  n). \Ixed{\kappa} \\
\end{align*}
\end{gather*}
\begin{gather*}
\fbox{$\Ixed{\KindJ \Gamma \tau \kappa}$} \\
\begin{align*}
\vspace{5em}
&\fbox{(When $\kappa$ not row-kinded.)} \\
\Ixed{\alpha} &= \alpha \\
\Ixed{\tau_1 \to \tau_2} &= \forall (\alpha : \Ixed{\tau_1}).\Ixed{\tau_2} \\
\Ixed{\forall \alpha \co \kappa. \tau} &= \forall (\alpha : \Ixed{\kappa}).\Ixed{\tau} \\
\Ixed{\lambda \alpha \co \kappa. \tau} &= \forall (\alpha : \Ixed{\kappa}).\Ixed{\tau} \\
\Ixed{\pi \then \tau} &= \forall (\alpha : \Ixed{\pi}). \Ixed{\tau} \\
\Ixed{\tau \, \upsilon} &= \Ixed{\tau} \, \Ixed{\upsilon} \\
\Ixed{\ell} &= \top  \\
\Ixed{\Sing \xi} &= \top  \\
\Ixed{\LabTy \xi \tau}&= \Ixed{\tau}  \\
\Ixed{\Pi \rho}&=  \forall(i : \Ix{(\Fst \, \Ixed{\rho})}). (\Snd \, \Ixed{\rho}) \, i\\
\Ixed{\Sigma \rho}&= \exists (i : \Ix{(\Fst \, \Ixed{\rho})}). (\Snd \, \Ixed{\rho}) \, i\\
&\fbox{(When $\kappa$ row-kinded.)} \\
\Ixed{\rho \, \Lift{\upsilon}} &= (\Fst \, \Ixed{\rho} : \Nat, \lambda (j : \Ix (\Fst \, \Ixed{\rho})). (\Snd \, \Ixed{\rho}) \Ixed{\upsilon})\\
\Ixed{\Lift{\tau} \, \rho} &= (\Fst \, \Ixed{\rho} : \Nat, \lambda (j : \Ix (\Fst \, \Ixed{\rho})). \Ixed{\tau} \, (\Snd \, \Ixed{\rho}))\\
\Ixed{\LabRow \xi \tau}&= (1, \, \Felim{\Ixed{\tau}} )  \\
\end{align*}
\end{gather*}

\begin{align*}
\fbox{$\Ixed{\Gamma \vdash \pi : \kappa}$} \\
\vspace{5em}
...
\end{align*}
\caption{A compositional translation of typed \RO kinds and predicates to untyped \IX{} terms}
\label{fig:translation}
\end{figure}

\begin{figure}[H]
\begin{align*}
\fbox{$\Ixed{\Gamma \Vdash \pi}$} \\
\vspace{5em}
...
\end{align*} \\
\begin{align*}
\fbox{$\Ixed{\TypeJ \Gamma M \tau}$} \\
\vspace{5em}
...
\end{align*}
\caption{Translating predicates and terms}
\label{fig:translation}
\end{figure}

\subsection{Typed translation}

\begin{figure}[H]
\small
\begin{gather*}
\fbox{$\Gamma \vdash \tau \leadsto \upsilon : \kappa$}
\\
\ib{\irule[\crule{foo}]{A};{B}} \\
\fbox{$\Gamma \vdash M \leadsto N : \tau$}
\\
\ib{\irule[\crule{foo}]{A};{B}} \\
\fbox{${\EntJ \Gamma \pi} \leadsto N$}
\\
\ib{\irule[\crule{foo}]{A};{B}}  \\
\fbox{${\tau \equiv \upsilon} \leadsto P$}
\\
\ib{\irule[\crule{foo}]{A};{B}} 
\end{gather*}
\caption{Translation of \RO derivations to \IX{} derivations}
\end{figure}

\subsection{Properties of Translation}

Presume an \RO instantiation of the simple row theory. A lot of this is likely bullshit.

\begin{theorem}[Translational Soundness (Types)]
  if $\TypeJ \Gamma \tau \kappa$ such that $\Gamma \vdash \tau \leadsto \upsilon \co \kappa$ then $\SortJ {\Ixed{\Gamma}} \upsilon {\Ixed{\kappa}}$.
\end{theorem}

\begin{theorem}[Translational Soundness (Type Equivalence)]
  if
  \begin{enumerate}
  \item $\Gamma \vdash \tau_{1} \leadsto \upsilon_{1} \co \kappa_{1}$;
  \item $\Gamma \vdash \tau_{2} \leadsto \upsilon_{2} \co \kappa_{2}$; and
  \item $\tau_{1} \equiv \tau_{2} \leadsto P$,
  \end{enumerate}
 then $\Ixed{\Gamma} \vdash P : \upsilon_{1} \equiv \upsilon_{2}$.
\end{theorem}

\begin{theorem}[Translational Soundness (Of Predicates)]
  if $\Gamma \Vdash \pi$ such that $\Gamma \Vdash \pi \leadsto N$ then $\Ixed{\Gamma} \vdash N : \Ixed{\pi}$.
\end{theorem}

Finally,

\begin{theorem}[Translational Soundness]
  if $\TypeJ \Gamma M \tau$ such that $\Gamma \vdash M \leadsto N \co \tau$ then $\SortJ {\Ixed{\Gamma}} N {\Ixed{\tau}}$.
\end{theorem}


\section{Operational semantics}


\bibliographystyle{ACM-Reference-Format}
\bibliography{MIx}
\end{document}

