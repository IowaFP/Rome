\documentclass[authoryear,acmsmall,screen]{acmart}
\citestyle{acmauthoryear}

\overfullrule=1mm

\usepackage{
  % AH> I don't know how much of these are used, and for what.
  %     (needs untangling.) 
  relsize,
  enumitem,
  xspace,
  mathtools,
  multicol,
  tikz-cd,
  parskip,
  mathrsfs,
  stmaryrd,
  tikz,
  float,
  titlecaps,
  soul,
  upgreek,
  caption,
  graphicx,
  array,
  subcaption,
  % amsmath,
  % amsthm,
  % amssymb,
  bibentry,
  bibunits,
  ./sty/mathwidth,
%  ../sty/sectsty,
  ./sty/commands,
  ./sty/infer,
  ./sty/commands,
  ./sty/higher,
  ./sty/mymath
}

\usepackage{natbib}

% tikz
\usepackage{tikz}
\usepackage{tikz-cd}

\title{Recursive Rows in Rome}

\author{AH \& JGM}

\newcommand\Todo[1]{{\color{red} #1}}
\newcommand\Absurd{\ensuremath{\lambdabar\mathrm{\Tt{()}}}}
\newcommand\SortJ[3]{\TypeJ {#1} {#2} {#3}}
\newcommand\IX{\textsc{Ix}}
\newcommand\Hix{\textsc{HIx}}
\newcommand\secfig[2]{Figure \ref{fig:#2}, \S\ref{sec:#1}}
\newcommand\Nat{\mathbb{N}}
\newcommand\Zero{Z}
\newcommand\FZero{\mathsf{I_0}}
\newcommand\Suc{\mathrm{S}}
\newcommand\FSuc{\mathsf{I_{\Suc}}}
\newcommand\Fin{\mathrm{Fin}}
\newcommand\Ix[1]{\mathrm{Ix} \, #1}
\newcommand\MuIx{\ensuremath{\mu}Ix}
\newcommand\Type{\mathrm{Type}}
\newcommand\FormJ[2]{\ensuremath{#1 \vdash #2 \, \Type}}
\renewcommand\tt{\Tt{tt}}
% \newcommand\Ixed[1]{\ensuremath{(#1)^{\bullet}}}
\newcommand\Ixed[1]{\ensuremath{\Sem{#1}}}
\newcommand\TyPair[3]{\ensuremath{\langle\!\langle #1 \co #2 , #3 \rangle\!\rangle}}

\newcommand\Lift[1]{\ensuremath{\lceil #1 \rceil}}
\newcommand\Fst{\mathrm{fst}}
\newcommand\Snd{\mathrm{snd}}
\newcommand\Pointed[1]{\ensuremath{#1_{\bot}}}
\newcommand\PointedT{\Pointed{\star}}
\newcommand\PointedU{\Pointed{\Box}}
\newcommand\J[4]{\mathcal{J} \, #1 \, #2 \, #3 \, #4}
\newcommand\Refl{\mathrm{refl}}
\renewcommand\left{\mathrm{left}}
\renewcommand\right{\mathrm{right}}
\renewcommand\Case{\mathrm{case}}
%\newcommand\CaseN[4]{\ensuremath{\Case_{\mathbb{N}} \, #1 \, \mathrm{of} \{ \Zero \mapsto #2; \Suc\, #3 \mapsto #4 \}}}
% \newcommand\CaseF[4]{\ensuremath{\Case_{\mathrm{Fin}} \, #1 \, \mathrm{of} \{ \FZero \mapsto #2; \FSuc\, #3 \mapsto #4 \}}}
% \newcommand\CaseP[3]{\ensuremath{\Case_{\mathrm{\exists}} \, #1 \, \mathrm{of} \{ (#1, #2) \mapsto #3 \} }}
% \newcommand\CaseS[5]{\ensuremath{\Case_{\mathrm{+}} \, #1 \, \mathrm{of} \, \{ \left \, #2 \mapsto #3 ; \right \, #4 \mapsto #5 \} }}
\newcommand\CaseN[3]{\ensuremath{\Case_{\Nat} \, #1 \, #2 \, #3}}
\newcommand\CaseIx[3]{\ensuremath{\Case_{\mathrm{\IX{}}} \, #1 \, #2 \, #3 }}
\newcommand\CaseP[2]{\ensuremath{\Case_{\mathrm{\exists}} \, #1 \, #2 }}
\newcommand\CaseS[3]{\ensuremath{\Case_{\mathrm{+}} \, #1 \, #2 \, #3}}
\newcommand\Rule[1]{(\textsc{#1})}
\newcommand\Safe[1]{\ensuremath{#1 \; \mathrm{Safe}}}
\newcommand\SafeJ[2]{\ensuremath{#1 \vdash #2 \; \mathrm{Safe}}}
\newcommand\Felim[1]{\{\!\!\{#1\}\!\!\}}

\newcommand\New[1]{{\color{blue}#1}}

\begin{document}

\maketitle

\section{\IX: The Index Calculus}

\subsection{Syntax}

\begin{figure}[H]
\begin{smalle}
\begin{gather*}
\begin{array}{r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l}
%  \text{Term variables} & x \; \alpha % & \text{sort variables} & \alpha %% & & \text{Labels} & \ell & \text{Directions} & d \in \Set {\Left, \Right}
\end{array}
\\[5px]
\begin{doublesyntaxarray}
  \mcl{\text{Sorts}} & \sigma & ::= & \star \mid \Box \\
  \mcl{\text{Terms}} & M, N, T & ::= & \star \mid x \mid \\
  & & & & \Nat \mid \Zero \mid \Suc \, M \mid \\
  & & & & \CaseN M N T \mid \\
  & & & & \Ix{M} \mid \FZero \mid \FSuc \; M \mid \\
  & & & & \CaseIx M N T \mid \Felim {M_1,...,M_n} \mid \Absurd \mid \\
  & & & &  \top \mid \tt \mid \\
  & & & &  \forall \alpha \co T. N \mid \lambda x \co T. N \mid M \, N \mid \\
  & & & &  \exists \alpha \co T. M \mid \TyPair \alpha T M \mid \CaseP M N \mid \\
  & & & &  M + N \mid \left\, M \mid \right\, M \mid \\
  & & & & \CaseS M N T \mid \\
  & & & &  M \equiv N \mid \Refl \, T \, M \, N \mid \\
  \mcl{\text{Environments}} & \Gamma & ::= & \varepsilon \mid \Gamma, \alpha : T
\end{doublesyntaxarray}
\end{gather*}
\end{smalle}
\caption{Syntax}
\label{fig:syntax}
\end{figure}

\subsubsection{Meta-syntax \& syntactic sugar}

Let
\begin{enumerate}
\item $\tau \to \upsilon$ denote the non-dependent universal quantification $\forall (\_ : \tau). \upsilon$;
\item $\tau \times \upsilon$ denote the non-dependent existential quantification $\exists (\_ : \tau). \upsilon$;
\item $0,1,2,...$ denote object-level natural numbers in the intuitive fashion; \item $i_{n}$ denote the index obtained by $n$ applications of $\FSuc$ to $\FZero$; and
\item the syntax 

\[
\Felim {M_1,...,M_n}
\]

denote the large elimination of a known, finite quantity of indices to types $M_{1},...,M_{n}$, elaborated by the equations:

\begin{align*}
  \Felim{M_{1}} &:= \lambda (i : \Ix{1}). \CaseIx i M_{1} \Absurd \\
  \Felim{M_{1},...,M_{n}} &:= \lambda (i : \Ix{n}). \CaseIx i {M_{1}} \Felim{M_{2},...,M_{n}}
\end{align*}
\end{enumerate}



\subsection{Typing}

\begin{figure}[H]
\small
\begin{gather*}
\fbox{$\EnvJ \Gamma$}
\\
\ib{\irule[\Rule{emp}]{ };{\EnvJ \varepsilon}}
\rsp
\ib{\irule[\Rule{var}]
          {\EnvJ \Gamma}
          {\SortJ \Gamma M \sigma};
          {\EnvJ {\Gamma, x : M}}}
\end{gather*}

\begin{gather*}
\fbox{$\TypeJ \Gamma M \sigma$} 
\\
\ib{\irule[\Rule{$\star$}] {\EnvJ \Gamma} ; {\TypeJ \Gamma \star \Box}} 
\rsp
\ib{\irule[\Rule{$\top$}] {\EnvJ \Gamma} ; {\SortJ \Gamma \top \sigma}}
\rsp
\ib{\irule[\Rule{Nat}] {\EnvJ \Gamma} ; {\SortJ \Gamma \Nat \star}}
\rsp
\ib{\irule[\Rule{Ix}] {\SortJ \Gamma n \Nat} ; {\SortJ \Gamma {\Ix n} \star}} \\
\ib{\irule[\Rule{$\forall$}]{\SortJ \Gamma M \sigma_1} {\SortJ {\Gamma, \alpha \co M}{N}{\sigma_2}};{\SortJ \Gamma {\forall \alpha \co M. N} \sigma_2}}
\rsp
\ib{\irule[\Rule{$\exists$}]{\SortJ \Gamma M \sigma_1} {\SortJ {\Gamma, \alpha \co M}{N}{\sigma_2}};{\SortJ \Gamma {\exists \alpha \co M. N} \sigma_2}} \\
\ib{\irule[\Rule{$+$}]{\SortJ \Gamma M \sigma}{\SortJ \Gamma N \sigma};{\SortJ \Gamma {M + N} {\sigma}}}
\rsp
\ib{
  \irule[\Rule{$\equiv$}]
  {\SortJ \Gamma {M} {\sigma}}
  {\SortJ \Gamma {N} {\sigma}};
  {\SortJ \Gamma {{M} \equiv {N}} {\sigma}}}
\end{gather*}
\caption{Context and type well-formedness}
\label{fig:formation}
\end{figure}

\begin{figure}[H]
\small
\begin{gather*}
\fbox{$\TypeJ \Gamma M N$} \\
\ib{\irule[\Rule{Var}] {\EnvJ \Gamma}{x \co M \in \Gamma} ; {\TypeJ \Gamma x M}} 
\rsp
\ib{\irule[\Rule{$\tt$}]{\EnvJ \Gamma};{\TypeJ \Gamma {\tt} \top}} 
\\
\ib{\irule[\Rule{$\Zero$}]{\EnvJ \Gamma};{\TypeJ \Gamma \Zero \Nat}} 
\rsp
\ib{\irule[\Rule{$\Suc{}$}]{\TypeJ \Gamma n \Nat};{\TypeJ \Gamma {\Suc \, n} \Nat}} 
\rsp
\ib{\irule[\Rule{$\E\Nat$}]
  {\TypeJ \Gamma A \sigma}
  {\TypeJ \Gamma M \Nat}
  {\TypeJ \Gamma N {A}}
  {\TypeJ \Gamma P {\Nat \to A}};
  {\TypeJ \Gamma {\CaseN M N P} A}}
\\
\ib{\irule[\Rule{$\FZero$}]{{\TypeJ \Gamma n \Nat}};{\TypeJ \Gamma \FZero {\Ix (\Suc \, n)}}} 
\rsp
\ib{\irule[\Rule{$\FSuc{}$}]{\TypeJ \Gamma n \Nat}{\TypeJ \Gamma i {\Ix n}};{\TypeJ \Gamma {\FSuc \, i} {\Ix {(\Suc \, n)}}}} 
\rsp
\ib{\irule[\Rule{$\Absurd$}]{\TypeJ \Gamma A \sigma};{\TypeJ \Gamma \Absurd {\Ix 0 \to A}}}
\\
\ib{\irule[\Rule{$\E\FSuc{}$}]
  {\TypeJ \Gamma A \sigma}
  {\TypeJ \Gamma M {\Ix {(\Suc \, n)}}}
  {\TypeJ \Gamma N A}
  {\TypeJ \Gamma P {\Ix n \to A}};
  {\TypeJ \Gamma {\CaseIx M N P} A}}
\\
\ib{\irule[\Rule{$\I\forall$}]
  {\SortJ \Gamma T \sigma}
  {\TypeJ {\Gamma , x \co T} {M} {N}};
  {\TypeJ \Gamma {\lambda x \co T. M} {\forall (x \co T). N}}}
\rsp
\ib{\irule[\Rule{$\E\forall$}]
    {\TypeJ \Gamma M {\forall(x \co T_1). T_2}} {\TypeJ \Gamma N {T_1}};
    {\TypeJ \Gamma {M \, N} T_2[N/x]}}
\\
 \ib{\irule[\Rule{$\I\exists$}]
      {\TypeJ {\Gamma}{T_{1}}{\sigma}}
      {\TypeJ {\Gamma}{M}{T_1}}
      {\TypeJ {\Gamma} {N} {T_2[M/x]}};
      {\TypeJ \Gamma {\TyPair M {T_1} N} {\exists (x \co T_1). T_2}}}
\\
 \ib{\irule [\Rule{$\E\exists$}]
     {\TypeJ \Gamma A \sigma}
     {\TypeJ \Gamma M {\exists (x \co T_1). T_2}}
     {\TypeJ \Gamma N {\forall (x : T_{1}). T_{2} \to A}};
     {\TypeJ \Gamma {\CaseP M N} {A}}}
\\
\ib{\irule[\Rule{$\I{+_{1}}$}]{\TypeJ \Gamma M A};{\TypeJ \Gamma {\left \, M} {A + B}}}
\rsp
\ib{\irule[\Rule{$\I{+_{2}}$}]{\TypeJ \Gamma N B};{\TypeJ \Gamma {\right \, N} {A + B}}}
\\
\ib{\irule[\Rule{$\E+$}]
  {\SortJ \Gamma C \sigma}
  {\TypeJ \Gamma M {A + B}}
  {\TypeJ \Gamma N {A \to C}}
  {\TypeJ \Gamma P {B \to C}};
  {\TypeJ \Gamma {\CaseS M N P} C}}
\\
\ib{
  \irule [\Rule{$\I\equiv$}]
  {\TypeJ \Gamma M \sigma};
  {\TypeJ \Gamma {\Refl} {M \equiv M}}}
\rsp
\ib{
  \irule [\Rule{conv}]
  {\TypeJ \Gamma M T_1}
  {\TypeJ \Gamma {T_1 = T_2} {\sigma}};
  {\TypeJ \Gamma M T_2}}
\\
\ib{
  \irule [\Rule{$\E\equiv$}]
      {\mathlarger{\mathlarger{\mathlarger{\substack{ 
        {\TypeJ \Gamma {P} {T_1 \equiv T_2}} \\
        {\Gamma \vdash M : T_1} \\
        {\Gamma \vdash N : T_1} \\
        {\TypeJ {\Gamma, x \co T_1, y \co T_1, p \co x \equiv y} {T} {\star}} \\
        {\TypeJ {\Gamma , z \co T_1} H {T[z/x, z/y, \Refl/p]} }}}}}}
  ;
  {\TypeJ \Gamma {\J H M N P} {T[M/x,N/y,P/p]}}}
\end{gather*}
\caption{Typing \IX{} terms}
\label{fig:IxRules}
\end{figure}

\begin{figure}[H]
\small
\begin{gather*}
\fbox{$\TypeJ \Gamma {M = N} \sigma$} \\
\ib{
  \irule[\erule{refl}]
  {\TypeJ \Gamma M \sigma} 
  ;
  {\TypeJ \Gamma {M = M} \sigma}}
\rsp
\ib{
  \irule[\erule{sym}]
  {\TypeJ \Gamma {N = M} \sigma} 
  ;
  {\TypeJ \Gamma {M = N} \sigma}}
\rsp
\ib{
  \irule[\erule{trans}]
  {\TypeJ \Gamma {M = P} \sigma} {{\TypeJ \Gamma {P = N} \sigma}}
  ;
  {\TypeJ \Gamma {M = N} \sigma}}
\end{gather*}
\begin{gather*}
\fbox{$\TypeJ \Gamma {M = N} T$} \\
\ib{
  \irule[\crule{refl}]
  {\TypeJ \Gamma M T} 
  ;
  {\TypeJ \Gamma {M = M} T}}
\rsp
\ib{
  \irule[\crule{sym}]
  {\TypeJ \Gamma {N = M} T} 
  ;
  {\TypeJ \Gamma {M = N} T}}
\rsp
\ib{
  \irule[\crule{trans}]
  {\TypeJ \Gamma {M = P} T} {{\TypeJ \Gamma {P = N} T}}
  ;
  {\TypeJ \Gamma {M = N} T}}
\end{gather*}
\caption{Definitional equality \& computational laws}
\label{fig:IxDefnEq}
\end{figure}

\subsection{Properties}

\begin{theorem}[Well-sortedness]
  if $\TypeJ \Gamma M N$ then $\EnvJ \Gamma$ and there exists $\sigma$ such that $\SortJ \Gamma N \sigma$.
\end{theorem}






\subsection{Elaborating \IX{} to the CoC + \Tt{Fin}}
Following the above, I believe \IX{} to a smaller calculus with the syntax below. This is effectively the calculus of constructions with primitive naturals and finite indices.

\begin{figure}[H]
\begin{smalle}
\begin{gather*}
\begin{array}{r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l}
%  \text{Term variables} & x \; \alpha % & \text{sort variables} & \alpha %% & & \text{Labels} & \ell & \text{Directions} & d \in \Set {\Left, \Right}
\end{array}
\\[5px]
\begin{doublesyntaxarray}
  \mcl{\text{Sorts}} & \sigma & ::= & \star \mid \Box \\
  \mcl{\text{Terms}} & M, N, T & ::= & \star \mid x \mid \\
  & & & & \Nat \mid \Zero \mid \Suc \, M \mid \\
  & & & & \CaseN M N T \mid \\
  & & & & \Ix{M} \mid \FZero \mid \FSuc \; M \mid \\
  & & & & \CaseIx M N T \mid \\
  & & & &  \forall \alpha \co T. N \mid \lambda x \co T. N \mid M \, N \mid \\
  & & & &  M \equiv N \mid \Refl \, T \, M \, N \mid \\
  \mcl{\text{Environments}} & \Gamma & ::= & \varepsilon \mid \Gamma, \alpha : T
\end{doublesyntaxarray}
\end{gather*}
\end{smalle}
\caption{Syntax}
\label{fig:syntax}
\end{figure}

Elaboration is given below. One would also expect a rule for bot elimination---or you could simply encode $\Ix 0$ as $\forall X \co \star. X$.


\begin{align*}
  \top &\leadsto \Ix 1 \\
  \tt &\leadsto  \FZero \\
  \bot &\leadsto \Ix 0 \\
  A \to B &\leadsto \forall (x : A). B \\
  \exists(x : A). B &\leadsto \forall (C : \Box).(\forall (x : A). B \to C) \to C \\
  \TyPair M T N &\leadsto \lambda (C : \Box). \lambda (f : (\forall (x : A). B \to C)). f \, M \, N \\
  A + B &\leadsto \exists (i : \Ix 2). \Felim {A,B} \, i \\
  \left\, M &\ \TyPair {i_0} {\Ix 2} {M} \\
  \right\, N &\ \TyPair {i_1} {\Ix 2} {N} \\
  A \times B &\leadsto \exists (x : A). B
\end{align*}

One could also translate naturals away using your favorite functional encoding. (I imagine there are encodings for \Tt{Fin}, too.)

\section{Translation From \RO}

\subsection{Untyped Translation}

We follow the approach of \cite{MorrisM19} and give both typed and untyped translations of \RO types. \cref{fig:translation} describe the untyped translation, which is used to show translational soundness of the typed translation (\cref{fig:translation}).


\begin{figure}[H]
\begin{gather*}
\fbox{$\Ixed{\kappa}$} \\
\begin{align*}
\vspace{5em}
\Ixed{\TypeK} &= \TypeK \\
\Ixed{\LabK} &= \top \\
\Ixed{\kappa_1 \to \kappa_2} &= \Ixed{\kappa_1} \to \Ixed{\kappa_2} \\
\Ixed{\RowK \kappa} &= \exists(n : \Nat). \Ix  n \to \Ixed{\kappa} \\
\end{align*}
\end{gather*}
\begin{gather*}
\fbox{$\Ixed{\KindJ \Delta \tau \kappa}$} \\
\begin{align*}
\vspace{5em}
\Ixed{\TypeJ \Delta \alpha \kappa} &= \alpha \\
\Ixed{\TypeJ \Delta {\tau_1 \to \tau_2} \star} &= \Ixed{\tau_1} \to \Ixed{\tau_2} \\
\Ixed{\TypeJ \Delta {\forall \alpha \co \kappa. \tau} \star} &= \forall (\alpha : \Ixed{\kappa}).\Ixed{\tau} \\
\Ixed{\TypeJ \Delta {\lambda \alpha \co \kappa. \tau} {\kappa \to \kappa'}} &= \forall (\alpha : \Ixed{\kappa}).\Ixed{\tau} \\
\Ixed{\TypeJ \Delta {\pi \then \tau} \kappa} &= \Ixed{\pi} \to \Ixed{\tau} \\
\Ixed{\TypeJ \Delta {\tau \, \upsilon} \kappa} &= \Ixed{\tau} \, \Ixed{\upsilon} \\
\Ixed{\TypeJ \Delta \ell {\LabK}} &= \top  \\
\Ixed{\TypeJ \Delta {\Sing \xi} \star} &= \top  \\
\Ixed{\TypeJ \Delta {(\LabTy \xi \tau)} \kappa}&= \Ixed{\tau}  \\
\Ixed{\TypeJ \Delta {\Pi \rho} \star}&= \CaseP {\Ixed{\rho}} {(\lambda n : \Nat. \lambda P : \Ix{n} \to \star. \forall (i : \Ix{n}). P \, i)}\\
\Ixed{\TypeJ \Delta {\Sigma \rho} \star}&= \CaseP {\Ixed{\rho}} {(\lambda n : \Nat. \lambda P : \Ix{n} \to \star. \exists (i : {\Ix n}). P \, i)}\\
\Ixed{\TypeJ \Delta \epsilon {\RowK \kappa}} &= \TyPair 0 \Nat \Absurd \\
\Ixed{\TypeJ \Delta {\rho \, \Lift{\upsilon}} {\RowK {\kappa_{2}}}} &= \CaseP {\Ixed \rho} {(\lambda n : \Nat. \lambda (P : \Ix n \to \Sem{\kappa_{1}} \to \Sem{\kappa_{2}}).  \TyPair {n} {\Nat} {\lambda (j : \Ix n). (P \, j) \Sem{\tau} })} \\
\Ixed{\TypeJ \Delta {\Lift{\tau} \, \rho} {\RowK {\kappa_{2}}}} &= \CaseP {\Ixed \rho} {(\lambda n : \Nat. \lambda (P : \Ix n \to \Sem{\kappa_{1}}).  \TyPair {n} {\Nat} {\lambda (j : \Ix n). \Sem{\tau} (P \, j) })} \\
\Ixed{\TypeJ \Delta {(\LabRow \xi \tau)} {\RowK \kappa}}&= \TyPair {1} {\Nat} {\Felim{\Sem{\tau}}}
\end{align*}
\end{gather*}
\caption{Translating kinding derivations to untyped \IX{} terms}
\label{fig:translation}
\end{figure}

\begin{figure}[H]
\begin{align*}
\fbox{$\Ixed{\Delta \vdash \pi : \kappa}$} \\
\vspace{5em}
\Ixed{\TypeJ \Delta {\Leqp {\rho_{1}} {\rho_{2}}} \kappa} &=
  \begin{aligned}
              &\Case\, {\Ixed{\rho_{1}}} (\lambda n : \Nat. \lambda (P : \Ix n \to \Ixed{\kappa}).  \\
              &\Case\, {\Ixed{\rho_{2}}} (\lambda m : \Nat. \lambda (Q : \Ix m \to \Ixed{\kappa}). \\                               
              &\forall (i : \Ix n). \exists (j : \Ix m). P \, i \equiv Q \, j))
  \end{aligned} \\ \\
\Ixed{\TypeJ \Delta {\RowPlusP {\rho_{1}} {\rho_{2}} {\rho_{3}}} \kappa} &= 
  \begin{aligned}                                           
              &\Case\, {\Ixed{\rho_{1}}} (\lambda n : \Nat. \lambda (P : \Ix n \to \Ixed{\kappa}).  \\
              &\Case\, {\Ixed{\rho_{2}}} (\lambda m : \Nat. \lambda (Q : \Ix m \to \Ixed{\kappa}). \\                               
              &\Case\, {\Ixed{\rho_{3}}} (\lambda l : \Nat. \lambda (R : \Ix l \to \Ixed{\kappa}). \\                               
              &(\forall (i : \Ix n). \exists (k : \Ix l). P \, i \equiv R \, k) \\ 
              \times \, &(\forall (j : \Ix m). \exists (k : \Ix l). Q \, j \equiv R \, k) \\
              \times \, &(\forall (k : \Ix l). \\
                &(\exists (i : \Ix n). P \, i \equiv R\, k) \\
                +\, &(\exists (j : \Ix m). Q \, j \equiv R\, k)))))
  \end{aligned}                                           
\end{align*}
\caption{Translating predicate well-formedness judgments}
\label{fig:translation}
\end{figure}

\subsection{Typed translation}
\newcommand\Fresh{\mathrm{fresh}}
\newcommand\TransEnv[2]{\ensuremath{\vdash #1 \leadsto #2}}
\newcommand\TransTerm[4]{\ensuremath{#1 \vdash #2 \leadsto #3 : #4}}
\newcommand\TransEnt[3]{\ensuremath{\EntJ #1 #2 \leadsto #3}}
\newcommand\TransEq[3]{\ensuremath{{#1 \equiv #2} \leadsto #3}}

There is some subtlety in mechanizing environments. Environments in $\RO$ store kinds, \emph{typing derivations}, and \emph{predicate well-formedness derivations}. If we are to simply translate derivations to untyped syntax, we are losing a bit of information. I am not sure, however, it is possible to translate derivations (in $\RO$) to derivations (in $\IX$) without a de facto type checker for $\IX$. I think we will have to perform the former: let derivations in $\RO$ environments translate to untyped types and sorts in $\IX$ environments. Then, argue as metatheory that $\TransEnv \Delta \Gamma$ implies $\EnvJ \Gamma$.

\begin{figure}[H]
\small
\begin{gather*}
\fbox{$\TransEnv \Delta \Gamma$} \\
\ib{
  \irule[\crule{$\varepsilon$}]
  {};
  {\TransEnv \epsilon \epsilon}}
\rsp
\ib{
  \irule[\crule{tvar}]
  {\TransEnv \Delta \Gamma};
  {\TransEnv {\Delta, \alpha : \kappa} {\Gamma, \alpha : \Ixed{\kappa}}}}
\\
\ib{
  \irule[\crule{var}]
  {\TransEnv \Delta \Gamma};
  {\TransEnv {\Delta, x : \tau} {\Gamma, x : \Ixed{\tau}}}}
\rsp
\ib{
  \irule[\crule{pred}]
  {\TransEnv \Delta \Gamma};
  {\TransEnv {\Delta, \pi : \kappa} {\Gamma, p : \Ixed{\pi}}}!{p \, \Fresh}}
\\ \\
\fbox{$\TransTerm \Delta M N \tau$}
\\
\ib{
  \irule[\trule{var}]
  {x : \tau \in \Delta};
  {\TransTerm \Delta x x \tau}}
\\
\ib{
  \irule[\trule{$\I\to$}]
  {\TransTerm {\Delta, x: \tau} M N \upsilon};
  {\TransTerm \Delta {\lambda x : \tau. M} {\lambda x : \Ixed{\tau}. N} {\tau \to \upsilon}}}
\rsp
\ib{
  \irule[\trule{$\I\to$}]
  {\TransTerm {\Delta} M F {\tau \to \upsilon}} {\TransTerm {\Delta} N E {\tau}};
  {\TransTerm \Delta {M \, N} {F \, E} {\upsilon}}}
\\
\ib{
  \irule[\trule{$\I\then$}]
  {\TransTerm {\Delta, \pi} {M} {N} {\tau}};
  {\TransTerm \Delta {M} {\lambda (p : \Ixed{\pi}). N} {\pi \then \tau}}}
\rsp
\ib{
  \irule[\trule{$\E\then$}]
  {\TransTerm \Delta M F {\pi \then \tau}}{\TransEnt \Delta \pi E};
  {\TransTerm \Delta M {F \, E} \tau}}
\\
\ib{
  \irule[\trule{$\I\forall$}]
  {\TransTerm \Delta {M} {N} \tau};
  {\TransTerm \Delta {\Lambda \alpha : \kappa. M} {\lambda (\alpha : \Ixed{\kappa}). N} {\forall \alpha : \kappa. \tau}}}
\rsp
\ib{
  \irule[\trule{$\E\forall$}]
  {\TransTerm \Delta M {N} {\forall \alpha : \kappa. \tau}};
  {\TransTerm \Delta {M [\upsilon]} {N \, \Ixed{\upsilon}} {\tau[\upsilon/\alpha]}}}
\\
\ib{
  \irule[\trule{sing}]
  {};
  {\TransTerm \Delta {\ell} {\tt} {\Sing \ell}}}
\rsp
\ib{
  \irule[\trule{\I\triangleright}]
  {\TransTerm \Delta {N} {E} {\tau}};
  {\TransTerm \Delta {\LabTy M N} {E} {\LabTy \ell \tau}}}
\ib{
  \irule[\trule{\E\triangleright}]
  {\TransTerm \Delta {M} {E} {\tau}}{\TransTerm \Delta {N} {\tt} {\Sing \ell}};
  {\TransTerm \Delta {\Unlabel M N} {E} {\LabTy \ell \tau}}}
\\
%% Row of Rules ----------------------------------------------------------------
\ib{
  \irule[\crule{foo}]
  {A};
  {B}}
\rsp
\ib{
  \irule[\crule{foo}]
  {A};
  {B}}
\rsp
\ib{
  \irule[\crule{foo}]
  {A};
  {B}}\\
%% End. ------------------------------------------------------------------------
\end{gather*}
\caption{Translation of \RO environments and typing derivations}
\end{figure}

\begin{figure}[H]
\small
\begin{gather*}
\ib{\irule[\crule{foo}]{A};{B}} \\
\fbox{$\TransEnt \Delta \pi N$}
\\
\ib{\irule[\crule{foo}]{A};{B}}  \\
\fbox{$\TransEq \tau \upsilon P$}
\\
\ib{\irule[\crule{foo}]{A};{B}} 
\end{gather*}
\caption{Translation of \RO derivations to \IX{} derivations}
\end{figure}

\subsection{Properties of Translation}

\begin{theorem}[Translational Soundness (Environments)]
  if $\TransEnv \Delta \Gamma$ then $\EnvJ \Gamma$.
\end{theorem}

\begin{theorem}[Translational Soundness (Types)]
  if $\TypeJ \Delta \tau \kappa$ and $\TransEnv \Delta \Gamma$ then $\SortJ \Gamma {\Ixed \tau} {\Ixed{\kappa}}$.
\end{theorem}

\begin{theorem}[Translational Soundness (Type Equivalence)]
  if
  \begin{enumerate}
  \item $\Gamma \vdash \tau_{1} \leadsto \upsilon_{1} \co \kappa_{1}$;
  \item $\Gamma \vdash \tau_{2} \leadsto \upsilon_{2} \co \kappa_{2}$; and
  \item $\tau_{1} \equiv \tau_{2} \leadsto P$,
  \end{enumerate}
 then $\Ixed{\Gamma} \vdash P : \upsilon_{1} \equiv \upsilon_{2}$.
\end{theorem}

\begin{theorem}[Translational Soundness (Predicates)]
  if $\Gamma \Vdash \pi$ such that $\Gamma \Vdash \pi \leadsto N$ then $\Ixed{\Gamma} \vdash N : \Ixed{\pi}$.
\end{theorem}

Finally,

\begin{theorem}[Translational Soundness]
  if $\TypeJ \Gamma M \tau$ such that $\Gamma \vdash M \leadsto N \co \tau$ then $\SortJ {\Ixed{\Gamma}} N {\Ixed{\tau}}$.
\end{theorem}


\section{Operational semantics}


\bibliographystyle{ACM-Reference-Format}
\bibliography{MIx}
\end{document}

