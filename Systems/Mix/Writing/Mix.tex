\documentclass[authoryear,acmsmall,screen]{acmart}
\citestyle{acmauthoryear}

\overfullrule=1mm

\usepackage{
  % AH> I don't know how much of these are used, and for what.
  %     (needs untangling.) 
  relsize,
  enumitem,
  xspace,
  mathtools,
  multicol,
  tikz-cd,
  parskip,
  mathrsfs,
  stmaryrd,
  tikz,
  float,
  titlecaps,
  soul,
  upgreek,
  caption,
  graphicx,
  array,
  subcaption,
  % amsmath,
  % amsthm,
  % amssymb,
  bibentry,
  bibunits,
  ./sty/mathwidth,
%  ../sty/sectsty,
  ./sty/commands,
  ./sty/infer,
  ./sty/commands,
  ./sty/higher,
  ./sty/mymath
}

\usepackage{natbib}

% tikz
\usepackage{tikz}
\usepackage{tikz-cd}

\title{Recursive Rows in Rome}

\author{AH \& JGM}

\newcommand\U{\mathcal{U}}
\newcommand\J[4]{\mathcal{J} \, #1 \, #2 \, #3 \, #4}
\newcommand\Refl{\mathrm{refl}}
\renewcommand\left{\mathrm{left}}
\renewcommand\right{\mathrm{right}}
\renewcommand\Case[3]{\mathrm{case} \; #1 \; #2 \; #3}
\newcommand\Rule[1]{(\textsc{#1})}
\begin{document}

\maketitle
\section{Introduction}
\subsection{The expression problem, in full}

\subsubsection{Seeking solutions sans encodings}

\subsection{Recursion and rows}

\subsubsection{Row type systems with term- or type-level $\mu$} There are none.
\subsubsection{Structural typing of objects in recursive record calculi}

\subsection{Challenges to practical extensibility}

\subsubsection{Polymorphic variants in OCaml}

\subsubsection{Inheritance is not subtyping}

\section{Rome: A row theoretic foundation for (co)inductive data types}



\section{\RO---higher ordered rows}
\label{app:RO}

Recursive types have a well known semantics as the least fixed-points of type-level operators. \RO is the only row calculus (to our knowledge) to include an (explicit) type-level $\lambda$ operator. Like with $F\omega$, this necessarily sacrifices desirable metatheoretic properties, such as principality of types; hence, like $F\omega$, $\RO$ may serve as a highly expressive intermediate or target language. Correspondingly, we perceive the addition of recursive terms and types to \RO to aid the adoption of recursion in surface languages.

We review the relevant syntax and typing of \RO now.

{\Todo{(Todo). It will be a challenge to trim this down, as \cite{HubersM23} does with \cite{MorrisM19}.}}

\subsection{Syntax}
\label{sec:ro-syntax}

The syntax of \RO [\Thy] is given in \cref{fig:syntax}.  

\begin{figure}[H]
\begin{smalle}
\begin{gather*}
\begin{array}{r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l}
  \text{Term variables} & x & \text{Type variables} & \alpha & \text{Labels} & \ell & \text{Directions} & d \in \Set {\Left, \Right}
\end{array}
\\[5px]
\begin{doublesyntaxarray}
  \mcl{\text{Kinds}} & \kappa & ::= & \TypeK \mid \LabK \mid \RowK \kappa \mid \kappa \to \kappa \\
  \mcl{\text{Predicates}} & \pi, \psi & ::= & \Leqp [d] \rho \rho \mid \RowPlusP \rho \rho \rho \\
  \text{Types} & \mcr{\phi, \tau, \upsilon, \rho, \xi} & ::= & \alpha \mid (\to) \mid \pi \then \tau \mid \forall \alpha\co\kappa. \tau \mid \lambda \alpha\co\kappa. \tau \mid \tau \, \tau \\
  & & & \mid & \ell \mid \Sing \xi \mid \LabTy \xi \tau \mid \Row {\tau_1, \dots, \tau_n} \mid \Pi \rho \mid \Sigma \rho \\
  \mcl{\text{Terms}} & H, M, N, P & ::= & x \mid \lambda x \co \tau. M \mid M \, N \mid \Lambda \alpha \co \kappa. M \mid \AppT M \tau \\
  & & & \mid & \ell \mid \LabTerm M M \mid \Unlabel M M \mid \Prj [d] M \mid M \Concat M \mid \Inj [d] M \mid M \Branch M \\
  & & & \mid & \Syn [\phi] \, M \mid \Ana [\phi]\, M \mid \FoldP \, M \, M \, M \, M \\
  \mcl{\text{Environments}} & \Gamma & ::= & \varepsilon \mid \Gamma, \alpha : \kappa \mid \Gamma, x : \tau \mid \Gamma, \pi
\end{doublesyntaxarray}
\end{gather*}
\end{smalle}
\caption{Syntax}
\label{fig:syntax}
\end{figure}

\subsection{Types and Kinds}
\label{sec:ro-types}
 
\cref{fig:kinding} gives rules for context formation ($\EnvJ \Gamma$), kinding ($\KindJ \Gamma \tau \kappa$), and predicate formation ($\PredJ \Gamma \pi$), parameterized by row theory $\Thy$.

\begin{figure}[H]
\small
\begin{gather*}
\fbox{$\EnvJ \Gamma$}
\\
\ib{\irule[\crule{emp}]{ };{\EnvJ \varepsilon}}
\rsp
\ib{\irule[\crule{tvar}]
          {\EnvJ \Gamma};
          {\EnvJ {\Gamma, \alpha : \kappa}}}
\rsp
\ib{\irule[\crule{var}]
          {\EnvJ \Gamma}
          {\KindJ \Gamma \tau \TypeK};
          {\EnvJ {\Gamma, x : \tau}}}
\rsp
\ib{\irule[\crule{pred}]
          {\EnvJ \Gamma}
          {\PredJ \Gamma \pi};
          {\EnvJ {\Gamma, \pi}}}
\end{gather*}
\begin{gather*}
\fbox{$\KindJ \Gamma \tau \kappa$} \; \fbox{$\PredJ \Gamma \pi$}
\\
\ib{\irule[\krule{var}]
          {\EnvJ \Gamma}
          {\alpha : \kappa \in \Gamma};
          {\Gamma \vdash \alpha : \kappa}}
\rsp
\ib{\irule[\krule{$(\to)$}]
          {\EnvJ \Gamma};
          {\KindJ \Gamma {(\to)} {\TypeK \to \TypeK \to \TypeK}}}
\rsp
\ib{\irule[\krule{$\then$}]
          {\PredJ \Gamma \pi}
          {\KindJ {\Gamma, \pi} \tau \TypeK};
          {\KindJ \Gamma {\pi \then \tau} \TypeK}}
\\
\ib{\irule[\krule{$\forall$}]
          {\KindJ {\Gamma, \alpha : \kappa} \tau \TypeK};
          {\KindJ \Gamma {\forall \alpha\co\kappa. \tau} \TypeK}}
\rsp
\ib{\irule[\krule{$\I\to$}]
          {\KindJ {\Gamma, \alpha : \kappa_1} \tau \kappa_2};
          {\KindJ \Gamma {\lambda \alpha \co \kappa_1. \tau} {\kappa_1 \to \kappa_2}}}
\rsp
\ib{\irule[\krule{$\E\to$}]
          {\KindJ \Gamma {\tau_1} {\kappa_1 \to \kappa_2}}
          {\KindJ \Gamma {\tau_2} {\kappa_1}};
          {\KindJ \Gamma {\tau_1 \, \tau_2} {\kappa_2}}}
\\
\ib{\irule[\krule{lab}]
          {\EnvJ \Gamma};
          {\KindJ \Gamma \ell \LabK}}
\rsp
\ib{\irule[\krule{sing}]
          {\KindJ \Gamma \xi \LabK};
          {\KindJ \Gamma {\Sing\xi} \TypeK}}
\rsp
\ib{\irule[\krule{lty}]
          {\KindJ \Gamma \xi \LabK}
          {\KindJ \Gamma \tau \kappa};
          {\KindJ \Gamma {\LabTy \xi \tau} \kappa}}
\rsp
\ib{\irule[\krule{row}]
          {\KindJS \Thy \Gamma {\Row {\overline {\LabTy \xi \tau}}} {\RowK \kappa}};
          {\KindJ \Gamma {\Row{\overline {\LabTy \xi \tau}}} {\RowK\kappa}}}
\\
\ib{\irule[\krule{$\Pi$}]
          {\KindJ \Gamma \rho {\RowK \kappa}};
          {\KindJ \Gamma {\Pi\rho} \kappa}}
\rsp
\ib{\irule[\krule{$\Sigma$}]
          {\KindJ \Gamma \rho {\RowK \kappa}};
          {\KindJ \Gamma {\Sigma\rho} \kappa}}
\rsp
\ib{\irule[\krule{lift$_1$}]
          {\KindJ \Gamma \rho {\RowK{\kappa_1 \to \kappa_2}}}
          {\KindJ \Gamma \tau {\kappa_1}};
          {\KindJ \Gamma {\rho\,\tau} {\RowK{\kappa_2}}}}
\\
\ib{\irule[\krule{lift$_2$}]
          {\KindJ \Gamma \phi {\kappa_1 \to \kappa_2}}
          {\KindJ \Gamma \rho {\RowK{\kappa_1}}};
          {\KindJ \Gamma {\phi\,\rho} {\RowK{\kappa_2}}}}
\rsp          
\ib{\irule[\krule{$\lesssim_{d}$}]
          {\KindJ \Gamma {\rho_i} {\RowK \kappa}};
          {\PredJ \Gamma {\Leqp [d] {\rho_1} {\rho_2}}}}
\rsp
\ib{\irule[\krule{$\odot$}]
          {\KindJ \Gamma {\rho_i} {\RowK \kappa}};
          {\PredJ \Gamma {\RowPlusP {\rho_1} {\rho_2} {\rho_3}}}}
\end{gather*}
\caption{Contexts and kinding.}
\label{fig:kinding}
\end{figure}

\begin{figure}[H]
\begin{gather*}
\fbox{$\EqvJ \tau \tau$} \; \fbox{$\EqvJ \pi \pi$}
\\
\ib{\irule[\erule{refl}]
          { };
          {\EqvJ \tau \tau}}
\rsp
\ib{\irule[\erule{sym}]
          {\EqvJ {\tau_1} {\tau_2}};
          {\EqvJ {\tau_2} {\tau_1}}}
\rsp
\ib{\irule[\erule{trans}]
          {\EqvJ {\tau_1} {\tau_2}}
          {\EqvJ {\tau_2} {\tau_3}};
          {\EqvJ {\tau_1} {\tau_3}}}
\rsp
\ib{\irule[\erule{$\beta$}]
          { };
          {\EqvJ {(\lambda \alpha\co\kappa. \tau)\,\upsilon} {\tau[\upsilon/\alpha]}}}
\\
\ib{\irule[\erulec {\then}]
          {\EqvJ {\pi_1} {\pi_2}}
          {\EqvJ {\tau_1} {\tau_2}};
          {\EqvJ {\pi_1 \then \tau_1} {\pi_2 \then \tau_2}}}
\rsp
\ib{\irule[\erulec{\forall}]
          {\EqvJ {\tau[\gamma/\alpha]} {\upsilon[\gamma/\beta]}};
          {\EqvJ {\forall\alpha\co\kappa.\tau} {\forall\beta\co\kappa.\upsilon}}!
          {\gamma\not\in fv(\tau, \upsilon)}}
\rsp
\ib{\irule[\erulec{\text{\textsc{app}}}]
          {\EqvJ {\tau_i} {\upsilon_i}};
          {\EqvJ {\tau_1\,\tau_2} {\upsilon_1\,\upsilon_2}}}
\\
\ib{\irule[\erulec{\triangleright}]
          {\EqvJ {\xi_1} {\xi_2}}
          {\EqvJ {\tau_1} {\tau_2}};
          {\EqvJ {\LabTy {\xi_1} {\tau_1}} {\LabTy {\xi_2} {\tau_2}}}}
\rsp
\ib{\irule[\erule{row}]
          {\EqvJS \Thy {\Row {\overline {\LabTy {\xi_i} {\tau_i}}}} {\Row {\overline {\LabTy {\xi'_j} {\tau'_j}}}}};
          {\EqvJ {\Row {\overline {\LabTy {\xi_i} {\tau_i}}}} {\Row {\overline {\LabTy {\xi'_j} {\tau'_j}}}}}}
\rsp
\ib{\irule[\erulec{\Sing\cdot}]
          {\EqvJ {\xi_1} {\xi_2}};
          {\EqvJ {\Sing{\xi_1}} {\Sing{\xi_2}}}}
\\
\ib{\irule[\erule{lift$_1$}]
          { };
          {\EqvJ {\Row{\LabTy \xi \phi } \, \tau} {\Row{\LabTy {\xi} {\phi\,\tau}}}}}
\rsp
\ib{\irule[\erule{lift$_2$}]
          { };
          {\EqvJ {\phi \, \Row{\LabTy {\xi} {\tau}}} {\Row{\LabTy {\xi} {\phi\,\tau}}}}}
\rsp
\\
\ib{\irule[\erulec{\Pi\Sigma}]
          {\EqvJ {\rho_1} {\rho_2}};
          {\EqvJ {K \rho_1} {K \rho_2}}}
\rsp
\ib{\irule[\erule{lift$_3$}]
          { };
          {\EqvJ {(K \rho) \, \tau} {K (\rho \, \tau)}}}
\rsp
\ib{\irule[\erule{sing}]
          { };
          {\EqvJ {K \Row{\LabTy \xi \tau}} {\LabTy \xi \tau}}}
\rsp
(K \in \Set {\Pi, \Sigma})
\\
\ib{\irule[\erulec{\lesssim_{d}}]
          {\EqvJ {\tau_i} {\upsilon_i}};
          {\EqvJ {\Leqp [d] {\tau_1} {\tau_2}} {\Leqp [d] {\upsilon_1} {\upsilon_2}}}}
\rsp
\ib{\irule[\erulec{\odot}]
          {\EqvJ {\tau_i} {\upsilon_i}};
          {\EqvJ {\RowPlusP {\tau_1} {\tau_2} {\tau_3}} {\RowPlusP {\upsilon_1} {\upsilon_2} {\upsilon_3}}}}
\end{gather*}
\caption{Type and predicate equivalence}
\label{fig:type-equiv}
\end{figure}


\subsection{Terms}
\label{sec:ro-terms}

\renewcommand\EntJ[2]{\EntJS \Thy #1 #2}
\begin{figure}[H]
\small  
\begin{gather*}
\fbox{$\TypeJ \Gamma M \tau$}
\\
\ib{\irule[\trule{var}]
          {\EnvJ \Gamma}
          {x : \tau \in \Gamma};
          {\TypeJ \Gamma x \tau}}
\rsp
\ib{\irule[\trule{$\I\to$}]
          {\KindJ \Gamma {\tau_1} {\TypeK}}
          {\TypeJ {\Gamma, x : \tau_1} M {\tau_2}};
          {\TypeJ \Gamma {\lambda x : \tau_1. M} {\tau_1 \to \tau_2}}}
\rsp          
\ib{\irule[\trule{$\E\to$}]
          {\TypeJ \Gamma {M_1} {\tau_1 \to \tau_2}}
          {\TypeJ \Gamma {M_2} {\tau_1}};
          {\TypeJ \Gamma {M_1 \, M_2} {\tau_2}}}
\\
\ib{\irule[\trule{$\equiv$}]
          {\TypeJ \Gamma M \tau}
          {\EqvJ \tau \upsilon};
          {\TypeJ \Gamma M \upsilon}}
\rsp
\ib{\irule[\trule{$\I\then$}]
          {\PredJ \Gamma \pi}
          {\TypeJ {\Gamma, \pi} M \tau};
          {\TypeJ \Gamma M {\pi \then \tau}}}
\rsp
\ib{\irule[\trule{$\E\then$}]
          {\TypeJ \Gamma M {\pi \then \tau}}
          {\EntJ \Gamma \pi};
          {\TypeJ \Gamma M \tau}}
\\
\ib{\irule[\trule{$\I\forall$}]
          {\TypeJ {\Gamma, \alpha : \kappa} M \tau};
          {\TypeJ \Gamma {\Lambda \alpha \co \kappa. M} {\forall \alpha\co\kappa. \tau}}}
\rsp
\ib{\irule[\trule{$\E\forall$}]
          {\TypeJ \Gamma M {\forall \alpha\co\kappa. \tau}}
          {\KindJ \Gamma \upsilon \kappa};
          {\TypeJ \Gamma {\AppT M \upsilon} {\tau[\upsilon/\alpha]}}}
\\
\ib{\irule[\trule{sing}]
          {\EnvJ \Gamma};
          {\TypeJ \Gamma \ell {\Sing \ell}}}
\rsp
\ib{\irule[\trule{$\I\triangleright$}]
          {\TypeJ \Gamma {M_1} {\Sing \ell}}
          {\TypeJ \Gamma {M_2} \tau};
          {\TypeJ \Gamma {\LabTerm {M_1} {M_2}} {\LabTy \ell \tau}}}
\rsp
\ib{\irule[\trule{$\E\triangleright$}]
          {\TypeJ \Gamma {M_1} {\LabTy \ell \tau}}
          {\TypeJ \Gamma {M_2} {\Sing \ell}};
          {\TypeJ \Gamma {\Unlabel {M_1} {M_2}} \tau}}
\\
\ib{\irule[\trule{$\E\Pi$}]
          {\TypeJ \Gamma M {\Pi \rho_1}}
          {\EntJ \Gamma {\Leqp [d] {\rho_2} {\rho_1}}};
          {\TypeJ \Gamma {\Prj [d] M} {\Pi \rho_2}}}
\rsp
\ib{\irule[\trule{$\I\Pi$}]
          {\TypeJ \Gamma {M_1} {\Pi \rho_1}}
          {\TypeJ \Gamma {M_2} {\Pi \rho_2}}
          {\EntJ \Gamma {\RowPlusP {\rho_1} {\rho_2} {\rho_3}}};
          {\TypeJ \Gamma {M_1 \Concat M_2} {\Pi \rho_3}}}
\\
\ib{\irule[\trule{$\I\Sigma$}]
          {\TypeJ \Gamma M {\Sigma \rho_1}}
          {\EntJ \Gamma {\Leqp [] {\rho_1} {\rho_2}}};
          {\TypeJ \Gamma {\Inj [] M} {\Sigma \rho_2}}}
\rsp
\ib{\irule[\trule{$\E\Sigma$}]
          {\TypeJ \Gamma {M_1} {\Sigma \rho_1 \to \tau}}
          {\TypeJ \Gamma {M_2} {\Sigma \rho_2 \to \tau}}
          {\EntJ \Gamma {\RowPlusP {\rho_1} {\rho_2} {\rho_3}}};
          {\TypeJ \Gamma {M_1 \Branch M_2} {\Sigma \rho_3 \to \tau}}}
\\
\ib{\irule[\trule{$\Ana$}]
          {\begin{array}{@{}c@{}}
             {\KindJ \Gamma \rho {\RowK \kappa}}
             \isp
             {\KindJ \Gamma \phi {\kappa \to \TypeK}}
             \\
             {\TypeJ \Gamma M {\forall l \co \LabK, u \co \kappa, y_1, z, y_2 \co \RowK \kappa. \, (\RowPlusP {y_1} {\Row {\LabTy l u}} z, \RowPlusP z {y_2} \rho) \then \Sing l \to \phi \, u \to \tau}}
           \end{array}};
          {\TypeJ \Gamma {\Ana [\phi] \, M} {\Sigma (\phi \, \rho) \to \tau}}}
\\          
\ib{\irule[\trule{$\Syn$}]
          {\begin{array}{@{}c@{}}
             {\KindJ \Gamma \rho {\RowK \kappa}}
             \isp
             {\KindJ \Gamma \phi {\kappa \to \TypeK}}
             \\
             {\TypeJ \Gamma M {\forall l \co \LabK, u \co \kappa, y_1, z, y_2 \co \RowK \kappa. \, (\RowPlusP {y_1} {\Row {\LabTy l u}} z, \RowPlusP z {y_2} \rho) \then \Sing l \to \phi \, u}}
           \end{array}};
          {\TypeJ \Gamma {\Syn [\phi] \, M} {\Pi (\phi \, \rho)}}}
\\
\ib{\irule[\trule{$\FoldP$}]
          {\begin{array}{@{}c@{}}
             {M_1 : \forall l \co \LabK, t \co \TypeK, y_1, z, y_2 \co \RowK \kappa. \, (\RowPlusP {y_1} {\Row {\LabTy l u}} z, \RowPlusP z {y_2} \rho) \then \Sing l \to t \to \upsilon}
             \\
             {\TypeJ \Gamma {M_2} {\upsilon \to \upsilon \to \upsilon}}
             \isp
             {\TypeJ \Gamma {M_3} \upsilon}
             \isp
             {\TypeJ \Gamma N {\Pi \rho}}
           \end{array}};
          {\TypeJ \Gamma {\FoldP \, M_1 \, M_2 \, M_3 \, N} \upsilon}}
\end{gather*}
\caption{Typing}
\label{fig:typing}
\end{figure}
\renewcommand\EntJ[2]{#1 \Vdash #2}

{Minimal Rows}
\label{sec:ro-minimal}

\cref{fig:minimal} gives the minimal row theory $\mathcal M$.

\begin{figure}[H]
\renewcommand\EntJ[2]{\EntJS \Mty {#1} {#2}}
\small
\begin{gather*}
\fbox{$\KindJS \Mty \Gamma \rho \kappa$} \; \fbox{$\vphantom\Gamma \EqvJS \Mty \rho \rho$}
\\
% \ib{\irule[\krule{munit}]
%           { };
%           {\KindJS \Mty \Gamma {\Row {}} {\RowK \kappa}}}
% \rsp          
\ib{\irule[\krule{mrow}]
          {\KindJ \Gamma \xi \LabK}
          {\KindJ \Gamma \tau \kappa};
          {\KindJS \Mty \Gamma {\Row {\LabTy \xi \tau}} {\RowK \kappa}}}
\rsp
% \ib{\irule[\erule{munit}]
%           { };
%           {\EqvJS \Mty {\Row {}} {\Row {}}}}
% \rsp
\ib{\irule[\erule{mrow}]
          {\EqvJ \xi {\xi'}}
          {\EqvJ \tau {\tau'}};
          {\EqvJS \Mty {\Row {\LabTy \xi \tau}} {\Row {\LabTy {\xi'} {\tau'}}}}}
\\          
\fbox{$\EntJ \Gamma \pi$}
\\
\ib{\irule[\entrule{ax}]
          {\pi \in \Gamma};
          {\EntJ {\Gamma} \pi}}
\rsp
\ib{\irule[\entrule{refl}]
          { };
          {\EntJ \Gamma {\Leqp [d] \rho \rho}}}
\rsp
\ib{\irule[\entrule{trans}]
          {\EntJ \Gamma {\Leqp [d] {\rho_1} {\rho_2}}}
          {\EntJ \Gamma {\Leqp [d] {\rho_2} {\rho_3}}};
          {\EntJ \Gamma {\Leqp [d] {\rho_1} {\rho_3}}}}
\\
\ib{\irule[\entrule{$\equiv$}]
          {\EntJ \Gamma {\pi_1}}
          {\pi_1 \equiv \pi_2};
          {\EntJ \Gamma {\pi_2}}}
\rsp
\ib{\irule[\entrule{$\lesssim$lift$_1$}]
          {\EntJ \Gamma {\Leqp [d] {\rho_1} {\rho_2}}};
          {\EntJ \Gamma {\Leqp [d] {\phi\,\rho_1} {\phi\,\rho_2}}}}
\rsp
\ib{\irule[\entrule{$\lesssim$lift$_2$}]
          {\EntJ \Gamma {\Leqp [d] {\rho_1} {\rho_2}}};
          {\EntJ \Gamma {\Leqp [d] {\rho_1\,\tau} {\rho_2\,\tau}}}}
\\
\ib{\irule[\entrule{$\odot$lift$_1$}]
          {\EntJ \Gamma {\RowPlusP {\rho_1} {\rho_2} {\rho_3}}};
          {\EntJ \Gamma {\RowPlusP {\rho_1 \, \tau} {\rho_2 \, \tau} {\rho_3 \, \tau}}}}
\rsp
\ib{\irule[\entrule{$\odot$lift$_2$}]
          {\EntJ \Gamma {\RowPlusP {\rho_1} {\rho_2} {\rho_3}}};
          {\EntJ \Gamma {\RowPlusP {\phi\,\rho_1} {\phi\,\rho_2} {\phi\,\rho_3}}}}
\\
\ib{\irule[\entrule{${\odot}{\lesssim_\Left}$}]
          {\EntJ \Gamma {\RowPlusP {\rho_1} {\rho_2} {\rho_3}}};
          {\EntJ \Gamma {\Leqp [\Left] {\rho_1} {\rho_3}}}}
\rsp
\ib{\irule[\entrule{${\odot}{\lesssim_\Right}$}]
          {\EntJ \Gamma {\RowPlusP {\rho_1} {\rho_2} {\rho_3}}};
          {\EntJ \Gamma {\Leqp [\Right] {\rho_2} {\rho_3}}}}
% \ruleNvm{
%   \ib{\irule[\entrule{$\sqcup$}]
%     {\EntJ \Gamma {\RowPlusP {\rho_1} {\rho_2} {\rho_3}}}
%     {\EntJ \Gamma {\Leqp {\rho_1} {\rho} }}
%     {\EntJ \Gamma {\Leqp {\rho_2} {\rho} }};
%     {\EntJ {\Gamma} {\Leqp {\rho_3} {\rho}}}}}
\end{gather*}
\caption{Minimal row theory $\mathcal M = \langle \vdash_\Mty, \equiv_\Mty, \Vdash_{\Mty} \rangle$}
\label{fig:minimal}
\end{figure}

\section{\IX: The Index Calculus}

\subsection{Syntax}

\begin{figure}[H]
\begin{smalle}
\begin{gather*}
\begin{array}{r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l}
  \text{Term variables} & x \; \alpha % & \text{sort variables} & \alpha %% & & \text{Labels} & \ell & \text{Directions} & d \in \Set {\Left, \Right}
\end{array}
\\[5px]
\begin{doublesyntaxarray}
  \mcl{\text{Sorts}} & \sigma & ::= & \star \mid \U \\
  \mcl{\text{Terms}} & M, N, T & ::= & x \mid \star \mid \Nat \mid \Zero \mid \Suc \, M \mid \\
  & & & & \Ix{M} \mid \FZero \mid \FSuc \; M \mid \\
  & & & &  \top \mid \tt \mid \\
  & & & &  \Pi \alpha \co T. N \mid \lambda x \co T. N \mid M \, N \mid \\
  & & & &  \Sigma \alpha \co T. M \mid (\alpha \co T , M) \mid M.1 \mid M.2  \\
  & & & &  M + N \mid \left\, M \mid \right\, M \mid \Case M M M \\
  & & & &  M \equiv N \mid \Refl \mid \Todo{...} \\
  \mcl{\text{Environments}} & \Gamma & ::= & \varepsilon \mid \Gamma, \alpha : T
\end{doublesyntaxarray}
\end{gather*}
\end{smalle}
\caption{Syntax}
\label{fig:syntax}
\end{figure}

\paragraph{Universes.} \IX{} is stratified by two universes: $\star$, the type of types, and $\mathcal{U}$, the type of $\star$. This is analogous to e.g. Coq/CoC, in which both \Tt{Set} and \Tt{Prop} are impredicative and have type \Tt{Type}.

% https://q.uiver.app/#q=WzAsMyxbMSwwLCJcXHRleHR0dHtUeXBlfSJdLFswLDEsIlxcdGV4dHR0e1NldH0iXSxbMiwxLCJcXHRleHR0dHtQcm9wfSJdLFsxLDBdLFsyLDBdXQ==
\[\begin{tikzcd}
	& {\texttt{Type}} \\
	{\texttt{Set}} && {\texttt{Prop}}
	\arrow[from=2-1, to=1-2]
	\arrow[from=2-3, to=1-2]
\end{tikzcd}\]

\IX{} is exactly the same modulo renaming and without a need for (the proof-irrelevant universe of) \Tt{Prop}.

\subsection{Typing}

\cref{fig:IxRules} gives the rules for three judgments: $\vdash \Gamma$, which states that typing environment $\Gamma$ is well-formed; $\Gamma \vdash M : \sigma$, which states that $M$ is a type with sort $\sigma$; and $\Gamma \vdash M : N$, which states that $M$ has type $N$. You may observe that one could merge the judgments $\Gamma \vdash M : \sigma$ and $\Gamma \vdash M : N$ by incorporating the syntax of $\sigma$ into the term language. (This is not a crazy thing to do in dependent type theory.) I find it is helpful to separate them for two reasons:

\begin{enumerate}
\item The judgment $\Gamma \vdash M : \sigma$ is not actually analogous to a typing judgment, but rather to the judgment $\Gamma \vdash M \; \text{type}$ one would see in MLTT/CoC. We are asserting that $M$ is a type with sort $\sigma$.
\item Definitional equality is different for the two judgments. Definitional equality of types, e.g. $\Gamma \vdash \Pi M_{1} N_{1} = \Pi M_{2} N_{2} : \sigma$, for example, holds if the components are equal; that is to say, definitional equality of types is mostly congruence rules. Definitional equality of terms are \emph{computational laws}, e.g., the computational law for (left) projection of dependent sums is given by $\Gamma \vdash (x \co A , M ).1 = x : A$.
\item Separating the two in the mechanization allows me to index \emph{terms} by \emph{types}:
\begin{verbatim}
data Type : Context → Pre.Term → Set
data Term : (d : Context) → {t : Pre.Term} → Type d t  → Set
\end{verbatim}

Defining terms and types as one AST (indexed by two \Tt{Pre.Term}s) means that \emph{terms can not be intrinsically typed}, as we are forced to define
\begin{verbatim}
data Term : (d : Context) → Pre.Term → Pre.Term → Set
\end{verbatim}

There is a lot of funny business one can do with induction-induction and induction-recursion, but to my knowledge you may not \emph{index} a type by itself in Agda.
\end{enumerate}


\begin{figure}[H]
\small
\begin{gather*}
\fbox{$\EnvJ \Gamma$}
\\
\ib{\irule[\Rule{emp}]{ };{\EnvJ \varepsilon}}
\rsp
\ib{\irule[\Rule{var}]
          {\EnvJ \Gamma}
          {\SortJ \Gamma M \sigma};
          {\EnvJ {\Gamma, x : M}}}
\end{gather*}
\begin{gather*}
\fbox{$\TypeJ \Gamma M \sigma$} \\
\ib{\irule[\Rule{$\star$}]{};{\SortJ \Gamma \star \U}} 
\rsp
\ib{\irule[\Rule{$\top_{\star}$}] {} ; {\SortJ \Gamma \top \star}}
\rsp
\ib{\irule[\Rule{$\top_{\U}$}] {} ; {\SortJ \Gamma \top \U}}
\\
\ib{\irule[\Rule{$Var$}]{\alpha \co \sigma \in \Gamma} ; {\TypeJ \Gamma \alpha \sigma}}
\rsp
\ib{\irule[\Rule{Nat}] {} ; {\SortJ \Gamma \Nat \star}}
\rsp
\ib{\irule[\Rule{Ix}] {\SortJ \Gamma n \Nat} ; {\SortJ \Gamma {\Ix n} \star}} \\
\ib{\irule[\Rule{$\Pi$}]{\SortJ \Gamma M \sigma} {\SortJ {\Gamma, \alpha \co M}{N}{\star}};{\SortJ \Gamma {\Pi \alpha \co M. N} \star }}
\rsp
\ib{\irule[\Rule{$\Sigma$}]{\SortJ \Gamma M \sigma} {\SortJ {\Gamma, \alpha \co M}{N}{\star}};{\SortJ \Gamma {\Sigma \alpha \co M. N} \star }} \\
\ib{\irule[\Rule{$+$}]{\SortJ \Gamma M \star}{\SortJ \Gamma N \star};{\SortJ \Gamma {M + N} {\star}}}
\rsp
\ib{\irule[\Rule{$\equiv$}]{\SortJ \Gamma {M_1} {N_1}} {\SortJ \Gamma {N_1} {\star}} {\SortJ \Gamma {M_2} {N_2}} {\SortJ \Gamma {N_2} {\star}} ; {\SortJ \Gamma {{M_1} \equiv {M_2}} {\star}}}
\end{gather*}

% \ib{\irule{};{}}
\begin{gather*}
\fbox{$\TypeJ \Gamma M N$} \\
\ib{\irule[\Rule{$Var$}]{x \co M \in \Gamma} ; {\TypeJ \Gamma x M}} 
\rsp
\ib{\irule[\Rule{$\tt$}]{};{\TypeJ \Gamma {\tt} \top}} 
\\
\ib{\irule[\Rule{$\Zero$}]{};{\TypeJ \Gamma \Zero \Nat}} 
\rsp
\ib{\irule[\Rule{$\Suc{}$}]{\TypeJ \Gamma n \Nat};{\TypeJ \Gamma {\Suc \, n} \Nat}} 
\rsp
\\
\ib{\irule[\Rule{$\FZero$}]{{\TypeJ \Gamma n \Nat}};{\TypeJ \Gamma \FZero {\Ix (\Suc \, n)}}} 
\rsp
\ib{\irule[\Rule{$\FSuc{}$}]{\TypeJ \Gamma n \Nat}{\TypeJ \Gamma i {\Ix n}};{\TypeJ \Gamma {\FSuc \, i} {\Ix {(\Suc \, n)}}}} 
\\
\ib{\irule[\Rule{$\I\Pi$}]
  {\SortJ \Gamma T \sigma}
  {\TypeJ {\Gamma , x \co T} {M} {N}};
  {\TypeJ \Gamma {\lambda x \co T. M} {\Pi (x \co T). N}}}
\rsp
\ib{\irule[\Rule{$\E\Pi$}]
    {\TypeJ \Gamma M {\Pi(x \co T_1). T_2}} {\TypeJ \Gamma N {T_1}};
    {\TypeJ \Gamma {M \, N} T_2[N/x]}}
\\
 \ib{\irule[\Rule{$\I\Sigma$}]
      {\TypeJ {\Gamma}{M}{T_1}}
      {\TypeJ {\Gamma} {N} {T_2[M/x]}};
      {\TypeJ \Gamma {(M \co T_1, N)} {\Sigma (x \co T_1). T_2}}}
\rsp
 \ib{\irule [\Rule{$\E\Sigma_{1}$}]
     {\TypeJ \Gamma M {\Sigma (x \co T_1). T_2}}; 
     {\TypeJ \Gamma {M.1} T_1}}
\rsp
 \ib{\irule [\Rule{$\E\Sigma_{2}$}]
     {\TypeJ \Gamma M {\Sigma (x \co T_1). T_2}}; 
     {\TypeJ \Gamma {M.2} T_2[M.1/x]}}
\\
\ib{
  \irule [\Rule{$\I\equiv$}]
  {\TypeJ \Gamma M \sigma};
  {\TypeJ \Gamma {\Refl} {M \equiv M}}}
\rsp
\ib{
  \irule [\Rule{conv}]
  {\TypeJ \Gamma M T_1}{\TypeJ \Gamma {T_1 = T_2} {\sigma}};
  {\TypeJ \Gamma M T_2}}
\\
\ib{
  \irule [\Rule{$\E\equiv$}]
      {\mathlarger{\mathlarger{\mathlarger{\substack{ 
        {\TypeJ \Gamma {P} {T_1 \equiv T_2}} \\
        {\Gamma \vdash M : T_1} \\
        {\Gamma \vdash N : T_1} \\
        {\TypeJ {\Gamma, x \co T_1, y \co T_1, p \co x \equiv y} {T} {\star}} \\
        {\TypeJ {\Gamma , z \co T_1} H {T[z/x, z/y, \Refl/p]} }}}}}}
  ;
  {\TypeJ \Gamma {\J H M N P} {T[M/x,N/y,P/p]}}}
\end{gather*}
\caption{Context formation and typing rules for \IX{} terms}
\label{fig:IxRules}
\end{figure}

 Let the meta-syntax $\tau$ denote both sort and term.

\begin{figure}[H]
\small
\begin{gather*}
\fbox{$\TypeJ \Gamma {M = N} \sigma$} \\
\ib{
  \irule[\erule{refl}]
  {\TypeJ \Gamma M \sigma} 
  ;
  {\TypeJ \Gamma {M = M} \sigma}}
\rsp
\ib{
  \irule[\erule{sym}]
  {\TypeJ \Gamma {N = M} \sigma} 
  ;
  {\TypeJ \Gamma {M = N} \sigma}}
\rsp
\ib{
  \irule[\erule{trans}]
  {\TypeJ \Gamma {M = P} \sigma} {{\TypeJ \Gamma {P = N} \sigma}}
  ;
  {\TypeJ \Gamma {M = N} \sigma}}
\end{gather*}
\begin{gather*}
\fbox{$\TypeJ \Gamma {M = N} T$} \\
\ib{
  \irule[\crule{refl}]
  {\TypeJ \Gamma M T} 
  ;
  {\TypeJ \Gamma {M = M} T}}
\rsp
\ib{
  \irule[\crule{sym}]
  {\TypeJ \Gamma {N = M} T} 
  ;
  {\TypeJ \Gamma {M = N} T}}
\rsp
\ib{
  \irule[\crule{trans}]
  {\TypeJ \Gamma {M = P} T} {{\TypeJ \Gamma {P = N} T}}
  ;
  {\TypeJ \Gamma {M = N} T}}
\end{gather*}
\caption{Definitional equality \& computational laws}
\label{fig:IxDefnEq}
\end{figure}




\section{Translation From \RO}

\subsection{Untyped Translation}

We follow the approach of \cite{MorrisM19} and give both typed and untyped translations of \RO types. \cref{fig:translation} describe the untyped translation, which is used to show translational soundness of the typed translation.

\begin{figure}[H]
\begin{gather*}
\fbox{$\Ixed{\kappa}$} \\
\begin{align*}
\vspace{5em}
\Ixed{\TypeK} &= \TypeK \\
\Ixed{\LabK} &= \top \\
\Ixed{\kappa_1 \to \kappa_2} &= \Pi (\alpha : \Ixed{\kappa_1}). \Ixed{\kappa_2} \\
\Ixed{\RowK \kappa} &= \Sigma(n : \Nat). \Pi (j : \Ix  n). \Ixed{\kappa} \\
\end{align*}
\end{gather*}

\begin{gather*}
\fbox{$\Ixed{\sigma}$} \\
\begin{align*}
\vspace{5em}
\Ixed{\alpha} &= \alpha \\
\Ixed{\tau_1 \to \tau_2} &= \Pi (\alpha : \Ixed{\tau_1}).\Ixed{\tau_2} \\
\Ixed{\forall \alpha \co \kappa. \tau} &= \Pi (\alpha : \Ixed{\kappa}).\Ixed{\tau} \\
\Ixed{\lambda \alpha \co \kappa. \tau} &= \Pi (\alpha : \Ixed{\kappa}).\Ixed{\tau} \\
\end{align*}
\end{gather*}

\begin{align*}
\fbox{$\Ixed{M}$} \\
\vspace{5em}
...
\end{align*} \\
\begin{align*}
\fbox{$\Ixed{\pi}$} \\
\vspace{5em}
...
\end{align*}
\caption{A compositional translation of \RO judgments to (untyped) \IX{} terms}
\label{fig:translation}
\end{figure}


\subsection{Typed translation}

\begin{figure}[H]
\small
\begin{gather*}
\fbox{$\Gamma \vdash \tau \leadsto \upsilon : \kappa$}
\\
\ib{\irule[\crule{foo}]{A};{B}} \\
\fbox{$\Gamma \vdash M \leadsto N : \tau$}
\\
\ib{\irule[\crule{foo}]{A};{B}} \\
\fbox{${\EntJ \Gamma \pi} \leadsto N$}
\\
\ib{\irule[\crule{foo}]{A};{B}}  \\
\fbox{${\tau \equiv \upsilon} \leadsto P$}
\\
\ib{\irule[\crule{foo}]{A};{B}} 
\end{gather*}
\caption{Translation of \RO derivations to \IX{} derivations}
\end{figure}

\subsection{Properties of Translation}

\begin{theorem}[Translational Soundness (Types)]
  if $\TypeJ \Gamma \tau \kappa$ such that $\Gamma \vdash \tau \leadsto \upsilon \co \kappa$ then $\SortJ {\Ixed{\Gamma}} \upsilon {\Ixed{\kappa}}$.
\end{theorem}

\Todo{The following is bullshit w.r.t. definitional equality.}
\begin{theorem}[Translational Soundness (Type Equivalence)]
  if $\Gamma \vdash \tau_{1} \leadsto \upsilon_{1} \co \kappa_{1}$ and $\Gamma \vdash \tau_{2} \leadsto \upsilon_{2} \co \kappa_{2}$ such that $\tau_{1} \equiv \tau_{2}$ is derivable in \RO, then $\Ixed{\Gamma} \vdash \upsilon_{1} \equiv \upsilon_{2}$.
\end{theorem}

The next theorems presume an \RO instantiation of the simple row theory.

\begin{theorem}[Translational Soundness (Row combination)]
  if $\Gamma \Vdash \rho_{1} \cdot \rho_{2} \sim \rho_{3} \leadsto N$ then $\Ixed{\Gamma} \vdash N : foobar$.
\end{theorem}

\begin{theorem}[Translational Soundness (Row containment)]
  if $\Gamma \Vdash \rho_{1} \lesssim \rho_{2} \leadsto N$ then $\Ixed{\Gamma} \vdash N : foobar$.
\end{theorem}

Finally,

\begin{theorem}[Translational Soundness]
  if $\TypeJ \Gamma M \tau$ such that $\Gamma \vdash M \leadsto N \co \tau$ then $\SortJ {\Ixed{\Gamma}} M {\Ixed{\tau}}$.
\end{theorem}

\section{Operational semantics of \IX{}}

\section{Recursion}

\Todo{This section will later be incorporated into earlier sections.}

\subsection{Rome, or, \RO with $\mu$}
\begin{figure}[H]
\small
\begin{gather*}
\fbox{\Todo{todo}}
\\
\ib{\irule[\crule{foo}]{A};{B}} \\
\end{gather*}
\caption{Additional \RO judgments for recursion}
\end{figure}

\subsection{Mix, the recursive index calculus}

\begin{figure}[H]
\small
\begin{gather*}
\fbox{\Todo{todo}}
\\
\ib{\irule[\crule{foo}]{A};{B}} \\
\end{gather*}
\caption{Additional \IX{} judgments for recursion}
\end{figure}

\subsection{Translation and properties of translation}

\bibliographystyle{ACM-Reference-Format}
\bibliography{MIx}
\end{document}

