\documentclass[authoryear,acmsmall,screen]{acmart}
\citestyle{acmauthoryear}

\overfullrule=1mm

\usepackage{
  % AH> I don't know how much of these are used, and for what.
  %     (needs untangling.) 
  relsize,
  enumitem,
  xspace,
  mathtools,
  multicol,
  tikz-cd,
  parskip,
  mathrsfs,
  stmaryrd,
  tikz,
  float,
  titlecaps,
  soul,
  upgreek,
  caption,
  graphicx,
  array,
  subcaption,
  % amsmath,
  % amsthm,
  % amssymb,
  bibentry,
  bibunits,
  ./sty/mathwidth,
%  ../sty/sectsty,
  ./sty/commands,
  ./sty/infer,
  ./sty/commands,
  ./sty/higher,
  ./sty/mymath
}

\usepackage{natbib}

% tikz
\usepackage{tikz}
\usepackage{tikz-cd}

\title{Recursive Rows in Rome}

\author{AH \& JGM}

\newcommand\Todo[1]{{\color{red} #1}}
\newcommand\SortJ[3]{\TypeJ {#1} {#2} {#3}}
\newcommand\IX{\textsc{Ix}}
\newcommand\Hix{\textsc{HIx}}
\newcommand\secfig[2]{Figure \ref{fig:#2}, \S\ref{sec:#1}}
\newcommand\Nat{\mathrm{Nat}}
\newcommand\Zero{Z}
\newcommand\FZero{\mathsf{I_0}}
\newcommand\Suc{\mathrm{S}}
\newcommand\FSuc{\mathsf{I_{\Suc}}}
\newcommand\Fin{\mathrm{Fin}}
\newcommand\Ix[1]{\mathrm{Ix} \, #1}
\newcommand\MuIx{\ensuremath{\mu}Ix}
\newcommand\Type{\mathrm{Type}}
\newcommand\FormJ[2]{\ensuremath{#1 \vdash #2 \, \Type}}
\renewcommand\tt{\Tt{tt}}
% \newcommand\Ixed[1]{\ensuremath{(#1)^{\bullet}}}
\newcommand\Ixed[1]{\ensuremath{\Sem{#1}}}
\newcommand\TyPair[3]{\ensuremath{\langle\!\langle #1 \co #2 , #3 \rangle\!\rangle}}

\newcommand\Lift[1]{\ensuremath{\lceil #1 \rceil}}
\newcommand\Fst{\mathrm{fst}}
\newcommand\Snd{\mathrm{snd}}
\newcommand\U{\mathcal{U}}
\newcommand\Pointed[1]{\ensuremath{#1_{\bot}}}
\newcommand\PointedT{\Pointed{\star}}
\newcommand\PointedU{\Pointed{\U}}
\newcommand\J[4]{\mathcal{J} \, #1 \, #2 \, #3 \, #4}
\newcommand\Refl{\mathrm{refl}}
\renewcommand\left{\mathrm{left}}
\renewcommand\right{\mathrm{right}}
\renewcommand\Case{\mathrm{case}}
%\newcommand\CaseN[4]{\ensuremath{\Case_{\mathbb{N}} \, #1 \, \mathrm{of} \{ \Zero \mapsto #2; \Suc\, #3 \mapsto #4 \}}}
% \newcommand\CaseF[4]{\ensuremath{\Case_{\mathrm{Fin}} \, #1 \, \mathrm{of} \{ \FZero \mapsto #2; \FSuc\, #3 \mapsto #4 \}}}
% \newcommand\CaseP[3]{\ensuremath{\Case_{\mathrm{\exists}} \, #1 \, \mathrm{of} \{ (#1, #2) \mapsto #3 \} }}
% \newcommand\CaseS[5]{\ensuremath{\Case_{\mathrm{+}} \, #1 \, \mathrm{of} \, \{ \left \, #2 \mapsto #3 ; \right \, #4 \mapsto #5 \} }}
\newcommand\CaseN[3]{\ensuremath{\Case_{\Nat} \, #1 \, #2 \, #3}}
\newcommand\CaseFZ[2]{\ensuremath{\Case_{\mathrm{Fin}} \, #1 \, #2 }}
\newcommand\CaseP[2]{\ensuremath{\Case_{\mathrm{\exists}} \, #1 \, #2 }}
\newcommand\CaseFS[3]{\ensuremath{\Case_{\mathrm{Fin}} \, #1 \, #2 \, #3 }}
\newcommand\CaseS[3]{\ensuremath{\Case_{\mathrm{+}} \, #1 \, #2 \, #3}}
\newcommand\Rule[1]{(\textsc{#1})}
\newcommand\Safe[1]{\ensuremath{#1 \; \mathrm{Safe}}}
\newcommand\SafeJ[2]{\ensuremath{#1 \vdash #2 \; \mathrm{Safe}}}
\newcommand\Felim[1]{\{\!\!\{#1\}\!\!\}}

\newcommand\New[1]{{\color{blue}#1}}

\begin{document}

\maketitle

\section{\IX: The Index Calculus}

\subsection{Syntax}

\begin{figure}[H]
\begin{smalle}
\begin{gather*}
\begin{array}{r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l@{\qquad}r@{\hspace{5px}}l}
%  \text{Term variables} & x \; \alpha % & \text{sort variables} & \alpha %% & & \text{Labels} & \ell & \text{Directions} & d \in \Set {\Left, \Right}
\end{array}
\\[5px]
\begin{doublesyntaxarray}
  \mcl{\text{Sorts}} & \sigma & ::= & \star \mid \U \\
  \mcl{\text{Terms}} & M, N, T & ::= & \star \mid x \mid \\
  & & & & \Nat \mid \Zero \mid \Suc \, M \mid \\
  & & & & \CaseN M N T \mid \\
  & & & & \Ix{M} \mid \FZero \mid \FSuc \; M \mid \\
  & & & & \CaseFZ M N \mid \CaseFS M N T \mid \\
  & & & & \Felim {M_1,...,M_n} \mid \\
  & & & &  \top \mid \tt \mid \bot \mid \\
  & & & &  \forall \alpha \co T. N \mid \lambda x \co T. N \mid M \, N \mid \\
  & & & &  \exists \alpha \co T. M \mid \TyPair \alpha T M \mid \CaseP M N \mid \\
  & & & &  M + N \mid \left\, M \mid \right\, M \mid \\
  & & & & \CaseS M N T \mid \\
  & & & &  M \equiv N \mid \Refl \, T \, M \, N \mid \\
  \mcl{\text{Environments}} & \Gamma & ::= & \varepsilon \mid \Gamma, \alpha : T
\end{doublesyntaxarray}
\end{gather*}
\end{smalle}
\caption{Syntax}
\label{fig:syntax}
\end{figure}

\subsubsection{Meta-syntax \& syntactic sugar}

Let
\begin{enumerate}
\item $\tau \to \upsilon$ denote the unnamed quantification $\forall (\_ : \tau). \upsilon$;
\item $0,1,2,...$ denote object-level natural numbers in the intuitive fashion; \item $i_{n}$ denote the index obtained by $n$ applications of $\FSuc$ to $\FZero$; and
\item the syntax 

\[
\Felim {M_1,...,M_n}
\]

denote the large elimination of a known, finite quantity of indices to types $M_{1},...,M_{n}$, elaborated by the equations:

\begin{align*}
  \Felim{M_{1}} &:= \lambda (i : \Ix{1}). \CaseFZ i M_{1} \\
  \Felim{M_{1},...,M_{n}} &:= \lambda (i : \Ix{n}). \CaseFS i {M_{n}} \Felim{M_{1},...,M_{n-1}}
\end{align*}


\end{enumerate}

\subsection{Typing}

\Todo{Many of these are fucked or in need of repair; refer to the translation as the SSOT.}

\begin{figure}[H]
\small
\begin{gather*}
\fbox{$\EnvJ \Gamma$}
\\
\ib{\irule[\Rule{emp}]{ };{\EnvJ \varepsilon}}
\rsp
\ib{\irule[\Rule{var}]
          {\EnvJ \Gamma}
          {\SortJ \Gamma M \sigma};
          {\EnvJ {\Gamma, x : M}}}
\end{gather*}

\begin{gather*}
\fbox{$\TypeJ \Gamma M \sigma$} 
\\
\ib{\irule[\Rule{$\star$}] ; {\TypeJ \Gamma \star \U}} 
\rsp
\ib{\irule[\Rule{$\top$}] {} ; {\SortJ \Gamma \top \sigma}}
\rsp
\ib{\irule[\Rule{Nat}] {} ; {\SortJ \Gamma \Nat \star}}
\rsp
\ib{\irule[\Rule{Ix}] {\SortJ \Gamma n \Nat} ; {\SortJ \Gamma {\Ix n} \star}} \\
\ib{\irule[\Rule{$\forall$}]{\SortJ \Gamma M \sigma_1} {\SortJ {\Gamma, \alpha \co M}{N}{\sigma_2}};{\SortJ \Gamma {\forall \alpha \co M. N} \sigma_2}}
\rsp
\ib{\irule[\Rule{$\exists$}]{\SortJ \Gamma M \sigma_1} {\SortJ {\Gamma, \alpha \co M}{N}{\sigma_2}};{\SortJ \Gamma {\exists \alpha \co M. N} \sigma_2}} \\
\ib{\irule[\Rule{$+$}]{\SortJ \Gamma M \sigma}{\SortJ \Gamma N \sigma};{\SortJ \Gamma {M + N} {\sigma}}}
\rsp
\ib{
  \irule[\Rule{$\equiv$}]
  {\SortJ \Gamma {M} {\sigma}}
  {\SortJ \Gamma {N} {\sigma}};
  {\SortJ \Gamma {{M} \equiv {N}} {\sigma}}}
\end{gather*}
\caption{Context and type formation rules}
\label{fig:formation}
\end{figure}

\begin{figure}[H]
\small
% \ib{\irule{};{}}
\begin{gather*}
\fbox{$\TypeJ \Gamma M N$} \\
\ib{\irule[\Rule{Var}] {\EnvJ \Gamma}{x \co M \in \Gamma} ; {\TypeJ \Gamma x M}} 
\rsp
\ib{\irule[\Rule{$\tt$}]{\EnvJ \Gamma};{\TypeJ \Gamma {\tt} \top}} 
\\
\ib{\irule[\Rule{$\Zero$}]{\EnvJ \Gamma};{\TypeJ \Gamma \Zero \Nat}} 
\rsp
\ib{\irule[\Rule{$\Suc{}$}]{\TypeJ \Gamma n \Nat};{\TypeJ \Gamma {\Suc \, n} \Nat}} 
\rsp
\\
\ib{\irule[\Rule{$\FZero$}]{{\TypeJ \Gamma n \Nat}};{\TypeJ \Gamma \FZero {\Ix (\Suc \, n)}}} 
\rsp
\ib{\irule[\Rule{$\FSuc{}$}]{\TypeJ \Gamma n \Nat}{\TypeJ \Gamma i {\Ix n}};{\TypeJ \Gamma {\FSuc \, i} {\Ix {(\Suc \, n)}}}} 
\rsp
\ib{\irule{};{\TypeJ \Gamma }}
\\
\ib{\irule[\Rule{$\I\forall$}]
  {\SortJ \Gamma T \star}
  {\TypeJ {\Gamma , x \co T} {M} {N}};
  {\TypeJ \Gamma {\lambda x \co T. M} {\forall (x \co T). N}}}
\rsp
\ib{\irule[\Rule{$\E\forall$}]
    {\TypeJ \Gamma M {\forall(x \co T_1). T_2}} {\TypeJ \Gamma N {T_1}};
    {\TypeJ \Gamma {M \, N} T_2[N/x]}}
\\
 \ib{\irule[\Rule{$\I\exists$}]
      {\TypeJ {\Gamma}{M}{T_1}}
      {\TypeJ {\Gamma} {N} {T_2[M/x]}};
      {\TypeJ \Gamma {(M \co T_1, N)} {\exists (x \co T_1). T_2}}}
\rsp
 \ib{\irule [\Rule{$\E\exists_{1}$}]
     {\TypeJ \Gamma M {\Sigma (x \co T_1). T_2}}; 
     {\TypeJ \Gamma {\Fst \, M} T_1}}
\rsp
 \ib{\irule [\Rule{$\E\exists_{2}$}]
     {\TypeJ \Gamma M {\Sigma (x \co T_1). T_2}}; 
     {\TypeJ \Gamma {\Snd \, M} T_1[\Fst \, M/x]}}
\\
\ib{
  \irule [\Rule{$\I\equiv$}]
  {\TypeJ \Gamma M \sigma};
  {\TypeJ \Gamma {\Refl} {M \equiv M}}}
\rsp
\ib{
  \irule [\Rule{conv}]
  {\TypeJ \Gamma M T_1}
  {\TypeJ \Gamma {T_1 = T_2} {\sigma}}
  {\Safe \sigma};
  {\TypeJ \Gamma M T_2}}
\\
\ib{
  \irule [\Rule{$\E\equiv$}]
      {\mathlarger{\mathlarger{\mathlarger{\substack{ 
        {\TypeJ \Gamma {P} {T_1 \equiv T_2}} \\
        {\Gamma \vdash M : T_1} \\
        {\Gamma \vdash N : T_1} \\
        {\TypeJ {\Gamma, x \co T_1, y \co T_1, p \co x \equiv y} {T} {\star}} \\
        {\TypeJ {\Gamma , z \co T_1} H {T[z/x, z/y, \Refl/p]} }}}}}}
  ;
  {\TypeJ \Gamma {\J H M N P} {T[M/x,N/y,P/p]}}}
\end{gather*}
\caption{Typing rules. \Todo{Missing nat, fin, and sum elimination. Fin elimination should have special case for $\Ix 1$.}}
\label{fig:IxRules}
\end{figure}

\begin{figure}[H]
\small
\begin{gather*}
\fbox{$\TypeJ \Gamma {M = N} \sigma$} \\
\ib{
  \irule[\erule{refl}]
  {\TypeJ \Gamma M \sigma} 
  ;
  {\TypeJ \Gamma {M = M} \sigma}}
\rsp
\ib{
  \irule[\erule{sym}]
  {\TypeJ \Gamma {N = M} \sigma} 
  ;
  {\TypeJ \Gamma {M = N} \sigma}}
\rsp
\ib{
  \irule[\erule{trans}]
  {\TypeJ \Gamma {M = P} \sigma} {{\TypeJ \Gamma {P = N} \sigma}}
  ;
  {\TypeJ \Gamma {M = N} \sigma}}
\end{gather*}
\begin{gather*}
\fbox{$\TypeJ \Gamma {M = N} T$} \\
\ib{
  \irule[\crule{refl}]
  {\TypeJ \Gamma M T} 
  ;
  {\TypeJ \Gamma {M = M} T}}
\rsp
\ib{
  \irule[\crule{sym}]
  {\TypeJ \Gamma {N = M} T} 
  ;
  {\TypeJ \Gamma {M = N} T}}
\rsp
\ib{
  \irule[\crule{trans}]
  {\TypeJ \Gamma {M = P} T} {{\TypeJ \Gamma {P = N} T}}
  ;
  {\TypeJ \Gamma {M = N} T}}
\end{gather*}
\caption{Definitional equality \& computational laws}
\label{fig:IxDefnEq}
\end{figure}

\subsection{A Comparison to $\lambda^{\Pi\mathcal{U}\mathbb{N}}$ \cite{AbelOV18}}


\section{Translation From \RO}

\subsection{Untyped Translation}

We follow the approach of \cite{MorrisM19} and give both typed and untyped translations of \RO types. \cref{fig:translation} describe the untyped translation, which is used to show translational soundness of the typed translation (\cref{fig:translation}).


\begin{figure}[H]
\begin{gather*}
\fbox{$\Ixed{\kappa}$} \\
\begin{align*}
\vspace{5em}
\Ixed{\TypeK} &= \TypeK \\
\Ixed{\LabK} &= \top \\
\Ixed{\kappa_1 \to \kappa_2} &= \Ixed{\kappa_1} \to \Ixed{\kappa_2} \\
\Ixed{\RowK \kappa} &= \exists(n : \Nat). \Ix  n \to \Ixed{\kappa} \\
\end{align*}
\end{gather*}
\begin{gather*}
\fbox{$\Ixed{\KindJ \Gamma \tau \kappa}$} \\
\begin{align*}
\vspace{5em}
\Ixed{\TypeJ \Gamma \alpha \kappa} &= \alpha \\
\Ixed{\TypeJ \Gamma {\tau_1 \to \tau_2} \star} &= \Ixed{\tau_1} \to \Ixed{\tau_2} \\
\Ixed{\TypeJ \Gamma {\forall \alpha \co \kappa. \tau} \star} &= \forall (\alpha : \Ixed{\kappa}).\Ixed{\tau} \\
\Ixed{\TypeJ \Gamma {\lambda \alpha \co \kappa. \tau} {\kappa \to \kappa'}} &= \forall (\alpha : \Ixed{\kappa}).\Ixed{\tau} \\
\Ixed{\TypeJ \Gamma {\pi \then \tau} \kappa} &= \forall (\alpha : \Ixed{\pi}). \Ixed{\tau} \\
\Ixed{\TypeJ \Gamma {\tau \, \upsilon} \kappa} &= \Ixed{\tau} \, \Ixed{\upsilon} \\
\Ixed{\TypeJ \Gamma \ell {\LabK}} &= \top  \\
\Ixed{\TypeJ \Gamma {\Sing \xi} \star} &= \top  \\
\Ixed{\TypeJ \Gamma {\LabTy \xi \tau} \kappa}&= \Ixed{\tau}  \\
\Ixed{\TypeJ \Gamma {\Pi \rho} \star}&= \CaseP {\Ixed{\rho}} {(\lambda n : \Nat. \lambda P : \Ix{n} \to \star. \forall (i : \Ix{n}). P \, i)}\\
\Ixed{\TypeJ \Gamma {\Sigma \rho} \star}&= \CaseP {\Ixed{\rho}} {(\lambda n : \Nat. \lambda P : \Ix{n} \to \star. \exists (i : {\Ix n}). P \, i)}\\
\Ixed{\TypeJ \Gamma \epsilon {\RowK \kappa}} &= \TyPair 0 \Nat \bot \\
\Ixed{\TypeJ \Gamma {\rho \, \Lift{\upsilon}} {\RowK {\kappa_{2}}}} &= \CaseP {\Ixed \rho} {(\lambda n : \Nat. \lambda (P : \Ix n \to \Sem{\kappa_{1}} \to \Sem{\kappa_{2}}).  \TyPair {n} {\Nat} {\lambda (j : \Ix n). (P \, j) \Sem{\tau} })} \\
\Ixed{\TypeJ \Gamma {\Lift{\tau} \, \rho} {\RowK {\kappa_{2}}}} &= \CaseP {\Ixed \rho} {(\lambda n : \Nat. \lambda (P : \Ix n \to \Sem{\kappa_{1}}).  \TyPair {n} {\Nat} {\lambda (j : \Ix n). \Sem{\tau} (P \, j) })} \\
\Ixed{\TypeJ \Gamma {\LabRow \xi \tau} {\RowK \kappa}}&= \TyPair {1} {\Nat} {\Felim{\Sem{\tau}}}  \\
\end{align*}
\end{gather*}

\begin{align*}
\fbox{$\Ixed{\Gamma \vdash \pi : \kappa}$} \\
\vspace{5em}
...
\end{align*}
\caption{A compositional translation of typed \RO kinds and predicates to untyped \IX{} terms}
\label{fig:translation}
\end{figure}

\begin{figure}[H]
\begin{align*}
\fbox{$\Ixed{\Gamma \Vdash \pi}$} \\
\vspace{5em}
...
\end{align*} \\
\begin{align*}
\fbox{$\Ixed{\TypeJ \Gamma M \tau}$} \\
\vspace{5em}
...
\end{align*}
\caption{Translating predicates and terms}
\label{fig:translation}
\end{figure}

\subsection{Typed translation}

\begin{figure}[H]
\small
\begin{gather*}
\fbox{$\Gamma \vdash \tau \leadsto \upsilon : \kappa$}
\\
\ib{\irule[\crule{foo}]{A};{B}} \\
\fbox{$\Gamma \vdash M \leadsto N : \tau$}
\\
\ib{\irule[\crule{foo}]{A};{B}} \\
\fbox{${\EntJ \Gamma \pi} \leadsto N$}
\\
\ib{\irule[\crule{foo}]{A};{B}}  \\
\fbox{${\tau \equiv \upsilon} \leadsto P$}
\\
\ib{\irule[\crule{foo}]{A};{B}} 
\end{gather*}
\caption{Translation of \RO derivations to \IX{} derivations}
\end{figure}

\subsection{Properties of Translation}

Presume an \RO instantiation of the simple row theory. A lot of this is likely bullshit.

\begin{theorem}[Translational Soundness (Types)]
  if $\TypeJ \Gamma \tau \kappa$ such that $\Gamma \vdash \tau \leadsto \upsilon \co \kappa$ then $\SortJ {\Ixed{\Gamma}} \upsilon {\Ixed{\kappa}}$.
\end{theorem}

\begin{theorem}[Translational Soundness (Type Equivalence)]
  if
  \begin{enumerate}
  \item $\Gamma \vdash \tau_{1} \leadsto \upsilon_{1} \co \kappa_{1}$;
  \item $\Gamma \vdash \tau_{2} \leadsto \upsilon_{2} \co \kappa_{2}$; and
  \item $\tau_{1} \equiv \tau_{2} \leadsto P$,
  \end{enumerate}
 then $\Ixed{\Gamma} \vdash P : \upsilon_{1} \equiv \upsilon_{2}$.
\end{theorem}

\begin{theorem}[Translational Soundness (Of Predicates)]
  if $\Gamma \Vdash \pi$ such that $\Gamma \Vdash \pi \leadsto N$ then $\Ixed{\Gamma} \vdash N : \Ixed{\pi}$.
\end{theorem}

Finally,

\begin{theorem}[Translational Soundness]
  if $\TypeJ \Gamma M \tau$ such that $\Gamma \vdash M \leadsto N \co \tau$ then $\SortJ {\Ixed{\Gamma}} N {\Ixed{\tau}}$.
\end{theorem}


\section{Operational semantics}


\bibliographystyle{ACM-Reference-Format}
\bibliography{MIx}
\end{document}

